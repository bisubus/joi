{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///joi-browser.min.js","webpack:///webpack/bootstrap 25e58d7788228f1405cc?dff7","webpack:///D:/Web/home/bisubus/joi-browser/lib/index.js?7435","webpack:///D:/Web/home/bisubus/joi-browser/lib/any.js?6bf9","webpack:///./~/buffer/index.js?1a55","webpack:///./~/buffer/~/base64-js/lib/b64.js?83f7","webpack:///./~/buffer/~/ieee754/index.js?3969","webpack:///./~/buffer/~/is-array/index.js?aaf1","webpack:///D:/Web/home/bisubus/joi-browser/~/hoek/lib/index.js?acd6","webpack:///D:/Web/home/bisubus/joi-browser/lib/browser-stub.js?d4c8","webpack:///D:/Web/home/bisubus/joi-browser/~/webpack/~/node-libs-browser/~/path-browserify/index.js?6100","webpack:///D:/Web/home/bisubus/joi-browser/lib/browser-util.js?fa2c","webpack:///D:/Web/home/bisubus/joi-browser/~/inherits/inherits_browser.js?7a28","webpack:///D:/Web/home/bisubus/joi-browser/~/hoek/lib/escape.js?f56d","webpack:///D:/Web/home/bisubus/joi-browser/lib/ref.js?fb34","webpack:///D:/Web/home/bisubus/joi-browser/lib/errors.js?2828","webpack:///D:/Web/home/bisubus/joi-browser/lib/language.js?1dce","webpack:///D:/Web/home/bisubus/joi-browser/lib/cast.js?753e","webpack:///D:/Web/home/bisubus/joi-browser/lib/date.js?afbe","webpack:///D:/Web/home/bisubus/joi-browser/lib/browser-moment.js?ec30","webpack:///D:/Web/home/bisubus/joi-browser/lib/string.js?8690","webpack:///D:/Web/home/bisubus/joi-browser/lib/browser-net.js?c990","webpack:///D:/Web/home/bisubus/joi-browser/~/is-ipv6-node/index.js?16b1","webpack:///D:/Web/home/bisubus/joi-browser/~/is-ipv6-node/lib/is-ipv6.js?cf2e","webpack:///D:/Web/home/bisubus/joi-browser/~/isemail/lib/index.js?d41f","webpack:///D:/Web/home/bisubus/joi-browser/lib/string/uri.js?a6bd","webpack:///D:/Web/home/bisubus/joi-browser/lib/string/rfc3986.js?68c0","webpack:///D:/Web/home/bisubus/joi-browser/lib/string/ip.js?c112","webpack:///D:/Web/home/bisubus/joi-browser/lib/number.js?ffb3","webpack:///D:/Web/home/bisubus/joi-browser/lib/boolean.js?1b85","webpack:///D:/Web/home/bisubus/joi-browser/lib/alternatives.js?72b4","webpack:///D:/Web/home/bisubus/joi-browser/lib/object.js?2220","webpack:///D:/Web/home/bisubus/joi-browser/~/topo/lib/index.js?af2f","webpack:///D:/Web/home/bisubus/joi-browser/lib/array.js?6617","webpack:///D:/Web/home/bisubus/joi-browser/lib/binary.js?c8cb"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Any","Cast","Ref","internals","alternatives","array","boolean","binary","date","number","object","string","any","clone","alt","arguments","length","apply","bool","func","_func","keys","ref","create","isRef","validate","value","last","callback","count","options","schema","compile","_validateWithOptions","describe","err","hasOwnProperty","message","path","assert","attempt","result","error","annotate","Error","Buffer","Hoek","Errors","Alternatives","defaults","abortEarly","convert","allowUnknown","skipFunctions","stripUnknown","language","presence","raw","strip","noDefaults","checkOptions","optionType","context","Object","i","key","opt","type","values","Array","isArray","slice","indexOf","join","isJoi","_type","_settings","_valids","Set","_invalids","_tests","_refs","_flags","_description","_unit","_notes","_tags","_examples","_meta","_inner","prototype","isImmutable","obj","getPrototypeOf","concatSettings","inners","concat","tmpObj","keysToRestore","merge","isObject","source","target","j","sourceKey","push","_test","name","arg","allowOnly","strict","isStrict","undefined","isRaw","_allow","flatten","remove","add","allow","valid","only","equal","invalid","disallow","not","required","exist","optional","forbidden","applyFunctionToChildren","children","fn","args","extraChildren","map","child","description","empty","_obj","when","then","otherwise","is","desc","notes","tags","meta","example","_validate","errors","process","unit","_try","e","state","reference","_this","originalValue","parent","finish","finalValue","defaultValue","isDeepDefault","has","insensitive","_base","base","valids","stripUndefined","test","settings","flags","flag","examples","invalids","rules","validator","item","label","reach","_set","refs","Date","isBuffer","filter","items","getTime","toLowerCase","toString","tKeys","sKeys","applyToDefaults","global","typedArraySupport","Bar","arr","Uint8Array","foo","constructor","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","fromNumber","fromString","fromObject","that","allocate","checked","encoding","write","fromBuffer","fromArray","TypeError","ArrayBuffer","buffer","fromTypedArray","fromArrayBuffer","fromArrayLike","fromJsonObject","copy","_augment","data","__proto__","_isBuffer","fromPool","poolSize","rootParent","RangeError","SlowBuffer","subject","buf","len","loweredCase","utf8ToBytes","base64ToBytes","slowToString","start","end","Infinity","hexSlice","utf8Slice","asciiSlice","binarySlice","base64Slice","utf16leSlice","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","isNaN","utf8Write","blitBuffer","asciiWrite","asciiToBytes","binaryWrite","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","String","fromCharCode","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","replace","INVALID_BASE64_RE","trim","n","units","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","b","compare","a","x","y","isEncoding","list","pos","equals","inspect","match","val","byteOffset","arrayIndexOf","foundIndex","get","readUInt8","set","v","writeUInt8","isFinite","swap","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","read","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","fill","toArrayBuffer","BP","toLocaleString","lookup","decode","elt","code","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","L","l","tmp","placeHolders","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","rt","abs","log","LN2","Crypto","Path","Util","Escape","seen","orig","newObj","cloneDeep","RegExp","proto","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","defineProperty","isNullOverride","isMergeArrays","cloneWithShallow","storage","store","restore","reachSet","split","segment","applyToDefaultsWithShallow","deepEqual","part","found","unique","index","mapToObject","intersect","array1","array2","justFirst","common","hash","contain","valuePairs","compareFlags","deep","hasOnly","hasPart","misses","matches","pattern","escapeRegex","regex","leftovers","$0","$1","matched","once","chain","separator","functions","reachTemplate","template","formatStack","stack","trace","getFileName","getLineNumber","getColumnNumber","getFunctionName","isConstructor","formatTrace","display","row","callStack","v8","prepareStackTrace","capture","captureStackTrace","displayStack","abortThrow","abort","hideStack","env","NODE_ENV","exit","condition","msgs","msg","stringify","Timer","ts","reset","now","elapsed","Bench","hrtime","base64urlEncode","base64urlDecode","escapeHeaderAttribute","attribute","escapeHtml","escapeJavaScript","nextTick","method","_hoekOnce","wrapped","isAbsolutePath","platform","isAbsolute","isInteger","parseFloat","ignore","inherits","format","transform","results","sourcePath","shift","uniqueFilename","extension","resolve","pid","randomBytes","JSON","shallow","normalizeArray","parts","allowAboveRoot","up","splice","unshift","xs","f","splitPathRe","splitPath","filename","exec","resolvedPath","resolvedAbsolute","cwd","normalize","trailingSlash","paths","relative","from","to","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","dir","basename","extname","ctor","superCtor","super_","enumerable","writable","configurable","TempCtor","input","escaped","charCode","isSafe","escapeJavaScriptChar","escapeHtmlChar","padLeft","hexValue","namedEscape","namedHtml","safeCharCodes","38","60","62","34","160","162","163","164","169","174","safe","validationOptions","isContext","contextPrefix","depth","Language","wrapArrays","Err","partial","localized","hasKey","skipKey","messages","isSecure","normalized","details","processErrors","localErrors","detail","getPath","reason","_object","recursePath","_x","_again","it","reachedItem","safeStringify","spaces","serializer","cycleReplacer","thisPos","placeholders","arrWithPlaceholders","seg","arrayLabel","objectLabel","replacement","appended","$2","unknown","default","includes","includesSingle","includesOne","includesOneSingle","includesRequiredUnknowns","includesRequiredKnowns","includesRequiredBoth","excludes","excludesSingle","ordered","orderedLength","sparse","isoDate","function","with","without","missing","xor","or","and","nand","rename","multiple","override","less","greater","float","integer","negative","positive","precision","alphanum","token","email","uri","uriCustomScheme","guid","hex","hostname","lowercase","uppercase","creditCard","ip","ipVersion","config","Moment","invalidDate","isIsoDate","isoString","toDate","isValid","isNow","compareTo","every","iso","_isIsoDate","Net","Isemail","JoiDate","Uri","Ip","uriRegex","createUriRegex","ipRegex","createIpRegex","toLocaleUpperCase","toLocaleLowerCase","replacements","sum","char","check","ignoreCase","isEmailOptions","checkDNS","tldWhitelist","minDomainAtoms","errorLevel","ipOptions","cidr","cidrs","version","versions","uriOptions","customScheme","scheme","regex2","isIPv6","Dns","hasOwn","defaultThreshold","maxIPv6Groups","categories","dnsWarn","rfc5321","cfws","deprecated","rfc5322","diagnoses","dnsWarnNoMXRecord","dnsWarnNoRecord","rfc5321TLD","rfc5321TLDNumeric","rfc5321QuotedString","rfc5321AddressLiteral","cfwsComment","cfwsFWS","deprecatedLocalPart","deprecatedFWS","deprecatedQTEXT","deprecatedQP","deprecatedComment","deprecatedCTEXT","deprecatedIPv6","deprecatedCFWSNearAt","rfc5322Domain","rfc5322TooLong","rfc5322LocalTooLong","rfc5322DomainTooLong","rfc5322LabelTooLong","rfc5322DomainLiteral","rfc5322DomainLiteralOBSDText","rfc5322IPv6GroupCount","rfc5322IPv62x2xColon","rfc5322IPv6BadCharacter","rfc5322IPv6MaxGroups","rfc5322IPv6ColonStart","rfc5322IPv6ColonEnd","errExpectingDTEXT","errNoLocalPart","errNoDomain","errConsecutiveDots","errATEXTAfterCFWS","errATEXTAfterQS","errATEXTAfterDomainLiteral","errExpectingQPair","errExpectingATEXT","errExpectingQTEXT","errExpectingCTEXT","errBackslashEnd","errDotStart","errDotEnd","errDomainHyphenStart","errDomainHyphenEnd","errUnclosedQuotedString","errUnclosedComment","errUnclosedDomainLiteral","errFWSCRLFx2","errFWSCRLFEnd","errCRNoLF","errUnknownTLD","errDomainTooShort","components","localpart","domain","literal","contextComment","contextFWS","contextQuotedString","contextQuotedPair","defer","bind","setTimeout","specials","body","Function","ipV4","ipV6","checkIpV6","validDomain","tldAtom","tldBlacklist","diagnose","threshold","maxResult","updateResult","prev","prevToken","parseData","local","atomData","locals","domains","elementCount","elementLength","crlfCount","hyphenFlag","assertEnd","emailLength","addressLiteral","matchesIP","maxGroups","groups","lastIndexOf","pop","dnsPositive","finishImmediately","finishResult","dnsDomain","resolveMx","mxRecords","NODATA","done","handleRecords","records","resolveCname","resolve4","resolve6","diag","RFC3986","optionalScheme","hierPart","query","fragment","rfc3986","generate","digit","digitOnly","alpha","alphaOnly","hexDigit","hexDigitOnly","unreserved","subDelims","pctEncoded","pchar","pcharOnly","zeroPad","decOctect","IPv4address","h16","ls32","IPv6SixHex","IPv6FiveHex","IPv6FourHex","IPv6ThreeHex","IPv6TwoHex","IPv6OneHex","IPv6NoneHex","IPv6NoneHex2","IPv6NoneHex3","IPv6address","IPvFuture","userinfo","IPLiteral","regName","host","port","authority","segmentNz","pathAbEmpty","pathAbsolute","pathRootless","ipv4","ipv6","ipvfuture","isNumber","round","precisionRx","places","decimals","Boolean","lower","failed","schemas","cast","Topo","renames","dependencies","patterns","parse","parseErr","valueKeys","renamed","ignoreUndefined","alias","unprocessed","localState","unprocessedKeys","rule","dep","peers","topo","after","group","castErr","nodes","_dependency","requiredKeys","optionalKeys","renameDefaults","groupChildren","sort","grouped","childGroup","substring","groupedChildren","peer","present","aon","main","allPresent","_items","before","forEach","node","seq","_sort","others","other","mergeSort","graph","graphAfters","graphNodes","expandedGroups","graphNodeItems","k","afterNodes","ancestors","visited","sorted","next","shouldSeeCount","seenCount","seqIndex","sortedNodes","sortedItem","fastSplice","ordereds","inclusions","exclusions","requireds","converted","wasArray","single","checkItems","previousErrors","errored","il","requiredChecks","jl","inclusion","previousCheck","fillMissedErrors","fillOrderedErrors","knownMisses","unknownMisses","patk","requiredOrdereds","orderedItems","enabled","Binary"],"mappings":"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","file":"joi-browser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"joi\"] = factory();\n\telse\n\t\troot[\"joi\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"joi\"] = factory();\n\telse\n\t\troot[\"joi\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!**********************!*\\\n  !*** ./lib/index.js ***!\n  \\**********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Cast = __webpack_require__(/*! ./cast */ 15);\n\tvar Ref = __webpack_require__(/*! ./ref */ 12);\n\t\n\t// Declare internals\n\t\n\tvar internals = {\n\t    alternatives: __webpack_require__(/*! ./alternatives */ 28),\n\t    array: __webpack_require__(/*! ./array */ 31),\n\t    boolean: __webpack_require__(/*! ./boolean */ 27),\n\t    binary: __webpack_require__(/*! ./binary */ 32),\n\t    date: __webpack_require__(/*! ./date */ 16),\n\t    number: __webpack_require__(/*! ./number */ 26),\n\t    object: __webpack_require__(/*! ./object */ 29),\n\t    string: __webpack_require__(/*! ./string */ 18)\n\t};\n\t\n\tinternals.root = function () {\n\t\n\t    var any = new Any();\n\t\n\t    var root = any.clone();\n\t    root.any = function () {\n\t\n\t        return any;\n\t    };\n\t\n\t    root.alternatives = root.alt = function () {\n\t\n\t        return arguments.length ? internals.alternatives['try'].apply(internals.alternatives, arguments) : internals.alternatives;\n\t    };\n\t\n\t    root.array = function () {\n\t\n\t        return internals.array;\n\t    };\n\t\n\t    root.boolean = root.bool = function () {\n\t\n\t        return internals.boolean;\n\t    };\n\t\n\t    root.binary = function () {\n\t\n\t        return internals.binary;\n\t    };\n\t\n\t    root.date = function () {\n\t\n\t        return internals.date;\n\t    };\n\t\n\t    root.func = function () {\n\t\n\t        return internals.object._func();\n\t    };\n\t\n\t    root.number = function () {\n\t\n\t        return internals.number;\n\t    };\n\t\n\t    root.object = function () {\n\t\n\t        return arguments.length ? internals.object.keys.apply(internals.object, arguments) : internals.object;\n\t    };\n\t\n\t    root.string = function () {\n\t\n\t        return internals.string;\n\t    };\n\t\n\t    root.ref = function () {\n\t\n\t        return Ref.create.apply(null, arguments);\n\t    };\n\t\n\t    root.isRef = function (ref) {\n\t\n\t        return Ref.isRef(ref);\n\t    };\n\t\n\t    root.validate = function (value /*, [schema], [options], callback */) {\n\t\n\t        var last = arguments[arguments.length - 1];\n\t        var callback = typeof last === 'function' ? last : null;\n\t\n\t        var count = arguments.length - (callback ? 1 : 0);\n\t        if (count === 1) {\n\t            return any.validate(value, callback);\n\t        }\n\t\n\t        var options = count === 3 ? arguments[2] : {};\n\t        var schema = root.compile(arguments[1]);\n\t\n\t        return schema._validateWithOptions(value, options, callback);\n\t    };\n\t\n\t    root.describe = function () {\n\t\n\t        var schema = arguments.length ? root.compile(arguments[0]) : any;\n\t        return schema.describe();\n\t    };\n\t\n\t    root.compile = function (schema) {\n\t\n\t        try {\n\t            return Cast.schema(schema);\n\t        } catch (err) {\n\t            if (err.hasOwnProperty('path')) {\n\t                err.message = err.message + '(' + err.path + ')';\n\t            }\n\t            throw err;\n\t        }\n\t    };\n\t\n\t    root.assert = function (value, schema, message) {\n\t\n\t        root.attempt(value, schema, message);\n\t    };\n\t\n\t    root.attempt = function (value, schema, message) {\n\t\n\t        var result = root.validate(value, schema);\n\t        var error = result.error;\n\t        if (error) {\n\t            if (!message) {\n\t                error.message = error.annotate();\n\t                throw error;\n\t            }\n\t\n\t            if (!(message instanceof Error)) {\n\t                error.message = message + ' ' + error.annotate();\n\t                throw error;\n\t            }\n\t\n\t            throw message;\n\t        }\n\t\n\t        return result.value;\n\t    };\n\t\n\t    return root;\n\t};\n\t\n\tmodule.exports = internals.root();\n\n/***/ },\n/* 1 */\n/*!********************!*\\\n  !*** ./lib/any.js ***!\n  \\********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\t// Load modules\n\t\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\tvar Ref = __webpack_require__(/*! ./ref */ 12);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\tvar Alternatives = null; // Delay-loaded to prevent circular dependencies\n\tvar Cast = null;\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.defaults = {\n\t    abortEarly: true,\n\t    convert: true,\n\t    allowUnknown: false,\n\t    skipFunctions: false,\n\t    stripUnknown: false,\n\t    language: {},\n\t    presence: 'optional',\n\t    raw: false,\n\t    strip: false,\n\t    noDefaults: false\n\t\n\t    // context: null\n\t};\n\t\n\tinternals.checkOptions = function (options) {\n\t\n\t    var optionType = {\n\t        abortEarly: 'boolean',\n\t        convert: 'boolean',\n\t        allowUnknown: 'boolean',\n\t        skipFunctions: 'boolean',\n\t        stripUnknown: 'boolean',\n\t        language: 'object',\n\t        presence: ['string', 'required', 'optional', 'forbidden', 'ignore'],\n\t        raw: 'boolean',\n\t        context: 'object',\n\t        strip: 'boolean',\n\t        noDefaults: 'boolean'\n\t    };\n\t\n\t    var keys = Object.keys(options);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var opt = optionType[key];\n\t        var type = opt;\n\t        var values = null;\n\t\n\t        if (Array.isArray(opt)) {\n\t            type = opt[0];\n\t            values = opt.slice(1);\n\t        }\n\t\n\t        Hoek.assert(type, 'unknown key ' + key);\n\t        Hoek.assert(typeof options[key] === type, key + ' should be of type ' + type);\n\t        if (values) {\n\t            Hoek.assert(values.indexOf(options[key]) >= 0, key + ' should be one of ' + values.join(', '));\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = internals.Any = function () {\n\t\n\t    Cast = Cast || __webpack_require__(/*! ./cast */ 15);\n\t\n\t    this.isJoi = true;\n\t    this._type = 'any';\n\t    this._settings = null;\n\t    this._valids = new internals.Set();\n\t    this._invalids = new internals.Set();\n\t    this._tests = [];\n\t    this._refs = [];\n\t    this._flags = {/*\n\t                   presence: 'optional',                   // optional, required, forbidden, ignore\n\t                   allowOnly: false,\n\t                   allowUnknown: undefined,\n\t                   default: undefined,\n\t                   forbidden: false,\n\t                   encoding: undefined,\n\t                   insensitive: false,\n\t                   trim: false,\n\t                   case: undefined,                        // upper, lower\n\t                   empty: undefined,\n\t                   func: false\n\t                   */};\n\t\n\t    this._description = null;\n\t    this._unit = null;\n\t    this._notes = [];\n\t    this._tags = [];\n\t    this._examples = [];\n\t    this._meta = [];\n\t\n\t    this._inner = {}; // Hash of arrays of immutable objects\n\t};\n\t\n\tinternals.Any.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n\t\n\tinternals.Any.prototype.clone = function () {\n\t\n\t    var obj = Object.create(Object.getPrototypeOf(this));\n\t\n\t    obj.isJoi = true;\n\t    obj._type = this._type;\n\t    obj._settings = internals.concatSettings(this._settings);\n\t    obj._valids = Hoek.clone(this._valids);\n\t    obj._invalids = Hoek.clone(this._invalids);\n\t    obj._tests = this._tests.slice();\n\t    obj._refs = this._refs.slice();\n\t    obj._flags = Hoek.clone(this._flags);\n\t\n\t    obj._description = this._description;\n\t    obj._unit = this._unit;\n\t    obj._notes = this._notes.slice();\n\t    obj._tags = this._tags.slice();\n\t    obj._examples = this._examples.slice();\n\t    obj._meta = this._meta.slice();\n\t\n\t    obj._inner = {};\n\t    var inners = Object.keys(this._inner);\n\t    for (var i = 0; i < inners.length; ++i) {\n\t        var key = inners[i];\n\t        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.concat = function (schema) {\n\t\n\t    Hoek.assert(schema && schema.isJoi, 'Invalid schema object');\n\t    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n\t\n\t    var obj = this.clone();\n\t\n\t    if (this._type === 'any' && schema._type !== 'any') {\n\t\n\t        // Reset values as if we were \"this\"\n\t        var tmpObj = schema.clone();\n\t        var keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit', '_notes', '_tags', '_examples', '_meta', '_inner'];\n\t\n\t        for (var i = 0; i < keysToRestore.length; ++i) {\n\t            tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n\t        }\n\t\n\t        obj = tmpObj;\n\t    }\n\t\n\t    obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;\n\t    obj._valids.merge(schema._valids, schema._invalids);\n\t    obj._invalids.merge(schema._invalids, schema._valids);\n\t    obj._tests = obj._tests.concat(schema._tests);\n\t    obj._refs = obj._refs.concat(schema._refs);\n\t    Hoek.merge(obj._flags, schema._flags);\n\t\n\t    obj._description = schema._description || obj._description;\n\t    obj._unit = schema._unit || obj._unit;\n\t    obj._notes = obj._notes.concat(schema._notes);\n\t    obj._tags = obj._tags.concat(schema._tags);\n\t    obj._examples = obj._examples.concat(schema._examples);\n\t    obj._meta = obj._meta.concat(schema._meta);\n\t\n\t    var inners = Object.keys(schema._inner);\n\t    var isObject = obj._type === 'object';\n\t    for (var i = 0; i < inners.length; ++i) {\n\t        var key = inners[i];\n\t        var source = schema._inner[key];\n\t        if (source) {\n\t            var target = obj._inner[key];\n\t            if (target) {\n\t                if (isObject && key === 'children') {\n\t                    var keys = {};\n\t\n\t                    for (var j = 0; j < target.length; ++j) {\n\t                        keys[target[j].key] = j;\n\t                    }\n\t\n\t                    for (var j = 0; j < source.length; ++j) {\n\t                        var sourceKey = source[j].key;\n\t                        if (keys[sourceKey] >= 0) {\n\t                            target[keys[sourceKey]] = {\n\t                                key: sourceKey,\n\t                                schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n\t                            };\n\t                        } else {\n\t                            target.push(source[j]);\n\t                        }\n\t                    }\n\t                } else {\n\t                    obj._inner[key] = obj._inner[key].concat(source);\n\t                }\n\t            } else {\n\t                obj._inner[key] = source.slice();\n\t            }\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype._test = function (name, arg, func) {\n\t\n\t    Hoek.assert(!this._flags.allowOnly, 'Cannot define rules when valid values specified');\n\t\n\t    var obj = this.clone();\n\t    obj._tests.push({ func: func, name: name, arg: arg });\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.options = function (options) {\n\t\n\t    Hoek.assert(!options.context, 'Cannot override context');\n\t    internals.checkOptions(options);\n\t\n\t    var obj = this.clone();\n\t    obj._settings = internals.concatSettings(obj._settings, options);\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.strict = function (isStrict) {\n\t\n\t    var obj = this.clone();\n\t    obj._settings = obj._settings || {};\n\t    obj._settings.convert = isStrict === undefined ? false : !isStrict;\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.raw = function (isRaw) {\n\t\n\t    var obj = this.clone();\n\t    obj._settings = obj._settings || {};\n\t    obj._settings.raw = isRaw === undefined ? true : isRaw;\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype._allow = function () {\n\t\n\t    var values = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    for (var i = 0; i < values.length; ++i) {\n\t        var value = values[i];\n\t\n\t        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\t        this._invalids.remove(value);\n\t        this._valids.add(value, this._refs);\n\t    }\n\t};\n\t\n\tinternals.Any.prototype.allow = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._allow.apply(obj, arguments);\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.valid = internals.Any.prototype.only = internals.Any.prototype.equal = function () {\n\t\n\t    Hoek.assert(!this._tests.length, 'Cannot set valid values when rules specified');\n\t\n\t    var obj = this.allow.apply(this, arguments);\n\t    obj._flags.allowOnly = true;\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.invalid = internals.Any.prototype.disallow = internals.Any.prototype.not = function (value) {\n\t\n\t    var obj = this.clone();\n\t    var values = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    for (var i = 0; i < values.length; ++i) {\n\t        value = values[i];\n\t\n\t        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n\t        obj._valids.remove(value);\n\t        obj._invalids.add(value, this._refs);\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.required = internals.Any.prototype.exist = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.presence = 'required';\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.optional = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.presence = 'optional';\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.forbidden = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.presence = 'forbidden';\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.strip = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.strip = true;\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.applyFunctionToChildren = function (children, fn, args, root) {\n\t\n\t    children = [].concat(children);\n\t\n\t    if (children.length !== 1 || children[0] !== '') {\n\t        root = root ? root + '.' : '';\n\t\n\t        var extraChildren = (children[0] === '' ? children.slice(1) : children).map(function (child) {\n\t\n\t            return root + child;\n\t        });\n\t\n\t        throw new Error('unknown key(s) ' + extraChildren.join(', '));\n\t    }\n\t\n\t    return this[fn].apply(this, args);\n\t};\n\t\n\tinternals.Any.prototype['default'] = function (value, description) {\n\t\n\t    if (typeof value === 'function' && !Ref.isRef(value)) {\n\t\n\t        if (!value.description && description) {\n\t\n\t            value.description = description;\n\t        }\n\t\n\t        if (!this._flags.func) {\n\t            Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n\t        }\n\t    }\n\t\n\t    var obj = this.clone();\n\t    obj._flags['default'] = value;\n\t    Ref.push(obj._refs, value);\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.empty = function (schema) {\n\t\n\t    if (schema === undefined) {\n\t        var _obj = this.clone();\n\t        _obj._flags.empty = undefined;\n\t        return _obj;\n\t    }\n\t\n\t    schema = Cast.schema(schema);\n\t\n\t    var obj = this.clone();\n\t    obj._flags.empty = schema;\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.when = function (ref, options) {\n\t\n\t    Hoek.assert(options && typeof options === 'object', 'Invalid options');\n\t    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\t\n\t    var then = options.then ? this.concat(Cast.schema(options.then)) : this;\n\t    var otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;\n\t\n\t    Alternatives = Alternatives || __webpack_require__(/*! ./alternatives */ 28);\n\t    var obj = Alternatives.when(ref, { is: options.is, then: then, otherwise: otherwise });\n\t    obj._flags.presence = 'ignore';\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.description = function (desc) {\n\t\n\t    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\t\n\t    var obj = this.clone();\n\t    obj._description = desc;\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.notes = function (notes) {\n\t\n\t    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n\t\n\t    var obj = this.clone();\n\t    obj._notes = obj._notes.concat(notes);\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.tags = function (tags) {\n\t\n\t    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n\t\n\t    var obj = this.clone();\n\t    obj._tags = obj._tags.concat(tags);\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.meta = function (meta) {\n\t\n\t    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n\t\n\t    var obj = this.clone();\n\t    obj._meta = obj._meta.concat(meta);\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.example = function (value) {\n\t\n\t    Hoek.assert(arguments.length, 'Missing example');\n\t    var result = this._validate(value, null, internals.defaults);\n\t    Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));\n\t\n\t    var obj = this.clone();\n\t    obj._examples = obj._examples.concat(value);\n\t    return obj;\n\t};\n\t\n\tinternals.Any.prototype.unit = function (name) {\n\t\n\t    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\t\n\t    var obj = this.clone();\n\t    obj._unit = name;\n\t    return obj;\n\t};\n\t\n\tinternals._try = function (fn, arg) {\n\t\n\t    var err = undefined;\n\t    var result = undefined;\n\t\n\t    try {\n\t        result = fn.call(null, arg);\n\t    } catch (e) {\n\t        err = e;\n\t    }\n\t\n\t    return {\n\t        value: result,\n\t        error: err\n\t    };\n\t};\n\t\n\tinternals.Any.prototype._validate = function (value, state, options, reference) {\n\t    var _this = this;\n\t\n\t    var originalValue = value;\n\t\n\t    // Setup state and settings\n\t\n\t    state = state || { key: '', path: '', parent: null, reference: reference };\n\t\n\t    if (this._settings) {\n\t        options = internals.concatSettings(options, this._settings);\n\t    }\n\t\n\t    var errors = [];\n\t    var finish = function finish() {\n\t\n\t        var finalValue = undefined;\n\t\n\t        if (!_this._flags.strip) {\n\t            if (value !== undefined) {\n\t                finalValue = options.raw ? originalValue : value;\n\t            } else if (options.noDefaults) {\n\t                finalValue = originalValue;\n\t            } else if (Ref.isRef(_this._flags['default'])) {\n\t                finalValue = _this._flags['default'](state.parent, options);\n\t            } else if (typeof _this._flags['default'] === 'function' && !(_this._flags.func && !_this._flags['default'].description)) {\n\t\n\t                var arg = undefined;\n\t\n\t                if (state.parent !== null && _this._flags['default'].length > 0) {\n\t\n\t                    arg = Hoek.clone(state.parent);\n\t                }\n\t\n\t                var defaultValue = internals._try(_this._flags['default'], arg);\n\t                finalValue = defaultValue.value;\n\t                if (defaultValue.error) {\n\t                    errors.push(Errors.create('any.default', defaultValue.error, state, options));\n\t                }\n\t            } else {\n\t                finalValue = Hoek.clone(_this._flags['default']);\n\t            }\n\t        }\n\t\n\t        return {\n\t            value: finalValue,\n\t            errors: errors.length ? errors : null\n\t        };\n\t    };\n\t\n\t    // Check presence requirements\n\t\n\t    var presence = this._flags.presence || options.presence;\n\t    if (presence === 'optional') {\n\t        if (value === undefined) {\n\t            var isDeepDefault = this._flags.hasOwnProperty('default') && this._flags['default'] === undefined;\n\t            if (isDeepDefault && this._type === 'object') {\n\t                value = {};\n\t            } else {\n\t                return finish();\n\t            }\n\t        }\n\t    } else if (presence === 'required' && value === undefined) {\n\t\n\t        errors.push(Errors.create('any.required', null, state, options));\n\t        return finish();\n\t    } else if (presence === 'forbidden') {\n\t        if (value === undefined) {\n\t            return finish();\n\t        }\n\t\n\t        errors.push(Errors.create('any.unknown', null, state, options));\n\t        return finish();\n\t    }\n\t\n\t    if (this._flags.empty && !this._flags.empty._validate(value, null, internals.defaults).errors) {\n\t        value = undefined;\n\t        return finish();\n\t    }\n\t\n\t    // Check allowed and denied values using the original value\n\t\n\t    if (this._valids.has(value, state, options, this._flags.insensitive)) {\n\t        return finish();\n\t    }\n\t\n\t    if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n\t        errors.push(Errors.create(value === '' ? 'any.empty' : 'any.invalid', null, state, options));\n\t        if (options.abortEarly || value === undefined) {\n\t            // No reason to keep validating missing value\n\t\n\t            return finish();\n\t        }\n\t    }\n\t\n\t    // Convert value and validate type\n\t\n\t    if (this._base) {\n\t        var base = this._base.call(this, value, state, options);\n\t        if (base.errors) {\n\t            value = base.value;\n\t            errors = errors.concat(base.errors);\n\t            return finish(); // Base error always aborts early\n\t        }\n\t\n\t        if (base.value !== value) {\n\t            value = base.value;\n\t\n\t            // Check allowed and denied values using the converted value\n\t\n\t            if (this._valids.has(value, state, options, this._flags.insensitive)) {\n\t                return finish();\n\t            }\n\t\n\t            if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n\t                errors.push(Errors.create('any.invalid', null, state, options));\n\t                if (options.abortEarly) {\n\t                    return finish();\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // Required values did not match\n\t\n\t    if (this._flags.allowOnly) {\n\t        errors.push(Errors.create('any.allowOnly', { valids: this._valids.values({ stripUndefined: true }) }, state, options));\n\t        if (options.abortEarly) {\n\t            return finish();\n\t        }\n\t    }\n\t\n\t    // Helper.validate tests\n\t\n\t    for (var i = 0; i < this._tests.length; ++i) {\n\t        var test = this._tests[i];\n\t        var err = test.func.call(this, value, state, options);\n\t        if (err) {\n\t            errors.push(err);\n\t            if (options.abortEarly) {\n\t                return finish();\n\t            }\n\t        }\n\t    }\n\t\n\t    return finish();\n\t};\n\t\n\tinternals.Any.prototype._validateWithOptions = function (value, options, callback) {\n\t\n\t    if (options) {\n\t        internals.checkOptions(options);\n\t    }\n\t\n\t    var settings = internals.concatSettings(internals.defaults, options);\n\t    var result = this._validate(value, null, settings);\n\t    var errors = Errors.process(result.errors, value);\n\t\n\t    if (callback) {\n\t        return callback(errors, result.value);\n\t    }\n\t\n\t    return { error: errors, value: result.value };\n\t};\n\t\n\tinternals.Any.prototype.validate = function (value, callback) {\n\t\n\t    var result = this._validate(value, null, internals.defaults);\n\t    var errors = Errors.process(result.errors, value);\n\t\n\t    if (callback) {\n\t        return callback(errors, result.value);\n\t    }\n\t\n\t    return { error: errors, value: result.value };\n\t};\n\t\n\tinternals.Any.prototype.describe = function () {\n\t\n\t    var description = {\n\t        type: this._type\n\t    };\n\t\n\t    var flags = Object.keys(this._flags);\n\t    if (flags.length) {\n\t        if (this._flags.empty) {\n\t            description.flags = {};\n\t            for (var i = 0; i < flags.length; ++i) {\n\t                var flag = flags[i];\n\t                description.flags[flag] = flag === 'empty' ? this._flags[flag].describe() : this._flags[flag];\n\t            }\n\t        } else {\n\t            description.flags = this._flags;\n\t        }\n\t    }\n\t\n\t    if (this._description) {\n\t        description.description = this._description;\n\t    }\n\t\n\t    if (this._notes.length) {\n\t        description.notes = this._notes;\n\t    }\n\t\n\t    if (this._tags.length) {\n\t        description.tags = this._tags;\n\t    }\n\t\n\t    if (this._meta.length) {\n\t        description.meta = this._meta;\n\t    }\n\t\n\t    if (this._examples.length) {\n\t        description.examples = this._examples;\n\t    }\n\t\n\t    if (this._unit) {\n\t        description.unit = this._unit;\n\t    }\n\t\n\t    var valids = this._valids.values();\n\t    if (valids.length) {\n\t        description.valids = valids;\n\t    }\n\t\n\t    var invalids = this._invalids.values();\n\t    if (invalids.length) {\n\t        description.invalids = invalids;\n\t    }\n\t\n\t    description.rules = [];\n\t\n\t    for (var i = 0; i < this._tests.length; ++i) {\n\t        var validator = this._tests[i];\n\t        var item = { name: validator.name };\n\t        if (validator.arg !== void 0) {\n\t            item.arg = validator.arg;\n\t        }\n\t        description.rules.push(item);\n\t    }\n\t\n\t    if (!description.rules.length) {\n\t        delete description.rules;\n\t    }\n\t\n\t    var label = Hoek.reach(this._settings, 'language.label');\n\t    if (label) {\n\t        description.label = label;\n\t    }\n\t\n\t    return description;\n\t};\n\t\n\tinternals.Any.prototype.label = function (name) {\n\t\n\t    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\t\n\t    var obj = this.clone();\n\t    var options = { language: { label: name } };\n\t\n\t    // If language.label is set, it should override this label\n\t    obj._settings = internals.concatSettings(options, obj._settings);\n\t    return obj;\n\t};\n\t\n\t// Set\n\t\n\tinternals.Set = function () {\n\t\n\t    this._set = [];\n\t};\n\t\n\tinternals.Set.prototype.add = function (value, refs) {\n\t\n\t    Hoek.assert(value === null || value === undefined || value instanceof Date || Buffer.isBuffer(value) || Ref.isRef(value) || typeof value !== 'function' && typeof value !== 'object', 'Value cannot be an object or function');\n\t\n\t    if (typeof value !== 'function' && this.has(value, null, null, false)) {\n\t\n\t        return;\n\t    }\n\t\n\t    Ref.push(refs, value);\n\t    this._set.push(value);\n\t};\n\t\n\tinternals.Set.prototype.merge = function (add, remove) {\n\t\n\t    for (var i = 0; i < add._set.length; ++i) {\n\t        this.add(add._set[i]);\n\t    }\n\t\n\t    for (var i = 0; i < remove._set.length; ++i) {\n\t        this.remove(remove._set[i]);\n\t    }\n\t};\n\t\n\tinternals.Set.prototype.remove = function (value) {\n\t\n\t    this._set = this._set.filter(function (item) {\n\t        return value !== item;\n\t    });\n\t};\n\t\n\tinternals.Set.prototype.has = function (value, state, options, insensitive) {\n\t\n\t    for (var i = 0; i < this._set.length; ++i) {\n\t        var items = this._set[i];\n\t\n\t        if (Ref.isRef(items)) {\n\t            items = items(state.reference || state.parent, options);\n\t        }\n\t\n\t        if (!Array.isArray(items)) {\n\t            items = [items];\n\t        }\n\t\n\t        for (var j = 0; j < items.length; ++j) {\n\t            var item = items[j];\n\t            if (typeof value !== typeof item) {\n\t                continue;\n\t            }\n\t\n\t            if (value === item || value instanceof Date && item instanceof Date && value.getTime() === item.getTime() || insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase() || Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary')) {\n\t\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    return false;\n\t};\n\t\n\tinternals.Set.prototype.values = function (options) {\n\t\n\t    if (options && options.stripUndefined) {\n\t        var values = [];\n\t\n\t        for (var i = 0; i < this._set.length; ++i) {\n\t            var item = this._set[i];\n\t            if (item !== undefined) {\n\t                values.push(item);\n\t            }\n\t        }\n\t\n\t        return values;\n\t    }\n\t\n\t    return this._set.slice();\n\t};\n\t\n\tinternals.concatSettings = function (target, source) {\n\t\n\t    // Used to avoid cloning context\n\t\n\t    if (!target && !source) {\n\t\n\t        return null;\n\t    }\n\t\n\t    var obj = {};\n\t\n\t    if (target) {\n\t        var tKeys = Object.keys(target);\n\t        for (var i = 0; i < tKeys.length; ++i) {\n\t            var key = tKeys[i];\n\t            obj[key] = target[key];\n\t        }\n\t    }\n\t\n\t    if (source) {\n\t        var sKeys = Object.keys(source);\n\t        for (var i = 0; i < sKeys.length; ++i) {\n\t            var key = sKeys[i];\n\t            if (key !== 'language' || !obj.hasOwnProperty(key)) {\n\t\n\t                obj[key] = source[key];\n\t            } else {\n\t                obj[key] = Hoek.applyToDefaults(obj[key], source[key]);\n\t            }\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 2).Buffer))\n\n/***/ },\n/* 2 */\n/*!***************************!*\\\n  !*** ./~/buffer/index.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\tvar base64 = __webpack_require__(/*! base64-js */ 3)\n\tvar ieee754 = __webpack_require__(/*! ieee754 */ 4)\n\tvar isArray = __webpack_require__(/*! is-array */ 5)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\tvar rootParent = {}\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n\t *     on objects.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\tfunction typedArraySupport () {\n\t  function Bar () {}\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.foo = function () { return 42 }\n\t    arr.constructor = Bar\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        arr.constructor === Bar && // constructor can be set\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\t/**\n\t * Class: Buffer\n\t * =============\n\t *\n\t * The Buffer constructor returns instances of `Uint8Array` that are augmented\n\t * with function properties for all the node `Buffer` API functions. We use\n\t * `Uint8Array` so that square bracket notation works as expected -- it returns\n\t * a single octet.\n\t *\n\t * By augmenting the instances, we can avoid modifying the `Uint8Array`\n\t * prototype.\n\t */\n\tfunction Buffer (arg) {\n\t  if (!(this instanceof Buffer)) {\n\t    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n\t    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n\t    return new Buffer(arg)\n\t  }\n\t\n\t  this.length = 0\n\t  this.parent = undefined\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    return fromNumber(this, arg)\n\t  }\n\t\n\t  // Slightly less common case.\n\t  if (typeof arg === 'string') {\n\t    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n\t  }\n\t\n\t  // Unusual.\n\t  return fromObject(this, arg)\n\t}\n\t\n\tfunction fromNumber (that, length) {\n\t  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < length; i++) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\t\n\t  // Assumption: byteLength() return value is always < kMaxLength.\n\t  var length = byteLength(string, encoding) | 0\n\t  that = allocate(that, length)\n\t\n\t  that.write(string, encoding)\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, object) {\n\t  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\t\n\t  if (isArray(object)) return fromArray(that, object)\n\t\n\t  if (object == null) {\n\t    throw new TypeError('must start with number, buffer, array or string')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined') {\n\t    if (object.buffer instanceof ArrayBuffer) {\n\t      return fromTypedArray(that, object)\n\t    }\n\t    if (object instanceof ArrayBuffer) {\n\t      return fromArrayBuffer(that, object)\n\t    }\n\t  }\n\t\n\t  if (object.length) return fromArrayLike(that, object)\n\t\n\t  return fromJsonObject(that, object)\n\t}\n\t\n\tfunction fromBuffer (that, buffer) {\n\t  var length = checked(buffer.length) | 0\n\t  that = allocate(that, length)\n\t  buffer.copy(that, 0, 0, length)\n\t  return that\n\t}\n\t\n\tfunction fromArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Duplicate of fromArray() to keep fromArray() monomorphic.\n\tfunction fromTypedArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  // Truncating the elements is probably not what people expect from typed\n\t  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n\t  // of the old Buffer constructor.\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    array.byteLength\n\t    that = Buffer._augment(new Uint8Array(array))\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromTypedArray(that, new Uint8Array(array))\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n\t// Returns a zero-length buffer for inputs that don't conform to the spec.\n\tfunction fromJsonObject (that, object) {\n\t  var array\n\t  var length = 0\n\t\n\t  if (object.type === 'Buffer' && isArray(object.data)) {\n\t    array = object.data\n\t    length = checked(array.length) | 0\n\t  }\n\t  that = allocate(that, length)\n\t\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t}\n\t\n\tfunction allocate (that, length) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = Buffer._augment(new Uint8Array(length))\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that.length = length\n\t    that._isBuffer = true\n\t  }\n\t\n\t  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n\t  if (fromPool) that.parent = rootParent\n\t\n\t  return that\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (subject, encoding) {\n\t  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\t\n\t  var buf = new Buffer(subject, encoding)\n\t  delete buf.parent\n\t  return buf\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  var i = 0\n\t  var len = Math.min(x, y)\n\t  while (i < len) {\n\t    if (a[i] !== b[i]) break\n\t\n\t    ++i\n\t  }\n\t\n\t  if (i !== len) {\n\t    x = a[i]\n\t    y = b[i]\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'raw':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\t\n\t  if (list.length === 0) {\n\t    return new Buffer(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; i++) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buf = new Buffer(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    item.copy(buf, pos)\n\t    pos += item.length\n\t  }\n\t  return buf\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (typeof string !== 'string') string = '' + string\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'binary':\n\t      // Deprecated\n\t      case 'raw':\n\t      case 'raws':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\t// pre-set for values that may exist in the future\n\tBuffer.prototype.length = undefined\n\tBuffer.prototype.parent = undefined\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  start = start | 0\n\t  end = end === undefined || end === Infinity ? this.length : end | 0\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t  if (start < 0) start = 0\n\t  if (end > this.length) end = this.length\n\t  if (end <= start) return ''\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'binary':\n\t        return binarySlice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return 0\n\t  return Buffer.compare(this, b)\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n\t  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n\t  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n\t  byteOffset >>= 0\n\t\n\t  if (this.length === 0) return -1\n\t  if (byteOffset >= this.length) return -1\n\t\n\t  // Negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\t\n\t  if (typeof val === 'string') {\n\t    if (val.length === 0) return -1 // special case: looking for empty string always fails\n\t    return String.prototype.indexOf.call(this, val, byteOffset)\n\t  }\n\t  if (Buffer.isBuffer(val)) {\n\t    return arrayIndexOf(this, val, byteOffset)\n\t  }\n\t  if (typeof val === 'number') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n\t      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n\t    }\n\t    return arrayIndexOf(this, [ val ], byteOffset)\n\t  }\n\t\n\t  function arrayIndexOf (arr, val, byteOffset) {\n\t    var foundIndex = -1\n\t    for (var i = 0; byteOffset + i < arr.length; i++) {\n\t      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n\t      } else {\n\t        foundIndex = -1\n\t      }\n\t    }\n\t    return -1\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\t// `get` is deprecated\n\tBuffer.prototype.get = function get (offset) {\n\t  console.log('.get() is deprecated. Access using array indexes instead.')\n\t  return this.readUInt8(offset)\n\t}\n\t\n\t// `set` is deprecated\n\tBuffer.prototype.set = function set (v, offset) {\n\t  console.log('.set() is deprecated. Access using array indexes instead.')\n\t  return this.writeUInt8(v, offset)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; i++) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) throw new Error('Invalid hex string')\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction binaryWrite (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    var swap = encoding\n\t    encoding = offset\n\t    offset = length | 0\n\t    length = swap\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'binary':\n\t        return binaryWrite(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction binarySlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; i++) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = Buffer._augment(this.subarray(start, end))\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; i++) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  if (newBuf.length) newBuf.parent = this.parent || this\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t  if (offset < 0) throw new RangeError('index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; i--) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; i++) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    target._set(this.subarray(start, start + len), targetStart)\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// fill(value, start=0, end=buffer.length)\n\tBuffer.prototype.fill = function fill (value, start, end) {\n\t  if (!value) value = 0\n\t  if (!start) start = 0\n\t  if (!end) end = this.length\n\t\n\t  if (end < start) throw new RangeError('end < start')\n\t\n\t  // Fill 0 bytes; we're done\n\t  if (end === start) return\n\t  if (this.length === 0) return\n\t\n\t  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n\t  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\t\n\t  var i\n\t  if (typeof value === 'number') {\n\t    for (i = start; i < end; i++) {\n\t      this[i] = value\n\t    }\n\t  } else {\n\t    var bytes = utf8ToBytes(value.toString())\n\t    var len = bytes.length\n\t    for (i = start; i < end; i++) {\n\t      this[i] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n\t * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n\t */\n\tBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n\t  if (typeof Uint8Array !== 'undefined') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t      return (new Buffer(this)).buffer\n\t    } else {\n\t      var buf = new Uint8Array(this.length)\n\t      for (var i = 0, len = buf.length; i < len; i += 1) {\n\t        buf[i] = this[i]\n\t      }\n\t      return buf.buffer\n\t    }\n\t  } else {\n\t    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n\t  }\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar BP = Buffer.prototype\n\t\n\t/**\n\t * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n\t */\n\tBuffer._augment = function _augment (arr) {\n\t  arr.constructor = Buffer\n\t  arr._isBuffer = true\n\t\n\t  // save reference to original Uint8Array set method before overwriting\n\t  arr._set = arr.set\n\t\n\t  // deprecated\n\t  arr.get = BP.get\n\t  arr.set = BP.set\n\t\n\t  arr.write = BP.write\n\t  arr.toString = BP.toString\n\t  arr.toLocaleString = BP.toString\n\t  arr.toJSON = BP.toJSON\n\t  arr.equals = BP.equals\n\t  arr.compare = BP.compare\n\t  arr.indexOf = BP.indexOf\n\t  arr.copy = BP.copy\n\t  arr.slice = BP.slice\n\t  arr.readUIntLE = BP.readUIntLE\n\t  arr.readUIntBE = BP.readUIntBE\n\t  arr.readUInt8 = BP.readUInt8\n\t  arr.readUInt16LE = BP.readUInt16LE\n\t  arr.readUInt16BE = BP.readUInt16BE\n\t  arr.readUInt32LE = BP.readUInt32LE\n\t  arr.readUInt32BE = BP.readUInt32BE\n\t  arr.readIntLE = BP.readIntLE\n\t  arr.readIntBE = BP.readIntBE\n\t  arr.readInt8 = BP.readInt8\n\t  arr.readInt16LE = BP.readInt16LE\n\t  arr.readInt16BE = BP.readInt16BE\n\t  arr.readInt32LE = BP.readInt32LE\n\t  arr.readInt32BE = BP.readInt32BE\n\t  arr.readFloatLE = BP.readFloatLE\n\t  arr.readFloatBE = BP.readFloatBE\n\t  arr.readDoubleLE = BP.readDoubleLE\n\t  arr.readDoubleBE = BP.readDoubleBE\n\t  arr.writeUInt8 = BP.writeUInt8\n\t  arr.writeUIntLE = BP.writeUIntLE\n\t  arr.writeUIntBE = BP.writeUIntBE\n\t  arr.writeUInt16LE = BP.writeUInt16LE\n\t  arr.writeUInt16BE = BP.writeUInt16BE\n\t  arr.writeUInt32LE = BP.writeUInt32LE\n\t  arr.writeUInt32BE = BP.writeUInt32BE\n\t  arr.writeIntLE = BP.writeIntLE\n\t  arr.writeIntBE = BP.writeIntBE\n\t  arr.writeInt8 = BP.writeInt8\n\t  arr.writeInt16LE = BP.writeInt16LE\n\t  arr.writeInt16BE = BP.writeInt16BE\n\t  arr.writeInt32LE = BP.writeInt32LE\n\t  arr.writeInt32BE = BP.writeInt32BE\n\t  arr.writeFloatLE = BP.writeFloatLE\n\t  arr.writeFloatBE = BP.writeFloatBE\n\t  arr.writeDoubleLE = BP.writeDoubleLE\n\t  arr.writeDoubleBE = BP.writeDoubleBE\n\t  arr.fill = BP.fill\n\t  arr.inspect = BP.inspect\n\t  arr.toArrayBuffer = BP.toArrayBuffer\n\t\n\t  return arr\n\t}\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; i++) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; i++) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 2).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 3 */\n/*!*****************************************!*\\\n  !*** ./~/buffer/~/base64-js/lib/b64.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\t;(function (exports) {\n\t\t'use strict';\n\t\n\t  var Arr = (typeof Uint8Array !== 'undefined')\n\t    ? Uint8Array\n\t    : Array\n\t\n\t\tvar PLUS   = '+'.charCodeAt(0)\n\t\tvar SLASH  = '/'.charCodeAt(0)\n\t\tvar NUMBER = '0'.charCodeAt(0)\n\t\tvar LOWER  = 'a'.charCodeAt(0)\n\t\tvar UPPER  = 'A'.charCodeAt(0)\n\t\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\t\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\t\n\t\tfunction decode (elt) {\n\t\t\tvar code = elt.charCodeAt(0)\n\t\t\tif (code === PLUS ||\n\t\t\t    code === PLUS_URL_SAFE)\n\t\t\t\treturn 62 // '+'\n\t\t\tif (code === SLASH ||\n\t\t\t    code === SLASH_URL_SAFE)\n\t\t\t\treturn 63 // '/'\n\t\t\tif (code < NUMBER)\n\t\t\t\treturn -1 //no match\n\t\t\tif (code < NUMBER + 10)\n\t\t\t\treturn code - NUMBER + 26 + 26\n\t\t\tif (code < UPPER + 26)\n\t\t\t\treturn code - UPPER\n\t\t\tif (code < LOWER + 26)\n\t\t\t\treturn code - LOWER + 26\n\t\t}\n\t\n\t\tfunction b64ToByteArray (b64) {\n\t\t\tvar i, j, l, tmp, placeHolders, arr\n\t\n\t\t\tif (b64.length % 4 > 0) {\n\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t\t}\n\t\n\t\t\t// the number of equal signs (place holders)\n\t\t\t// if there are two placeholders, than the two characters before it\n\t\t\t// represent one byte\n\t\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t\t// this is just a cheap hack to not do indexOf twice\n\t\t\tvar len = b64.length\n\t\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\t\n\t\t\t// base64 is 4/3 + up to two characters of the original data\n\t\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\t\n\t\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\t\n\t\t\tvar L = 0\n\t\n\t\t\tfunction push (v) {\n\t\t\t\tarr[L++] = v\n\t\t\t}\n\t\n\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\tif (placeHolders === 2) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t} else if (placeHolders === 1) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\treturn arr\n\t\t}\n\t\n\t\tfunction uint8ToBase64 (uint8) {\n\t\t\tvar i,\n\t\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\t\toutput = \"\",\n\t\t\t\ttemp, length\n\t\n\t\t\tfunction encode (num) {\n\t\t\t\treturn lookup.charAt(num)\n\t\t\t}\n\t\n\t\t\tfunction tripletToBase64 (num) {\n\t\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t\t}\n\t\n\t\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\t\toutput += tripletToBase64(temp)\n\t\t\t}\n\t\n\t\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\t\tswitch (extraBytes) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\t\toutput += '=='\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\t\toutput += '='\n\t\t\t\t\tbreak\n\t\t\t}\n\t\n\t\t\treturn output\n\t\t}\n\t\n\t\texports.toByteArray = b64ToByteArray\n\t\texports.fromByteArray = uint8ToBase64\n\t}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 4 */\n/*!*************************************!*\\\n  !*** ./~/buffer/~/ieee754/index.js ***!\n  \\*************************************/\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 5 */\n/*!**************************************!*\\\n  !*** ./~/buffer/~/is-array/index.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * isArray\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * toString\n\t */\n\t\n\tvar str = Object.prototype.toString;\n\t\n\t/**\n\t * Whether or not the given `val`\n\t * is an array.\n\t *\n\t * example:\n\t *\n\t *        isArray([]);\n\t *        // > true\n\t *        isArray(arguments);\n\t *        // > false\n\t *        isArray('');\n\t *        // > false\n\t *\n\t * @param {mixed} val\n\t * @return {bool}\n\t */\n\t\n\tmodule.exports = isArray || function (val) {\n\t  return !! val && '[object Array]' == str.call(val);\n\t};\n\n\n/***/ },\n/* 6 */\n/*!*****************************!*\\\n  !*** ./~/hoek/lib/index.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\t// Load modules\n\t\n\tvar Crypto = __webpack_require__(/*! crypto */ 7);\n\tvar Path = __webpack_require__(/*! path */ 8);\n\tvar Util = __webpack_require__(/*! util */ 9);\n\tvar Escape = __webpack_require__(/*! ./escape */ 11);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\t// Clone object or array\n\t\n\texports.clone = function (obj, seen) {\n\t\n\t    if (typeof obj !== 'object' || obj === null) {\n\t\n\t        return obj;\n\t    }\n\t\n\t    seen = seen || { orig: [], copy: [] };\n\t\n\t    var lookup = seen.orig.indexOf(obj);\n\t    if (lookup !== -1) {\n\t        return seen.copy[lookup];\n\t    }\n\t\n\t    var newObj = undefined;\n\t    var cloneDeep = false;\n\t\n\t    if (!Array.isArray(obj)) {\n\t        if (Buffer.isBuffer(obj)) {\n\t            newObj = new Buffer(obj);\n\t        } else if (obj instanceof Date) {\n\t            newObj = new Date(obj.getTime());\n\t        } else if (obj instanceof RegExp) {\n\t            newObj = new RegExp(obj);\n\t        } else {\n\t            var proto = Object.getPrototypeOf(obj);\n\t            if (proto && proto.isImmutable) {\n\t\n\t                newObj = obj;\n\t            } else {\n\t                newObj = Object.create(proto);\n\t                cloneDeep = true;\n\t            }\n\t        }\n\t    } else {\n\t        newObj = [];\n\t        cloneDeep = true;\n\t    }\n\t\n\t    seen.orig.push(obj);\n\t    seen.copy.push(newObj);\n\t\n\t    if (cloneDeep) {\n\t        var keys = Object.getOwnPropertyNames(obj);\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\t            if (descriptor && (descriptor.get || descriptor.set)) {\n\t\n\t                Object.defineProperty(newObj, key, descriptor);\n\t            } else {\n\t                newObj[key] = exports.clone(obj[key], seen);\n\t            }\n\t        }\n\t    }\n\t\n\t    return newObj;\n\t};\n\t\n\t// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\t\n\t/*eslint-disable */\n\texports.merge = function (target, source, isNullOverride, /* = true */isMergeArrays /* = true */) {\n\t    /*eslint-enable */\n\t\n\t    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n\t    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\t\n\t    if (!source) {\n\t        return target;\n\t    }\n\t\n\t    if (Array.isArray(source)) {\n\t        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n\t        if (isMergeArrays === false) {\n\t            // isMergeArrays defaults to true\n\t            target.length = 0; // Must not change target assignment\n\t        }\n\t\n\t        for (var i = 0; i < source.length; ++i) {\n\t            target.push(exports.clone(source[i]));\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    var keys = Object.keys(source);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var value = source[key];\n\t        if (value && typeof value === 'object') {\n\t\n\t            if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) ^ Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {\n\t\n\t                target[key] = exports.clone(value);\n\t            } else {\n\t                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n\t            }\n\t        } else {\n\t            if (value !== null && value !== undefined) {\n\t                // Explicit to preserve empty strings\n\t\n\t                target[key] = value;\n\t            } else if (isNullOverride !== false) {\n\t                // Defaults to true\n\t                target[key] = value;\n\t            }\n\t        }\n\t    }\n\t\n\t    return target;\n\t};\n\t\n\t// Apply options to a copy of the defaults\n\t\n\texports.applyToDefaults = function (defaults, options, isNullOverride) {\n\t\n\t    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n\t    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\t\n\t    if (!options) {\n\t        // If no options, return null\n\t        return null;\n\t    }\n\t\n\t    var copy = exports.clone(defaults);\n\t\n\t    if (options === true) {\n\t        // If options is set to true, use defaults\n\t        return copy;\n\t    }\n\t\n\t    return exports.merge(copy, options, isNullOverride === true, false);\n\t};\n\t\n\t// Clone an object except for the listed keys which are shallow copied\n\t\n\texports.cloneWithShallow = function (source, keys) {\n\t\n\t    if (!source || typeof source !== 'object') {\n\t\n\t        return source;\n\t    }\n\t\n\t    var storage = internals.store(source, keys); // Move shallow copy items to storage\n\t    var copy = exports.clone(source); // Deep copy the rest\n\t    internals.restore(copy, source, storage); // Shallow copy the stored items and restore\n\t    return copy;\n\t};\n\t\n\tinternals.store = function (source, keys) {\n\t\n\t    var storage = {};\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var value = exports.reach(source, key);\n\t        if (value !== undefined) {\n\t            storage[key] = value;\n\t            internals.reachSet(source, key, undefined);\n\t        }\n\t    }\n\t\n\t    return storage;\n\t};\n\t\n\tinternals.restore = function (copy, source, storage) {\n\t\n\t    var keys = Object.keys(storage);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        internals.reachSet(copy, key, storage[key]);\n\t        internals.reachSet(source, key, storage[key]);\n\t    }\n\t};\n\t\n\tinternals.reachSet = function (obj, key, value) {\n\t\n\t    var path = key.split('.');\n\t    var ref = obj;\n\t    for (var i = 0; i < path.length; ++i) {\n\t        var segment = path[i];\n\t        if (i + 1 === path.length) {\n\t            ref[segment] = value;\n\t        }\n\t\n\t        ref = ref[segment];\n\t    }\n\t};\n\t\n\t// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\t\n\texports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\t\n\t    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n\t    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\t    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\t\n\t    if (!options) {\n\t        // If no options, return null\n\t        return null;\n\t    }\n\t\n\t    var copy = exports.cloneWithShallow(defaults, keys);\n\t\n\t    if (options === true) {\n\t        // If options is set to true, use defaults\n\t        return copy;\n\t    }\n\t\n\t    var storage = internals.store(options, keys); // Move shallow copy items to storage\n\t    exports.merge(copy, options, false, false); // Deep copy the rest\n\t    internals.restore(copy, options, storage); // Shallow copy the stored items and restore\n\t    return copy;\n\t};\n\t\n\t// Deep object or array comparison\n\t\n\texports.deepEqual = function (obj, ref, options, seen) {\n\t\n\t    options = options || { prototype: true };\n\t\n\t    var type = typeof obj;\n\t\n\t    if (type !== typeof ref) {\n\t        return false;\n\t    }\n\t\n\t    if (type !== 'object' || obj === null || ref === null) {\n\t\n\t        if (obj === ref) {\n\t            // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n\t            return obj !== 0 || 1 / obj === 1 / ref; // -0 / +0\n\t        }\n\t\n\t        return obj !== obj && ref !== ref; // NaN\n\t    }\n\t\n\t    seen = seen || [];\n\t    if (seen.indexOf(obj) !== -1) {\n\t        return true; // If previous comparison failed, it would have stopped execution\n\t    }\n\t\n\t    seen.push(obj);\n\t\n\t    if (Array.isArray(obj)) {\n\t        if (!Array.isArray(ref)) {\n\t            return false;\n\t        }\n\t\n\t        if (!options.part && obj.length !== ref.length) {\n\t            return false;\n\t        }\n\t\n\t        for (var i = 0; i < obj.length; ++i) {\n\t            if (options.part) {\n\t                var found = false;\n\t                for (var j = 0; j < ref.length; ++j) {\n\t                    if (exports.deepEqual(obj[i], ref[j], options)) {\n\t                        found = true;\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                return found;\n\t            }\n\t\n\t            if (!exports.deepEqual(obj[i], ref[i], options)) {\n\t                return false;\n\t            }\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    if (Buffer.isBuffer(obj)) {\n\t        if (!Buffer.isBuffer(ref)) {\n\t            return false;\n\t        }\n\t\n\t        if (obj.length !== ref.length) {\n\t            return false;\n\t        }\n\t\n\t        for (var i = 0; i < obj.length; ++i) {\n\t            if (obj[i] !== ref[i]) {\n\t                return false;\n\t            }\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    if (obj instanceof Date) {\n\t        return ref instanceof Date && obj.getTime() === ref.getTime();\n\t    }\n\t\n\t    if (obj instanceof RegExp) {\n\t        return ref instanceof RegExp && obj.toString() === ref.toString();\n\t    }\n\t\n\t    if (options.prototype) {\n\t        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    var keys = Object.getOwnPropertyNames(obj);\n\t\n\t    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n\t        return false;\n\t    }\n\t\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\t        if (descriptor.get) {\n\t            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n\t                return false;\n\t            }\n\t        } else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    return true;\n\t};\n\t\n\t// Remove duplicate items from array\n\t\n\texports.unique = function (array, key) {\n\t\n\t    var index = {};\n\t    var result = [];\n\t\n\t    for (var i = 0; i < array.length; ++i) {\n\t        var id = key ? array[i][key] : array[i];\n\t        if (index[id] !== true) {\n\t\n\t            result.push(array[i]);\n\t            index[id] = true;\n\t        }\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\t// Convert array into object\n\t\n\texports.mapToObject = function (array, key) {\n\t\n\t    if (!array) {\n\t        return null;\n\t    }\n\t\n\t    var obj = {};\n\t    for (var i = 0; i < array.length; ++i) {\n\t        if (key) {\n\t            if (array[i][key]) {\n\t                obj[array[i][key]] = true;\n\t            }\n\t        } else {\n\t            obj[array[i]] = true;\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\t// Find the common unique items in two arrays\n\t\n\texports.intersect = function (array1, array2, justFirst) {\n\t\n\t    if (!array1 || !array2) {\n\t        return [];\n\t    }\n\t\n\t    var common = [];\n\t    var hash = Array.isArray(array1) ? exports.mapToObject(array1) : array1;\n\t    var found = {};\n\t    for (var i = 0; i < array2.length; ++i) {\n\t        if (hash[array2[i]] && !found[array2[i]]) {\n\t            if (justFirst) {\n\t                return array2[i];\n\t            }\n\t\n\t            common.push(array2[i]);\n\t            found[array2[i]] = true;\n\t        }\n\t    }\n\t\n\t    return justFirst ? null : common;\n\t};\n\t\n\t// Test if the reference contains the values\n\t\n\texports.contain = function (ref, values, options) {\n\t\n\t    /*\n\t        string -> string(s)\n\t        array -> item(s)\n\t        object -> key(s)\n\t        object -> object (key:value)\n\t    */\n\t\n\t    var valuePairs = null;\n\t    if (typeof ref === 'object' && typeof values === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {\n\t\n\t        valuePairs = values;\n\t        values = Object.keys(values);\n\t    } else {\n\t        values = [].concat(values);\n\t    }\n\t\n\t    options = options || {}; // deep, once, only, part\n\t\n\t    exports.assert(arguments.length >= 2, 'Insufficient arguments');\n\t    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n\t    exports.assert(values.length, 'Values array cannot be empty');\n\t\n\t    var compare = undefined;\n\t    var compareFlags = undefined;\n\t    if (options.deep) {\n\t        compare = exports.deepEqual;\n\t\n\t        var hasOnly = options.hasOwnProperty('only');\n\t        var hasPart = options.hasOwnProperty('part');\n\t\n\t        compareFlags = {\n\t            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n\t            part: hasOnly ? !options.only : hasPart ? options.part : true\n\t        };\n\t    } else {\n\t        compare = function (a, b) {\n\t            return a === b;\n\t        };\n\t    }\n\t\n\t    var misses = false;\n\t    var matches = new Array(values.length);\n\t    for (var i = 0; i < matches.length; ++i) {\n\t        matches[i] = 0;\n\t    }\n\t\n\t    if (typeof ref === 'string') {\n\t        var pattern = '(';\n\t        for (var i = 0; i < values.length; ++i) {\n\t            var value = values[i];\n\t            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n\t            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n\t        }\n\t\n\t        var regex = new RegExp(pattern + ')', 'g');\n\t        var leftovers = ref.replace(regex, function ($0, $1) {\n\t\n\t            var index = values.indexOf($1);\n\t            ++matches[index];\n\t            return ''; // Remove from string\n\t        });\n\t\n\t        misses = !!leftovers;\n\t    } else if (Array.isArray(ref)) {\n\t        for (var i = 0; i < ref.length; ++i) {\n\t            var matched = false;\n\t            for (var j = 0; j < values.length && matched === false; ++j) {\n\t                matched = compare(values[j], ref[i], compareFlags) && j;\n\t            }\n\t\n\t            if (matched !== false) {\n\t                ++matches[matched];\n\t            } else {\n\t                misses = true;\n\t            }\n\t        }\n\t    } else {\n\t        var keys = Object.keys(ref);\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            var pos = values.indexOf(key);\n\t            if (pos !== -1) {\n\t                if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {\n\t\n\t                    return false;\n\t                }\n\t\n\t                ++matches[pos];\n\t            } else {\n\t                misses = true;\n\t            }\n\t        }\n\t    }\n\t\n\t    var result = false;\n\t    for (var i = 0; i < matches.length; ++i) {\n\t        result = result || !!matches[i];\n\t        if (options.once && matches[i] > 1 || !options.part && !matches[i]) {\n\t\n\t            return false;\n\t        }\n\t    }\n\t\n\t    if (options.only && misses) {\n\t\n\t        return false;\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\t// Flatten array\n\t\n\texports.flatten = function (array, target) {\n\t\n\t    var result = target || [];\n\t\n\t    for (var i = 0; i < array.length; ++i) {\n\t        if (Array.isArray(array[i])) {\n\t            exports.flatten(array[i], result);\n\t        } else {\n\t            result.push(array[i]);\n\t        }\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\t// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\t\n\texports.reach = function (obj, chain, options) {\n\t\n\t    if (chain === false || chain === null || typeof chain === 'undefined') {\n\t\n\t        return obj;\n\t    }\n\t\n\t    options = options || {};\n\t    if (typeof options === 'string') {\n\t        options = { separator: options };\n\t    }\n\t\n\t    var path = chain.split(options.separator || '.');\n\t    var ref = obj;\n\t    for (var i = 0; i < path.length; ++i) {\n\t        var key = path[i];\n\t        if (key[0] === '-' && Array.isArray(ref)) {\n\t            key = key.slice(1, key.length);\n\t            key = ref.length - key;\n\t        }\n\t\n\t        if (!ref || !((typeof ref === 'object' || typeof ref === 'function') && key in ref) || typeof ref !== 'object' && options.functions === false) {\n\t            // Only object and function can have properties\n\t\n\t            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n\t            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n\t            ref = options['default'];\n\t            break;\n\t        }\n\t\n\t        ref = ref[key];\n\t    }\n\t\n\t    return ref;\n\t};\n\t\n\texports.reachTemplate = function (obj, template, options) {\n\t\n\t    return template.replace(/{([^}]+)}/g, function ($0, chain) {\n\t\n\t        var value = exports.reach(obj, chain, options);\n\t        return value === undefined || value === null ? '' : value;\n\t    });\n\t};\n\t\n\texports.formatStack = function (stack) {\n\t\n\t    var trace = [];\n\t    for (var i = 0; i < stack.length; ++i) {\n\t        var item = stack[i];\n\t        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n\t    }\n\t\n\t    return trace;\n\t};\n\t\n\texports.formatTrace = function (trace) {\n\t\n\t    var display = [];\n\t\n\t    for (var i = 0; i < trace.length; ++i) {\n\t        var row = trace[i];\n\t        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n\t    }\n\t\n\t    return display;\n\t};\n\t\n\texports.callStack = function (slice) {\n\t\n\t    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\n\t    var v8 = Error.prepareStackTrace;\n\t    Error.prepareStackTrace = function (err, stack) {\n\t\n\t        return stack;\n\t    };\n\t\n\t    var capture = {};\n\t    Error.captureStackTrace(capture, this); // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result\n\t    var stack = capture.stack;\n\t\n\t    Error.prepareStackTrace = v8;\n\t\n\t    var trace = exports.formatStack(stack);\n\t\n\t    return trace.slice(1 + slice);\n\t};\n\t\n\texports.displayStack = function (slice) {\n\t\n\t    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n\t\n\t    return exports.formatTrace(trace);\n\t};\n\t\n\texports.abortThrow = false;\n\t\n\texports.abort = function (message, hideStack) {\n\t\n\t    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n\t        throw new Error(message || 'Unknown error');\n\t    }\n\t\n\t    var stack = '';\n\t    if (!hideStack) {\n\t        stack = exports.displayStack(1).join('\\n\\t');\n\t    }\n\t    console.log('ABORT: ' + message + '\\n\\t' + stack);\n\t    process.exit(1);\n\t};\n\t\n\texports.assert = function (condition /*, msg1, msg2, msg3 */) {\n\t\n\t    if (condition) {\n\t        return;\n\t    }\n\t\n\t    if (arguments.length === 2 && arguments[1] instanceof Error) {\n\t        throw arguments[1];\n\t    }\n\t\n\t    var msgs = [];\n\t    for (var i = 1; i < arguments.length; ++i) {\n\t        if (arguments[i] !== '') {\n\t            msgs.push(arguments[i]); // Avoids Array.slice arguments leak, allowing for V8 optimizations\n\t        }\n\t    }\n\t\n\t    msgs = msgs.map(function (msg) {\n\t\n\t        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);\n\t    });\n\t\n\t    throw new Error(msgs.join(' ') || 'Unknown error');\n\t};\n\t\n\texports.Timer = function () {\n\t\n\t    this.ts = 0;\n\t    this.reset();\n\t};\n\t\n\texports.Timer.prototype.reset = function () {\n\t\n\t    this.ts = Date.now();\n\t};\n\t\n\texports.Timer.prototype.elapsed = function () {\n\t\n\t    return Date.now() - this.ts;\n\t};\n\t\n\texports.Bench = function () {\n\t\n\t    this.ts = 0;\n\t    this.reset();\n\t};\n\t\n\texports.Bench.prototype.reset = function () {\n\t\n\t    this.ts = exports.Bench.now();\n\t};\n\t\n\texports.Bench.prototype.elapsed = function () {\n\t\n\t    return exports.Bench.now() - this.ts;\n\t};\n\t\n\texports.Bench.now = function () {\n\t\n\t    var ts = process.hrtime();\n\t    return ts[0] * 1e3 + ts[1] / 1e6;\n\t};\n\t\n\t// Escape string for Regex construction\n\t\n\texports.escapeRegex = function (string) {\n\t\n\t    // Escape ^$.*+-?=!:|\\/()[]{},\n\t    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n\t};\n\t\n\t// Base64url (RFC 4648) encode\n\t\n\texports.base64urlEncode = function (value, encoding) {\n\t\n\t    var buf = Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary');\n\t    return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n\t};\n\t\n\t// Base64url (RFC 4648) decode\n\t\n\texports.base64urlDecode = function (value, encoding) {\n\t\n\t    if (value && !/^[\\w\\-]*$/.test(value)) {\n\t\n\t        return new Error('Invalid character');\n\t    }\n\t\n\t    try {\n\t        var buf = new Buffer(value, 'base64');\n\t        return encoding === 'buffer' ? buf : buf.toString(encoding || 'binary');\n\t    } catch (err) {\n\t        return err;\n\t    }\n\t};\n\t\n\t// Escape attribute value for use in HTTP header\n\t\n\texports.escapeHeaderAttribute = function (attribute) {\n\t\n\t    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\t\n\t    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\t\n\t    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"'); // Escape quotes and slash\n\t};\n\t\n\texports.escapeHtml = function (string) {\n\t\n\t    return Escape.escapeHtml(string);\n\t};\n\t\n\texports.escapeJavaScript = function (string) {\n\t\n\t    return Escape.escapeJavaScript(string);\n\t};\n\t\n\texports.nextTick = function (callback) {\n\t\n\t    return function () {\n\t\n\t        var args = arguments;\n\t        process.nextTick(function () {\n\t\n\t            callback.apply(null, args);\n\t        });\n\t    };\n\t};\n\t\n\texports.once = function (method) {\n\t\n\t    if (method._hoekOnce) {\n\t        return method;\n\t    }\n\t\n\t    var once = false;\n\t    var wrapped = function wrapped() {\n\t\n\t        if (!once) {\n\t            once = true;\n\t            method.apply(null, arguments);\n\t        }\n\t    };\n\t\n\t    wrapped._hoekOnce = true;\n\t\n\t    return wrapped;\n\t};\n\t\n\texports.isAbsolutePath = function (path, platform) {\n\t\n\t    if (!path) {\n\t        return false;\n\t    }\n\t\n\t    if (Path.isAbsolute) {\n\t        // node >= 0.11\n\t        return Path.isAbsolute(path);\n\t    }\n\t\n\t    platform = platform || process.platform;\n\t\n\t    // Unix\n\t\n\t    if (platform !== 'win32') {\n\t        return path[0] === '/';\n\t    }\n\t\n\t    // Windows\n\t\n\t    return !!/^(?:[a-zA-Z]:[\\\\\\/])|(?:[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/])/.test(path); // C:\\ or \\\\something\\something\n\t};\n\t\n\texports.isInteger = function (value) {\n\t\n\t    return typeof value === 'number' && parseFloat(value) === parseInt(value, 10) && !isNaN(value);\n\t};\n\t\n\texports.ignore = function () {};\n\t\n\texports.inherits = Util.inherits;\n\t\n\texports.format = Util.format;\n\t\n\texports.transform = function (source, transform, options) {\n\t\n\t    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n\t\n\t    if (Array.isArray(source)) {\n\t        var results = [];\n\t        for (var i = 0; i < source.length; ++i) {\n\t            results.push(exports.transform(source[i], transform, options));\n\t        }\n\t        return results;\n\t    }\n\t\n\t    var result = {};\n\t    var keys = Object.keys(transform);\n\t\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var path = key.split('.');\n\t        var sourcePath = transform[key];\n\t\n\t        exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n\t\n\t        var segment = undefined;\n\t        var res = result;\n\t\n\t        while (path.length > 1) {\n\t            segment = path.shift();\n\t            if (!res[segment]) {\n\t                res[segment] = {};\n\t            }\n\t            res = res[segment];\n\t        }\n\t        segment = path.shift();\n\t        res[segment] = exports.reach(source, sourcePath, options);\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\texports.uniqueFilename = function (path, extension) {\n\t\n\t    if (extension) {\n\t        extension = extension[0] !== '.' ? '.' + extension : extension;\n\t    } else {\n\t        extension = '';\n\t    }\n\t\n\t    path = Path.resolve(path);\n\t    var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n\t    return Path.join(path, name);\n\t};\n\t\n\texports.stringify = function () {\n\t\n\t    try {\n\t        return JSON.stringify.apply(null, arguments);\n\t    } catch (err) {\n\t        return '[Cannot display object: ' + err.message + ']';\n\t    }\n\t};\n\t\n\texports.shallow = function (source) {\n\t\n\t    var target = {};\n\t    var keys = Object.keys(source);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        target[key] = source[key];\n\t    }\n\t\n\t    return target;\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 2).Buffer))\n\n/***/ },\n/* 7 */\n/*!*****************************!*\\\n  !*** ./lib/browser-stub.js ***!\n  \\*****************************/\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = {};\n\n/***/ },\n/* 8 */\n/*!****************************************************************!*\\\n  !*** (webpack)/~/node-libs-browser/~/path-browserify/index.js ***!\n  \\****************************************************************/\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\t'use strict';\n\t\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function splitPath(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function () {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = i >= 0 ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function (path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function (p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function (path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function () {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function (p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function (from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function (path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\texports.basename = function (path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\texports.extname = function (path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter(xs, f) {\n\t  if (xs.filter) return xs.filter(f);\n\t  var res = [];\n\t  for (var i = 0; i < xs.length; i++) {\n\t    if (f(xs[i], i, xs)) res.push(xs[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n\t  return str.substr(start, len);\n\t} : function (str, start, len) {\n\t  if (start < 0) start = str.length + start;\n\t  return str.substr(start, len);\n\t};\n\n/***/ },\n/* 9 */\n/*!*****************************!*\\\n  !*** ./lib/browser-util.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t\tinherits: __webpack_require__(/*! inherits */ 10)\n\t};\n\n/***/ },\n/* 10 */\n/*!****************************************!*\\\n  !*** ./~/inherits/inherits_browser.js ***!\n  \\****************************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function TempCtor() {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  };\n\t}\n\n/***/ },\n/* 11 */\n/*!******************************!*\\\n  !*** ./~/hoek/lib/escape.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\texports.escapeJavaScript = function (input) {\n\t\n\t    if (!input) {\n\t        return '';\n\t    }\n\t\n\t    var escaped = '';\n\t\n\t    for (var i = 0; i < input.length; ++i) {\n\t\n\t        var charCode = input.charCodeAt(i);\n\t\n\t        if (internals.isSafe(charCode)) {\n\t            escaped += input[i];\n\t        } else {\n\t            escaped += internals.escapeJavaScriptChar(charCode);\n\t        }\n\t    }\n\t\n\t    return escaped;\n\t};\n\t\n\texports.escapeHtml = function (input) {\n\t\n\t    if (!input) {\n\t        return '';\n\t    }\n\t\n\t    var escaped = '';\n\t\n\t    for (var i = 0; i < input.length; ++i) {\n\t\n\t        var charCode = input.charCodeAt(i);\n\t\n\t        if (internals.isSafe(charCode)) {\n\t            escaped += input[i];\n\t        } else {\n\t            escaped += internals.escapeHtmlChar(charCode);\n\t        }\n\t    }\n\t\n\t    return escaped;\n\t};\n\t\n\tinternals.escapeJavaScriptChar = function (charCode) {\n\t\n\t    if (charCode >= 256) {\n\t        return '\\\\u' + internals.padLeft('' + charCode, 4);\n\t    }\n\t\n\t    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');\n\t    return '\\\\x' + internals.padLeft(hexValue, 2);\n\t};\n\t\n\tinternals.escapeHtmlChar = function (charCode) {\n\t\n\t    var namedEscape = internals.namedHtml[charCode];\n\t    if (typeof namedEscape !== 'undefined') {\n\t        return namedEscape;\n\t    }\n\t\n\t    if (charCode >= 256) {\n\t        return '&#' + charCode + ';';\n\t    }\n\t\n\t    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');\n\t    return '&#x' + internals.padLeft(hexValue, 2) + ';';\n\t};\n\t\n\tinternals.padLeft = function (str, len) {\n\t\n\t    while (str.length < len) {\n\t        str = '0' + str;\n\t    }\n\t\n\t    return str;\n\t};\n\t\n\tinternals.isSafe = function (charCode) {\n\t\n\t    return typeof internals.safeCharCodes[charCode] !== 'undefined';\n\t};\n\t\n\tinternals.namedHtml = {\n\t    '38': '&amp;',\n\t    '60': '&lt;',\n\t    '62': '&gt;',\n\t    '34': '&quot;',\n\t    '160': '&nbsp;',\n\t    '162': '&cent;',\n\t    '163': '&pound;',\n\t    '164': '&curren;',\n\t    '169': '&copy;',\n\t    '174': '&reg;'\n\t};\n\t\n\tinternals.safeCharCodes = (function () {\n\t\n\t    var safe = {};\n\t\n\t    for (var i = 32; i < 123; ++i) {\n\t\n\t        if (i >= 97 || // a-z\n\t        i >= 65 && i <= 90 || // A-Z\n\t        i >= 48 && i <= 57 || // 0-9\n\t        i === 32 || // space\n\t        i === 46 || // .\n\t        i === 44 || // ,\n\t        i === 45 || // -\n\t        i === 58 || // :\n\t        i === 95) {\n\t            // _\n\t\n\t            safe[i] = null;\n\t        }\n\t    }\n\t\n\t    return safe;\n\t})();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 2).Buffer))\n\n/***/ },\n/* 12 */\n/*!********************!*\\\n  !*** ./lib/ref.js ***!\n  \\********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\texports.create = function (key, options) {\n\t\n\t    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);\n\t\n\t    var settings = Hoek.clone(options); // options can be reused and modified\n\t\n\t    var ref = function ref(value, validationOptions) {\n\t\n\t        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);\n\t    };\n\t\n\t    ref.isContext = key[0] === (settings && settings.contextPrefix || '$');\n\t    ref.key = ref.isContext ? key.slice(1) : key;\n\t    ref.path = ref.key.split(settings && settings.separator || '.');\n\t    ref.depth = ref.path.length;\n\t    ref.root = ref.path[0];\n\t    ref.isJoi = true;\n\t\n\t    ref.toString = function () {\n\t\n\t        return (ref.isContext ? 'context:' : 'ref:') + ref.key;\n\t    };\n\t\n\t    return ref;\n\t};\n\t\n\texports.isRef = function (ref) {\n\t\n\t    return typeof ref === 'function' && ref.isJoi;\n\t};\n\t\n\texports.push = function (array, ref) {\n\t\n\t    if (exports.isRef(ref) && !ref.isContext) {\n\t\n\t        array.push(ref.root);\n\t    }\n\t};\n\n/***/ },\n/* 13 */\n/*!***********************!*\\\n  !*** ./lib/errors.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\tvar Language = __webpack_require__(/*! ./language */ 14);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.stringify = function (value, wrapArrays) {\n\t\n\t    var type = typeof value;\n\t\n\t    if (value === null) {\n\t        return 'null';\n\t    }\n\t\n\t    if (type === 'string') {\n\t        return value;\n\t    }\n\t\n\t    if (value instanceof internals.Err || type === 'function') {\n\t        return value.toString();\n\t    }\n\t\n\t    if (type === 'object') {\n\t        if (Array.isArray(value)) {\n\t            var partial = '';\n\t\n\t            for (var i = 0; i < value.length; ++i) {\n\t                partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);\n\t            }\n\t\n\t            return wrapArrays ? '[' + partial + ']' : partial;\n\t        }\n\t\n\t        return value.toString();\n\t    }\n\t\n\t    return JSON.stringify(value);\n\t};\n\t\n\tinternals.Err = function (type, context, state, options) {\n\t\n\t    this.type = type;\n\t    this.context = context || {};\n\t    this.context.key = state.key;\n\t    this.path = state.path;\n\t    this.options = options;\n\t};\n\t\n\tinternals.Err.prototype.toString = function () {\n\t    var _this = this;\n\t\n\t    var localized = this.options.language;\n\t\n\t    if (localized.label) {\n\t        this.context.key = localized.label;\n\t    } else if (this.context.key === '' || this.context.key === null) {\n\t        this.context.key = localized.root || Language.errors.root;\n\t    }\n\t\n\t    var format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);\n\t    var hasKey = /\\{\\{\\!?key\\}\\}/.test(format);\n\t    var skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';\n\t\n\t    if (skipKey) {\n\t        format = format.slice(2);\n\t    }\n\t\n\t    if (!hasKey && !skipKey) {\n\t        format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;\n\t    }\n\t\n\t    var wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');\n\t    if (typeof wrapArrays !== 'boolean') {\n\t        wrapArrays = Language.errors.messages.wrapArrays;\n\t    }\n\t\n\t    var message = format.replace(/\\{\\{(\\!?)([^}]+)\\}\\}/g, function ($0, isSecure, name) {\n\t\n\t        var value = Hoek.reach(_this.context, name);\n\t        var normalized = internals.stringify(value, wrapArrays);\n\t        return isSecure ? Hoek.escapeHtml(normalized) : normalized;\n\t    });\n\t\n\t    return message;\n\t};\n\t\n\texports.create = function (type, context, state, options) {\n\t\n\t    return new internals.Err(type, context, state, options);\n\t};\n\t\n\texports.process = function (errors, object) {\n\t\n\t    if (!errors || !errors.length) {\n\t        return null;\n\t    }\n\t\n\t    // Construct error\n\t\n\t    var message = '';\n\t    var details = [];\n\t\n\t    var processErrors = function processErrors(localErrors, parent) {\n\t\n\t        for (var i = 0; i < localErrors.length; ++i) {\n\t            var item = localErrors[i];\n\t\n\t            var detail = {\n\t                message: item.toString(),\n\t                path: internals.getPath(item),\n\t                type: item.type,\n\t                context: item.context\n\t            };\n\t\n\t            if (!parent) {\n\t                message = message + (message ? '. ' : '') + detail.message;\n\t            }\n\t\n\t            // Do not push intermediate errors, we're only interested in leafs\n\t            if (item.context.reason && item.context.reason.length) {\n\t                processErrors(item.context.reason, item.path);\n\t            } else {\n\t                details.push(detail);\n\t            }\n\t        }\n\t    };\n\t\n\t    processErrors(errors);\n\t\n\t    var error = new Error(message);\n\t    error.name = 'ValidationError';\n\t    error.details = details;\n\t    error._object = object;\n\t    error.annotate = internals.annotate;\n\t    return error;\n\t};\n\t\n\tinternals.getPath = function (item) {\n\t\n\t    var recursePath = function recursePath(_x) {\n\t        var _again = true;\n\t\n\t        _function: while (_again) {\n\t            var it = _x;\n\t            _again = false;\n\t\n\t            var reachedItem = Hoek.reach(it, 'context.reason.0');\n\t            if (reachedItem && reachedItem.context) {\n\t                _x = reachedItem;\n\t                _again = true;\n\t                reachedItem = undefined;\n\t                continue _function;\n\t            }\n\t\n\t            return it.path;\n\t        }\n\t    };\n\t\n\t    return recursePath(item) || item.context.key;\n\t};\n\t\n\t// Inspired by json-stringify-safe\n\tinternals.safeStringify = function (obj, spaces) {\n\t\n\t    return JSON.stringify(obj, internals.serializer(), spaces);\n\t};\n\t\n\tinternals.serializer = function () {\n\t\n\t    var keys = [];\n\t    var stack = [];\n\t\n\t    var cycleReplacer = function cycleReplacer(key, value) {\n\t\n\t        if (stack[0] === value) {\n\t            return '[Circular ~]';\n\t        }\n\t\n\t        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n\t    };\n\t\n\t    return function (key, value) {\n\t\n\t        if (stack.length > 0) {\n\t            var thisPos = stack.indexOf(this);\n\t            if (~thisPos) {\n\t                stack.length = thisPos + 1;\n\t                keys.length = thisPos + 1;\n\t                keys[thisPos] = key;\n\t            } else {\n\t                stack.push(this);\n\t                keys.push(key);\n\t            }\n\t\n\t            if (~stack.indexOf(value)) {\n\t                value = cycleReplacer.call(this, key, value);\n\t            }\n\t        } else {\n\t            stack.push(value);\n\t        }\n\t\n\t        if (Array.isArray(value) && value.placeholders) {\n\t            var placeholders = value.placeholders;\n\t            var arrWithPlaceholders = [];\n\t            for (var i = 0; i < value.length; ++i) {\n\t                if (placeholders[i]) {\n\t                    arrWithPlaceholders.push(placeholders[i]);\n\t                }\n\t                arrWithPlaceholders.push(value[i]);\n\t            }\n\t\n\t            value = arrWithPlaceholders;\n\t        }\n\t\n\t        return value;\n\t    };\n\t};\n\t\n\tinternals.annotate = function () {\n\t\n\t    if (typeof this._object !== 'object') {\n\t        return this.details[0].message;\n\t    }\n\t\n\t    var obj = Hoek.clone(this._object || {});\n\t\n\t    var lookup = {};\n\t    for (var i = this.details.length - 1; i >= 0; --i) {\n\t        // Reverse order to process deepest child first\n\t        var pos = this.details.length - i;\n\t        var error = this.details[i];\n\t        var path = error.path.split('.');\n\t        var ref = obj;\n\t        for (var j = 0; j < path.length && ref; ++j) {\n\t            var seg = path[j];\n\t            if (j + 1 < path.length) {\n\t                ref = ref[seg];\n\t            } else {\n\t                var value = ref[seg];\n\t                if (Array.isArray(ref)) {\n\t                    var arrayLabel = '_$idx$_' + (i + 1) + '_$end$_';\n\t                    if (!ref.placeholders) {\n\t                        ref.placeholders = {};\n\t                    }\n\t\n\t                    if (ref.placeholders[seg]) {\n\t                        ref.placeholders[seg] = ref.placeholders[seg].replace('_$end$_', ', ' + (i + 1) + '_$end$_');\n\t                    } else {\n\t                        ref.placeholders[seg] = arrayLabel;\n\t                    }\n\t                } else {\n\t                    if (value !== undefined) {\n\t                        delete ref[seg];\n\t                        var objectLabel = seg + '_$key$_' + pos + '_$end$_';\n\t                        ref[objectLabel] = value;\n\t                        lookup[error.path] = objectLabel;\n\t                    } else if (lookup[error.path]) {\n\t                        var replacement = lookup[error.path];\n\t                        var appended = replacement.replace('_$end$_', ', ' + pos + '_$end$_');\n\t                        ref[appended] = ref[replacement];\n\t                        lookup[error.path] = appended;\n\t                        delete ref[replacement];\n\t                    } else {\n\t                        ref['_$miss$_' + seg + '|' + pos + '_$end$_'] = '__missing__';\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    var message = internals.safeStringify(obj, 2).replace(/_\\$key\\$_([, \\d]+)_\\$end\\$_\\\"/g, function ($0, $1) {\n\t\n\t        return '\" \\u001b[31m[' + $1 + ']\\u001b[0m';\n\t    }).replace(/\\\"_\\$miss\\$_([^\\|]+)\\|(\\d+)_\\$end\\$_\\\"\\: \\\"__missing__\\\"/g, function ($0, $1, $2) {\n\t\n\t        return '\\u001b[41m\"' + $1 + '\"\\u001b[0m\\u001b[31m [' + $2 + ']: -- missing --\\u001b[0m';\n\t    }).replace(/\\s*\\\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\\\",?\\n(.*)/g, function ($0, $1, $2) {\n\t\n\t        return '\\n' + $2 + ' \\u001b[31m[' + $1 + ']\\u001b[0m';\n\t    });\n\t\n\t    message = message + '\\n\\u001b[31m';\n\t\n\t    for (var i = 0; i < this.details.length; ++i) {\n\t        message = message + '\\n[' + (i + 1) + '] ' + this.details[i].message;\n\t    }\n\t\n\t    message = message + '\\u001b[0m';\n\t\n\t    return message;\n\t};\n\n/***/ },\n/* 14 */\n/*!*************************!*\\\n  !*** ./lib/language.js ***!\n  \\*************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\texports.errors = {\n\t    root: 'value',\n\t    key: '\"{{!key}}\" ',\n\t    messages: {\n\t        wrapArrays: true\n\t    },\n\t    any: {\n\t        unknown: 'is not allowed',\n\t        invalid: 'contains an invalid value',\n\t        empty: 'is not allowed to be empty',\n\t        required: 'is required',\n\t        allowOnly: 'must be one of {{valids}}',\n\t        'default': 'threw an error when running default method'\n\t    },\n\t    alternatives: {\n\t        base: 'not matching any of the allowed alternatives'\n\t    },\n\t    array: {\n\t        base: 'must be an array',\n\t        includes: 'at position {{pos}} does not match any of the allowed types',\n\t        includesSingle: 'single value of \"{{!key}}\" does not match any of the allowed types',\n\t        includesOne: 'at position {{pos}} fails because {{reason}}',\n\t        includesOneSingle: 'single value of \"{{!key}}\" fails because {{reason}}',\n\t        includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',\n\t        includesRequiredKnowns: 'does not contain {{knownMisses}}',\n\t        includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',\n\t        excludes: 'at position {{pos}} contains an excluded value',\n\t        excludesSingle: 'single value of \"{{!key}}\" contains an excluded value',\n\t        min: 'must contain at least {{limit}} items',\n\t        max: 'must contain less than or equal to {{limit}} items',\n\t        length: 'must contain {{limit}} items',\n\t        ordered: 'at position {{pos}} fails because {{reason}}',\n\t        orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',\n\t        sparse: 'must not be a sparse array',\n\t        unique: 'position {{pos}} contains a duplicate value'\n\t    },\n\t    boolean: {\n\t        base: 'must be a boolean'\n\t    },\n\t    binary: {\n\t        base: 'must be a buffer or a string',\n\t        min: 'must be at least {{limit}} bytes',\n\t        max: 'must be less than or equal to {{limit}} bytes',\n\t        length: 'must be {{limit}} bytes'\n\t    },\n\t    date: {\n\t        base: 'must be a number of milliseconds or valid date string',\n\t        min: 'must be larger than or equal to \"{{limit}}\"',\n\t        max: 'must be less than or equal to \"{{limit}}\"',\n\t        isoDate: 'must be a valid ISO 8601 date',\n\t        ref: 'references \"{{ref}}\" which is not a date'\n\t    },\n\t    'function': {\n\t        base: 'must be a Function'\n\t    },\n\t    object: {\n\t        base: 'must be an object',\n\t        child: 'child \"{{!key}}\" fails because {{reason}}',\n\t        min: 'must have at least {{limit}} children',\n\t        max: 'must have less than or equal to {{limit}} children',\n\t        length: 'must have {{limit}} children',\n\t        allowUnknown: 'is not allowed',\n\t        'with': 'missing required peer \"{{peer}}\"',\n\t        without: 'conflict with forbidden peer \"{{peer}}\"',\n\t        missing: 'must contain at least one of {{peers}}',\n\t        xor: 'contains a conflict between exclusive peers {{peers}}',\n\t        or: 'must contain at least one of {{peers}}',\n\t        and: 'contains {{present}} without its required peers {{missing}}',\n\t        nand: '!!\"{{main}}\" must not exist simultaneously with {{peers}}',\n\t        assert: '!!\"{{ref}}\" validation failed because \"{{ref}}\" failed to {{message}}',\n\t        rename: {\n\t            multiple: 'cannot rename child \"{{from}}\" because multiple renames are disabled and another key was already renamed to \"{{to}}\"',\n\t            override: 'cannot rename child \"{{from}}\" because override is disabled and target \"{{to}}\" exists'\n\t        },\n\t        type: 'must be an instance of \"{{type}}\"'\n\t    },\n\t    number: {\n\t        base: 'must be a number',\n\t        min: 'must be larger than or equal to {{limit}}',\n\t        max: 'must be less than or equal to {{limit}}',\n\t        less: 'must be less than {{limit}}',\n\t        greater: 'must be greater than {{limit}}',\n\t        float: 'must be a float or double',\n\t        integer: 'must be an integer',\n\t        negative: 'must be a negative number',\n\t        positive: 'must be a positive number',\n\t        precision: 'must have no more than {{limit}} decimal places',\n\t        ref: 'references \"{{ref}}\" which is not a number',\n\t        multiple: 'must be a multiple of {{multiple}}'\n\t    },\n\t    string: {\n\t        base: 'must be a string',\n\t        min: 'length must be at least {{limit}} characters long',\n\t        max: 'length must be less than or equal to {{limit}} characters long',\n\t        length: 'length must be {{limit}} characters long',\n\t        alphanum: 'must only contain alpha-numeric characters',\n\t        token: 'must only contain alpha-numeric and underscore characters',\n\t        regex: {\n\t            base: 'with value \"{{!value}}\" fails to match the required pattern: {{pattern}}',\n\t            name: 'with value \"{{!value}}\" fails to match the {{name}} pattern'\n\t        },\n\t        email: 'must be a valid email',\n\t        uri: 'must be a valid uri',\n\t        uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',\n\t        isoDate: 'must be a valid ISO 8601 date',\n\t        guid: 'must be a valid GUID',\n\t        hex: 'must only contain hexadecimal characters',\n\t        hostname: 'must be a valid hostname',\n\t        lowercase: 'must only contain lowercase characters',\n\t        uppercase: 'must only contain uppercase characters',\n\t        trim: 'must not have leading or trailing whitespace',\n\t        creditCard: 'must be a credit card',\n\t        ref: 'references \"{{ref}}\" which is not a number',\n\t        ip: 'must be a valid ip address with a {{cidr}} CIDR',\n\t        ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'\n\t    }\n\t};\n\n/***/ },\n/* 15 */\n/*!*********************!*\\\n  !*** ./lib/cast.js ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\tvar Ref = __webpack_require__(/*! ./ref */ 12);\n\t\n\t// Type modules are delay-loaded to prevent circular dependencies\n\t\n\t// Declare internals\n\t\n\tvar internals = {\n\t    any: null,\n\t    date: __webpack_require__(/*! ./date */ 16),\n\t    string: __webpack_require__(/*! ./string */ 18),\n\t    number: __webpack_require__(/*! ./number */ 26),\n\t    boolean: __webpack_require__(/*! ./boolean */ 27),\n\t    alt: null,\n\t    object: null\n\t};\n\t\n\texports.schema = function (config) {\n\t\n\t    internals.any = internals.any || new (__webpack_require__(/*! ./any */ 1))();\n\t    internals.alt = internals.alt || __webpack_require__(/*! ./alternatives */ 28);\n\t    internals.object = internals.object || __webpack_require__(/*! ./object */ 29);\n\t\n\t    if (config && typeof config === 'object') {\n\t\n\t        if (config.isJoi) {\n\t            return config;\n\t        }\n\t\n\t        if (Array.isArray(config)) {\n\t            return internals.alt['try'](config);\n\t        }\n\t\n\t        if (config instanceof RegExp) {\n\t            return internals.string.regex(config);\n\t        }\n\t\n\t        if (config instanceof Date) {\n\t            return internals.date.valid(config);\n\t        }\n\t\n\t        return internals.object.keys(config);\n\t    }\n\t\n\t    if (typeof config === 'string') {\n\t        return internals.string.valid(config);\n\t    }\n\t\n\t    if (typeof config === 'number') {\n\t        return internals.number.valid(config);\n\t    }\n\t\n\t    if (typeof config === 'boolean') {\n\t        return internals.boolean.valid(config);\n\t    }\n\t\n\t    if (Ref.isRef(config)) {\n\t        return internals.any.valid(config);\n\t    }\n\t\n\t    Hoek.assert(config === null, 'Invalid schema content:', config);\n\t\n\t    return internals.any.valid(null);\n\t};\n\t\n\texports.ref = function (id) {\n\t\n\t    return Ref.isRef(id) ? id : Ref.create(id);\n\t};\n\n/***/ },\n/* 16 */\n/*!*********************!*\\\n  !*** ./lib/date.js ***!\n  \\*********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\tvar Ref = __webpack_require__(/*! ./ref */ 12);\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\tvar Moment = __webpack_require__(/*! moment */ 17);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.isoDate = /^(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/;\n\tinternals.invalidDate = new Date('');\n\tinternals.isIsoDate = (function () {\n\t\n\t    var isoString = internals.isoDate.toString();\n\t\n\t    return function (date) {\n\t\n\t        return date && date.toString() === isoString;\n\t    };\n\t})();\n\t\n\tinternals.Date = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'date';\n\t};\n\t\n\tHoek.inherits(internals.Date, Any);\n\t\n\tinternals.Date.prototype._base = function (value, state, options) {\n\t\n\t    var result = {\n\t        value: options.convert && internals.toDate(value, this._flags.format) || value\n\t    };\n\t\n\t    if (result.value instanceof Date && !isNaN(result.value.getTime())) {\n\t        result.errors = null;\n\t    } else {\n\t        result.errors = Errors.create(internals.isIsoDate(this._flags.format) ? 'date.isoDate' : 'date.base', null, state, options);\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\tinternals.toDate = function (value, format) {\n\t\n\t    if (value instanceof Date) {\n\t        return value;\n\t    }\n\t\n\t    if (typeof value === 'string' || Hoek.isInteger(value)) {\n\t\n\t        if (typeof value === 'string' && /^[+-]?\\d+$/.test(value)) {\n\t\n\t            value = parseInt(value, 10);\n\t        }\n\t\n\t        var date = undefined;\n\t        if (format) {\n\t            if (internals.isIsoDate(format)) {\n\t                date = format.test(value) ? new Date(value) : internals.invalidDate;\n\t            } else {\n\t                date = Moment(value, format, true);\n\t                date = date.isValid() ? date.toDate() : internals.invalidDate;\n\t            }\n\t        } else {\n\t            date = new Date(value);\n\t        }\n\t\n\t        if (!isNaN(date.getTime())) {\n\t            return date;\n\t        }\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\tinternals.compare = function (type, compare) {\n\t\n\t    return function (date) {\n\t\n\t        var isNow = date === 'now';\n\t        var isRef = Ref.isRef(date);\n\t\n\t        if (!isNow && !isRef) {\n\t            date = internals.toDate(date);\n\t        }\n\t\n\t        Hoek.assert(date, 'Invalid date format');\n\t\n\t        return this._test(type, date, function (value, state, options) {\n\t\n\t            var compareTo = undefined;\n\t            if (isNow) {\n\t                compareTo = Date.now();\n\t            } else if (isRef) {\n\t                compareTo = internals.toDate(date(state.parent, options));\n\t\n\t                if (!compareTo) {\n\t                    return Errors.create('date.ref', { ref: date.key }, state, options);\n\t                }\n\t\n\t                compareTo = compareTo.getTime();\n\t            } else {\n\t                compareTo = date.getTime();\n\t            }\n\t\n\t            if (compare(value.getTime(), compareTo)) {\n\t                return null;\n\t            }\n\t\n\t            return Errors.create('date.' + type, { limit: new Date(compareTo) }, state, options);\n\t        });\n\t    };\n\t};\n\t\n\tinternals.Date.prototype.min = internals.compare('min', function (value, date) {\n\t    return value >= date;\n\t});\n\tinternals.Date.prototype.max = internals.compare('max', function (value, date) {\n\t    return value <= date;\n\t});\n\t\n\tinternals.Date.prototype.format = function (format) {\n\t\n\t    Hoek.assert(typeof format === 'string' || Array.isArray(format) && format.every(function (f) {\n\t        return typeof f === 'string';\n\t    }), 'Invalid format.');\n\t\n\t    var obj = this.clone();\n\t    obj._flags.format = format;\n\t    return obj;\n\t};\n\t\n\tinternals.Date.prototype.iso = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.format = internals.isoDate;\n\t    return obj;\n\t};\n\t\n\tinternals.Date.prototype._isIsoDate = function (value) {\n\t\n\t    return internals.isoDate.test(value);\n\t};\n\t\n\tmodule.exports = new internals.Date();\n\n/***/ },\n/* 17 */\n/*!*******************************!*\\\n  !*** ./lib/browser-moment.js ***!\n  \\*******************************/\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = function () {\n\t\treturn {\n\t\t\tisValid: function isValid() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t};\n\n/***/ },\n/* 18 */\n/*!***********************!*\\\n  !*** ./lib/string.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\t// Load modules\n\t\n\tvar Net = __webpack_require__(/*! net */ 19);\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\tvar Isemail = __webpack_require__(/*! isemail */ 22);\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Ref = __webpack_require__(/*! ./ref */ 12);\n\tvar JoiDate = __webpack_require__(/*! ./date */ 16);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\tvar Uri = __webpack_require__(/*! ./string/uri */ 23);\n\tvar Ip = __webpack_require__(/*! ./string/ip */ 25);\n\t\n\t// Declare internals\n\t\n\tvar internals = {\n\t    uriRegex: Uri.createUriRegex(),\n\t    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')\n\t};\n\t\n\tinternals.String = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'string';\n\t    this._invalids.add('');\n\t};\n\t\n\tHoek.inherits(internals.String, Any);\n\t\n\tinternals.compare = function (type, compare) {\n\t\n\t    return function (limit, encoding) {\n\t\n\t        var isRef = Ref.isRef(limit);\n\t\n\t        Hoek.assert(Hoek.isInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n\t        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\t\n\t        return this._test(type, limit, function (value, state, options) {\n\t\n\t            var compareTo = undefined;\n\t            if (isRef) {\n\t                compareTo = limit(state.parent, options);\n\t\n\t                if (!Hoek.isInteger(compareTo)) {\n\t                    return Errors.create('string.ref', { ref: limit.key }, state, options);\n\t                }\n\t            } else {\n\t                compareTo = limit;\n\t            }\n\t\n\t            if (compare(value, compareTo, encoding)) {\n\t                return null;\n\t            }\n\t\n\t            return Errors.create('string.' + type, { limit: compareTo, value: value, encoding: encoding }, state, options);\n\t        });\n\t    };\n\t};\n\t\n\tinternals.String.prototype._base = function (value, state, options) {\n\t\n\t    if (typeof value === 'string' && options.convert) {\n\t\n\t        if (this._flags['case']) {\n\t            value = this._flags['case'] === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n\t        }\n\t\n\t        if (this._flags.trim) {\n\t            value = value.trim();\n\t        }\n\t\n\t        if (this._inner.replacements) {\n\t\n\t            for (var i = 0; i < this._inner.replacements.length; ++i) {\n\t                var replacement = this._inner.replacements[i];\n\t                value = value.replace(replacement.pattern, replacement.replacement);\n\t            }\n\t        }\n\t    }\n\t\n\t    return {\n\t        value: value,\n\t        errors: typeof value === 'string' ? null : Errors.create('string.base', { value: value }, state, options)\n\t    };\n\t};\n\t\n\tinternals.String.prototype.insensitive = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.insensitive = true;\n\t    return obj;\n\t};\n\t\n\tinternals.String.prototype.min = internals.compare('min', function (value, limit, encoding) {\n\t\n\t    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n\t    return length >= limit;\n\t});\n\t\n\tinternals.String.prototype.max = internals.compare('max', function (value, limit, encoding) {\n\t\n\t    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n\t    return length <= limit;\n\t});\n\t\n\tinternals.String.prototype.creditCard = function () {\n\t\n\t    return this._test('creditCard', undefined, function (value, state, options) {\n\t\n\t        var i = value.length;\n\t        var sum = 0;\n\t        var mul = 1;\n\t\n\t        while (i--) {\n\t            var char = value.charAt(i) * mul;\n\t            sum = sum + (char - (char > 9) * 9);\n\t            mul = mul ^ 3;\n\t        }\n\t\n\t        var check = sum % 10 === 0 && sum > 0;\n\t        return check ? null : Errors.create('string.creditCard', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.length = internals.compare('length', function (value, limit, encoding) {\n\t\n\t    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n\t    return length === limit;\n\t});\n\t\n\tinternals.String.prototype.regex = function (pattern, name) {\n\t\n\t    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n\t\n\t    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n\t\n\t    return this._test('regex', pattern, function (value, state, options) {\n\t\n\t        if (pattern.test(value)) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create(name ? 'string.regex.name' : 'string.regex.base', { name: name, pattern: pattern, value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.alphanum = function () {\n\t\n\t    return this._test('alphanum', undefined, function (value, state, options) {\n\t\n\t        if (/^[a-zA-Z0-9]+$/.test(value)) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.alphanum', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.token = function () {\n\t\n\t    return this._test('token', undefined, function (value, state, options) {\n\t\n\t        if (/^\\w+$/.test(value)) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.token', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.email = function (isEmailOptions) {\n\t\n\t    if (isEmailOptions) {\n\t        Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n\t        Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n\t        Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n\t        Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');\n\t        Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');\n\t    }\n\t\n\t    return this._test('email', isEmailOptions, function (value, state, options) {\n\t\n\t        try {\n\t            var result = Isemail.validate(value, isEmailOptions);\n\t            if (result === true || result === 0) {\n\t                return null;\n\t            }\n\t        } catch (e) {}\n\t\n\t        return Errors.create('string.email', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.ip = function (ipOptions) {\n\t\n\t    var regex = internals.ipRegex;\n\t    ipOptions = ipOptions || {};\n\t    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\t\n\t    if (ipOptions.cidr) {\n\t        Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n\t        ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\t\n\t        Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', '));\n\t\n\t        // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\t        if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n\t            regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n\t        }\n\t    } else {\n\t\n\t        // Set our default cidr strategy\n\t        ipOptions.cidr = 'optional';\n\t    }\n\t\n\t    var versions = undefined;\n\t    if (ipOptions.version) {\n\t        if (!Array.isArray(ipOptions.version)) {\n\t            ipOptions.version = [ipOptions.version];\n\t        }\n\t\n\t        Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\t\n\t        versions = [];\n\t        for (var i = 0; i < ipOptions.version.length; ++i) {\n\t            var version = ipOptions.version[i];\n\t            Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n\t            version = version.toLowerCase();\n\t            Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n\t            versions.push(version);\n\t        }\n\t\n\t        // Make sure we have a set of versions\n\t        versions = Hoek.unique(versions);\n\t\n\t        regex = Ip.createIpRegex(versions, ipOptions.cidr);\n\t    }\n\t\n\t    return this._test('ip', ipOptions, function (value, state, options) {\n\t\n\t        if (regex.test(value)) {\n\t            return null;\n\t        }\n\t\n\t        if (versions) {\n\t            return Errors.create('string.ipVersion', { value: value, cidr: ipOptions.cidr, version: versions }, state, options);\n\t        }\n\t\n\t        return Errors.create('string.ip', { value: value, cidr: ipOptions.cidr }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.uri = function (uriOptions) {\n\t\n\t    var customScheme = '';\n\t    var regex = internals.uriRegex;\n\t\n\t    if (uriOptions) {\n\t        Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\t\n\t        if (uriOptions.scheme) {\n\t            Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\t\n\t            if (!Array.isArray(uriOptions.scheme)) {\n\t                uriOptions.scheme = [uriOptions.scheme];\n\t            }\n\t\n\t            Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\t\n\t            // Flatten the array into a string to be used to match the schemes.\n\t            for (var i = 0; i < uriOptions.scheme.length; ++i) {\n\t                var scheme = uriOptions.scheme[i];\n\t                Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\t\n\t                // Add OR separators if a value already exists\n\t                customScheme = customScheme + (customScheme ? '|' : '');\n\t\n\t                // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\t                if (scheme instanceof RegExp) {\n\t                    customScheme = customScheme + scheme.source;\n\t                } else {\n\t                    Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n\t                    customScheme = customScheme + Hoek.escapeRegex(scheme);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    if (customScheme) {\n\t        regex = Uri.createUriRegex(customScheme);\n\t    }\n\t\n\t    return this._test('uri', uriOptions, function (value, state, options) {\n\t\n\t        if (regex.test(value)) {\n\t            return null;\n\t        }\n\t\n\t        if (customScheme) {\n\t            return Errors.create('string.uriCustomScheme', { scheme: customScheme, value: value }, state, options);\n\t        }\n\t\n\t        return Errors.create('string.uri', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.isoDate = function () {\n\t\n\t    return this._test('isoDate', undefined, function (value, state, options) {\n\t\n\t        if (JoiDate._isIsoDate(value)) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.isoDate', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.guid = function () {\n\t\n\t    var regex = /^[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}$/i;\n\t    var regex2 = /^\\{[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}\\}$/i;\n\t\n\t    return this._test('guid', undefined, function (value, state, options) {\n\t\n\t        if (regex.test(value) || regex2.test(value)) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.guid', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.hex = function () {\n\t\n\t    var regex = /^[a-f0-9]+$/i;\n\t\n\t    return this._test('hex', regex, function (value, state, options) {\n\t\n\t        if (regex.test(value)) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.hex', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.hostname = function () {\n\t\n\t    var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\t\n\t    return this._test('hostname', undefined, function (value, state, options) {\n\t\n\t        if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n\t\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.hostname', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.String.prototype.lowercase = function () {\n\t\n\t    var obj = this._test('lowercase', undefined, function (value, state, options) {\n\t\n\t        if (options.convert || value === value.toLocaleLowerCase()) {\n\t\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.lowercase', { value: value }, state, options);\n\t    });\n\t\n\t    obj._flags['case'] = 'lower';\n\t    return obj;\n\t};\n\t\n\tinternals.String.prototype.uppercase = function () {\n\t\n\t    var obj = this._test('uppercase', undefined, function (value, state, options) {\n\t\n\t        if (options.convert || value === value.toLocaleUpperCase()) {\n\t\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.uppercase', { value: value }, state, options);\n\t    });\n\t\n\t    obj._flags['case'] = 'upper';\n\t    return obj;\n\t};\n\t\n\tinternals.String.prototype.trim = function () {\n\t\n\t    var obj = this._test('trim', undefined, function (value, state, options) {\n\t\n\t        if (options.convert || value === value.trim()) {\n\t\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('string.trim', { value: value }, state, options);\n\t    });\n\t\n\t    obj._flags.trim = true;\n\t    return obj;\n\t};\n\t\n\tinternals.String.prototype.replace = function (pattern, replacement) {\n\t\n\t    if (typeof pattern === 'string') {\n\t        pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n\t    }\n\t\n\t    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n\t    Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\t\n\t    // This can not be considere a test like trim, we can't \"reject\"\n\t    // anything from this rule, so just clone the current object\n\t    var obj = this.clone();\n\t\n\t    if (!obj._inner.replacements) {\n\t        obj._inner.replacements = [];\n\t    }\n\t\n\t    obj._inner.replacements.push({\n\t        pattern: pattern,\n\t        replacement: replacement\n\t    });\n\t\n\t    return obj;\n\t};\n\t\n\tmodule.exports = new internals.String();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 2).Buffer))\n\n/***/ },\n/* 19 */\n/*!****************************!*\\\n  !*** ./lib/browser-net.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t\tisIPv6: __webpack_require__(/*! is-ipv6-node */ 20)\n\t};\n\n/***/ },\n/* 20 */\n/*!*********************************!*\\\n  !*** ./~/is-ipv6-node/index.js ***!\n  \\*********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module index\n\t * @description Entry point for is-ipv6-node module.\n\t * @version 1.0.6\n\t * @author Anatoliy Gatt [anatoliy.gatt@aol.com]\n\t * @copyright Copyright (c) 2015 Anatoliy Gatt\n\t * @license MIT\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * @public\n\t * @description Expose function to check if {String} is an IPv6 address.\n\t * @returns {Function} - Function to check if {String} is an IPv6 address.\n\t */\n\t\n\tmodule.exports = __webpack_require__(/*! ./lib/is-ipv6 */ 21);\n\n/***/ },\n/* 21 */\n/*!***************************************!*\\\n  !*** ./~/is-ipv6-node/lib/is-ipv6.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * @module is-ipv6\n\t * @description Provides function to check if {String} is an IPv6 address.\n\t * @version 1.0.6\n\t * @author Anatoliy Gatt [anatoliy.gatt@aol.com]\n\t * @copyright Copyright (c) 2015 Anatoliy Gatt\n\t * @license MIT\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * @public\n\t * @function isIPv6\n\t * @description Check if {String} is an IPv6 address.\n\t * @param {String} string - String to check.\n\t * @returns {Boolean} - Determine whether a {String} is an IPv6 address.\n\t */\n\t\n\tfunction isIPv6(string) {\n\t  return !!/(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/.test(string);\n\t}\n\t\n\t/**\n\t * @public\n\t * @description Expose function to check if {String} is an IPv6 address.\n\t * @param {String} string - String to check.\n\t * @returns {Boolean} - Determine whether a {String} is an IPv6 address.\n\t */\n\t\n\tmodule.exports = function (string) {\n\t  return isIPv6(string);\n\t};\n\n/***/ },\n/* 22 */\n/*!********************************!*\\\n  !*** ./~/isemail/lib/index.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Dns = __webpack_require__(/*! dns */ 7);\n\t\n\t// Declare internals\n\t\n\tvar internals = {\n\t    hasOwn: Object.prototype.hasOwnProperty,\n\t    indexOf: Array.prototype.indexOf,\n\t    defaultThreshold: 16,\n\t    maxIPv6Groups: 8,\n\t\n\t    categories: {\n\t        valid: 1,\n\t        dnsWarn: 7,\n\t        rfc5321: 15,\n\t        cfws: 31,\n\t        deprecated: 63,\n\t        rfc5322: 127,\n\t        error: 255\n\t    },\n\t\n\t    diagnoses: {\n\t\n\t        // Address is valid\n\t\n\t        valid: 0,\n\t\n\t        // Address is valid, but the DNS check failed\n\t\n\t        dnsWarnNoMXRecord: 5,\n\t        dnsWarnNoRecord: 6,\n\t\n\t        // Address is valid for SMTP but has unusual elements\n\t\n\t        rfc5321TLD: 9,\n\t        rfc5321TLDNumeric: 10,\n\t        rfc5321QuotedString: 11,\n\t        rfc5321AddressLiteral: 12,\n\t\n\t        // Address is valid for message, but must be modified for envelope\n\t\n\t        cfwsComment: 17,\n\t        cfwsFWS: 18,\n\t\n\t        // Address contains deprecated elements, but may still be valid in some contexts\n\t\n\t        deprecatedLocalPart: 33,\n\t        deprecatedFWS: 34,\n\t        deprecatedQTEXT: 35,\n\t        deprecatedQP: 36,\n\t        deprecatedComment: 37,\n\t        deprecatedCTEXT: 38,\n\t        deprecatedIPv6: 39,\n\t        deprecatedCFWSNearAt: 49,\n\t\n\t        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\n\t\n\t        rfc5322Domain: 65,\n\t        rfc5322TooLong: 66,\n\t        rfc5322LocalTooLong: 67,\n\t        rfc5322DomainTooLong: 68,\n\t        rfc5322LabelTooLong: 69,\n\t        rfc5322DomainLiteral: 70,\n\t        rfc5322DomainLiteralOBSDText: 71,\n\t        rfc5322IPv6GroupCount: 72,\n\t        rfc5322IPv62x2xColon: 73,\n\t        rfc5322IPv6BadCharacter: 74,\n\t        rfc5322IPv6MaxGroups: 75,\n\t        rfc5322IPv6ColonStart: 76,\n\t        rfc5322IPv6ColonEnd: 77,\n\t\n\t        // Address is invalid for any purpose\n\t\n\t        errExpectingDTEXT: 129,\n\t        errNoLocalPart: 130,\n\t        errNoDomain: 131,\n\t        errConsecutiveDots: 132,\n\t        errATEXTAfterCFWS: 133,\n\t        errATEXTAfterQS: 134,\n\t        errATEXTAfterDomainLiteral: 135,\n\t        errExpectingQPair: 136,\n\t        errExpectingATEXT: 137,\n\t        errExpectingQTEXT: 138,\n\t        errExpectingCTEXT: 139,\n\t        errBackslashEnd: 140,\n\t        errDotStart: 141,\n\t        errDotEnd: 142,\n\t        errDomainHyphenStart: 143,\n\t        errDomainHyphenEnd: 144,\n\t        errUnclosedQuotedString: 145,\n\t        errUnclosedComment: 146,\n\t        errUnclosedDomainLiteral: 147,\n\t        errFWSCRLFx2: 148,\n\t        errFWSCRLFEnd: 149,\n\t        errCRNoLF: 150,\n\t        errUnknownTLD: 160,\n\t        errDomainTooShort: 161\n\t    },\n\t\n\t    components: {\n\t        localpart: 0,\n\t        domain: 1,\n\t        literal: 2,\n\t        contextComment: 3,\n\t        contextFWS: 4,\n\t        contextQuotedString: 5,\n\t        contextQuotedPair: 6\n\t    }\n\t};\n\t\n\t// $lab:coverage:off$\n\tinternals.defer = typeof process !== 'undefined' && process && typeof process.nextTick === 'function' ? process.nextTick.bind(process) : function (callback) {\n\t\n\t    return setTimeout(callback, 0);\n\t};\n\t// $lab:coverage:on$\n\t\n\tinternals.specials = (function () {\n\t\n\t    var specials = '()<>[]:;@\\\\,.\"'; // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\n\t    var lookup = new Array(0x100);\n\t    for (var i = 0xff; i >= 0; --i) {\n\t        lookup[i] = false;\n\t    }\n\t\n\t    for (var i = 0; i < specials.length; ++i) {\n\t        lookup[specials.charCodeAt(i)] = true;\n\t    }\n\t\n\t    var body = 'return function (code) {\\n  return lookup[code];\\n}';\n\t    return new Function('lookup', body)(lookup);\n\t})();\n\t\n\tinternals.regex = {\n\t    ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n\t    ipV6: /^[a-fA-F\\d]{0,4}$/\n\t};\n\t\n\tinternals.checkIpV6 = function (items) {\n\t\n\t    return items.every(function (value) {\n\t        return internals.regex.ipV6.test(value);\n\t    });\n\t};\n\t\n\tinternals.validDomain = function (tldAtom, options) {\n\t\n\t    if (options.tldBlacklist) {\n\t        if (Array.isArray(options.tldBlacklist)) {\n\t            return internals.indexOf.call(options.tldBlacklist, tldAtom) === -1;\n\t        }\n\t\n\t        return !internals.hasOwn.call(options.tldBlacklist, tldAtom);\n\t    }\n\t\n\t    if (Array.isArray(options.tldWhitelist)) {\n\t        return internals.indexOf.call(options.tldWhitelist, tldAtom) !== -1;\n\t    }\n\t\n\t    return internals.hasOwn.call(options.tldWhitelist, tldAtom);\n\t};\n\t\n\t/**\r\n\t * Check that an email address conforms to RFCs 5321, 5322 and others\r\n\t *\r\n\t * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\r\n\t * addr-spec as defined by RFC 5322. Depending on the context, either can be\r\n\t * regarded as a valid email address. The RFC 5321 Mailbox specification is\r\n\t * more restrictive (comments, white space and obsolete forms are not allowed).\r\n\t *\r\n\t * @param {string} email The email address to check. See README for specifics.\r\n\t * @param {Object} options The (optional) options:\r\n\t *   {boolean} checkDNS If true then will check DNS for MX records. If\r\n\t *     true this call to isEmail _will_ be asynchronous.\r\n\t *   {*} errorLevel Determines the boundary between valid and invalid\r\n\t *     addresses.\r\n\t *   {*} tldBlacklist The set of domains to consider invalid.\r\n\t *   {*} tldWhitelist The set of domains to consider valid.\r\n\t *   {*} minDomainAtoms The minimum number of domain atoms which must be present\r\n\t *     for the address to be valid.\r\n\t * @param {function(number|boolean)} callback The (optional) callback handler.\r\n\t * @return {*}\r\n\t */\n\t\n\texports.validate = internals.validate = function (email, options, callback) {\n\t\n\t    options = options || {};\n\t\n\t    if (typeof options === 'function') {\n\t        callback = options;\n\t        options = {};\n\t    }\n\t\n\t    if (typeof callback !== 'function') {\n\t        if (options.checkDNS) {\n\t            throw new TypeError('expected callback function for checkDNS option');\n\t        }\n\t\n\t        callback = null;\n\t    }\n\t\n\t    var diagnose = undefined;\n\t    var threshold = undefined;\n\t\n\t    if (typeof options.errorLevel === 'number') {\n\t        diagnose = true;\n\t        threshold = options.errorLevel;\n\t    } else {\n\t        diagnose = !!options.errorLevel;\n\t        threshold = internals.diagnoses.valid;\n\t    }\n\t\n\t    if (options.tldWhitelist) {\n\t        if (typeof options.tldWhitelist === 'string') {\n\t            options.tldWhitelist = [options.tldWhitelist];\n\t        } else if (typeof options.tldWhitelist !== 'object') {\n\t            throw new TypeError('expected array or object tldWhitelist');\n\t        }\n\t    }\n\t\n\t    if (options.tldBlacklist) {\n\t        if (typeof options.tldBlacklist === 'string') {\n\t            options.tldBlacklist = [options.tldBlacklist];\n\t        } else if (typeof options.tldBlacklist !== 'object') {\n\t            throw new TypeError('expected array or object tldBlacklist');\n\t        }\n\t    }\n\t\n\t    if (options.minDomainAtoms && (options.minDomainAtoms !== (+options.minDomainAtoms | 0) || options.minDomainAtoms < 0)) {\n\t        throw new TypeError('expected positive integer minDomainAtoms');\n\t    }\n\t\n\t    var maxResult = internals.diagnoses.valid;\n\t    var updateResult = function updateResult(value) {\n\t\n\t        if (value > maxResult) {\n\t            maxResult = value;\n\t        }\n\t    };\n\t\n\t    var context = {\n\t        now: internals.components.localpart,\n\t        prev: internals.components.localpart,\n\t        stack: [internals.components.localpart]\n\t    };\n\t\n\t    var prevToken = '';\n\t\n\t    var parseData = {\n\t        local: '',\n\t        domain: ''\n\t    };\n\t    var atomData = {\n\t        locals: [''],\n\t        domains: ['']\n\t    };\n\t\n\t    var elementCount = 0;\n\t    var elementLength = 0;\n\t    var crlfCount = 0;\n\t    var charCode = undefined;\n\t\n\t    var hyphenFlag = false;\n\t    var assertEnd = false;\n\t\n\t    var emailLength = email.length;\n\t\n\t    var token = undefined; // Token is used outside the loop, must declare similarly\n\t    for (var i = 0; i < emailLength; ++i) {\n\t        token = email[i];\n\t\n\t        switch (context.now) {\n\t            // Local-part\n\t            case internals.components.localpart:\n\t                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n\t                //   local-part      =   dot-atom / quoted-string / obs-local-part\n\t                //\n\t                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n\t                //\n\t                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n\t                //\n\t                //   quoted-string   =   [CFWS]\n\t                //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n\t                //                       [CFWS]\n\t                //\n\t                //   obs-local-part  =   word *(\".\" word)\n\t                //\n\t                //   word            =   atom / quoted-string\n\t                //\n\t                //   atom            =   [CFWS] 1*atext [CFWS]\n\t                switch (token) {\n\t                    // Comment\n\t                    case '(':\n\t                        if (elementLength === 0) {\n\t                            // Comments are OK at the beginning of an element\n\t                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\n\t                        } else {\n\t                            updateResult(internals.diagnoses.cfwsComment);\n\t                            // Cannot start a comment in an element, should be end\n\t                            assertEnd = true;\n\t                        }\n\t\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextComment;\n\t                        break;\n\t\n\t                    // Next dot-atom element\n\t                    case '.':\n\t                        if (elementLength === 0) {\n\t                            // Another dot, already?\n\t                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n\t                        } else {\n\t                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n\t                            if (assertEnd) {\n\t                                updateResult(internals.diagnoses.deprecatedLocalPart);\n\t                            }\n\t\n\t                            // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\n\t                            assertEnd = false;\n\t                            elementLength = 0;\n\t                            ++elementCount;\n\t                            parseData.local += token;\n\t                            atomData.locals[elementCount] = '';\n\t                        }\n\t\n\t                        break;\n\t\n\t                    // Quoted string\n\t                    case '\"':\n\t                        if (elementLength === 0) {\n\t                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n\t                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\n\t\n\t                            parseData.local += token;\n\t                            atomData.locals[elementCount] += token;\n\t                            ++elementLength;\n\t\n\t                            // Quoted string must be the entire element\n\t                            assertEnd = true;\n\t                            context.stack.push(context.now);\n\t                            context.now = internals.components.contextQuotedString;\n\t                        } else {\n\t                            updateResult(internals.diagnoses.errExpectingATEXT);\n\t                        }\n\t\n\t                        break;\n\t\n\t                    // Folding white space\n\t                    case '\\r':\n\t                        if (emailLength === ++i || email[i] !== '\\n') {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errCRNoLF);\n\t                            break;\n\t                        }\n\t\n\t                    // Fallthrough\n\t\n\t                    case ' ':\n\t                    case '\\t':\n\t                        if (elementLength === 0) {\n\t                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\n\t                        } else {\n\t                            // We can't start FWS in the middle of an element, better be end\n\t                            assertEnd = true;\n\t                        }\n\t\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextFWS;\n\t                        prevToken = token;\n\t                        break;\n\t\n\t                    case '@':\n\t                        // At this point we should have a valid local-part\n\t                        // $lab:coverage:off$\n\t                        if (context.stack.length !== 1) {\n\t                            throw new Error('unexpected item on context stack');\n\t                        }\n\t                        // $lab:coverage:on$\n\t\n\t                        if (parseData.local.length === 0) {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errNoLocalPart);\n\t                        } else if (elementLength === 0) {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errDotEnd);\n\t                        }\n\t                        // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\n\t                        //    octets\n\t                        else if (parseData.local.length > 64) {\n\t                                updateResult(internals.diagnoses.rfc5322LocalTooLong);\n\t                            }\n\t                            // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\n\t                            //    addr-spec\n\t                            //\n\t                            // http://tools.ietf.org/html/rfc2119\n\t                            // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\n\t                            //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\n\t                            //    and the case carefully weighed before implementing any behavior described with this label.\n\t                            else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\n\t                                    updateResult(internals.diagnoses.deprecatedCFWSNearAt);\n\t                                }\n\t\n\t                        // Clear everything down for the domain parsing\n\t                        context.now = internals.components.domain;\n\t                        context.stack[0] = internals.components.domain;\n\t                        elementCount = 0;\n\t                        elementLength = 0;\n\t                        assertEnd = false; // CFWS can only appear at the end of the element\n\t                        break;\n\t\n\t                    // ATEXT\n\t                    default:\n\t                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n\t                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n\t                        //            \"!\" / \"#\" /     ;  characters not including\n\t                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n\t                        //            \"&\" / \"'\" /\n\t                        //            \"*\" / \"+\" /\n\t                        //            \"-\" / \"/\" /\n\t                        //            \"=\" / \"?\" /\n\t                        //            \"^\" / \"_\" /\n\t                        //            \"`\" / \"{\" /\n\t                        //            \"|\" / \"}\" /\n\t                        //            \"~\"\n\t                        if (assertEnd) {\n\t                            // We have encountered atext where it is no longer valid\n\t                            switch (context.prev) {\n\t                                case internals.components.contextComment:\n\t                                case internals.components.contextFWS:\n\t                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n\t                                    break;\n\t\n\t                                case internals.components.contextQuotedString:\n\t                                    updateResult(internals.diagnoses.errATEXTAfterQS);\n\t                                    break;\n\t\n\t                                // $lab:coverage:off$\n\t                                default:\n\t                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n\t                                // $lab:coverage:on$\n\t                            }\n\t                        } else {\n\t                                context.prev = context.now;\n\t                                charCode = token.charCodeAt(0);\n\t\n\t                                // Especially if charCode == 10\n\t                                if (charCode < 33 || charCode > 126 || internals.specials(charCode)) {\n\t\n\t                                    // Fatal error\n\t                                    updateResult(internals.diagnoses.errExpectingATEXT);\n\t                                }\n\t\n\t                                parseData.local += token;\n\t                                atomData.locals[elementCount] += token;\n\t                                ++elementLength;\n\t                            }\n\t                }\n\t\n\t                break;\n\t\n\t            case internals.components.domain:\n\t                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n\t                //   domain          =   dot-atom / domain-literal / obs-domain\n\t                //\n\t                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n\t                //\n\t                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n\t                //\n\t                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n\t                //\n\t                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n\t                //                       %d94-126 /         ;  characters not including\n\t                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n\t                //\n\t                //   obs-domain      =   atom *(\".\" atom)\n\t                //\n\t                //   atom            =   [CFWS] 1*atext [CFWS]\n\t\n\t                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n\t                //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\n\t                //\n\t                //   Domain         = sub-domain *(\".\" sub-domain)\n\t                //\n\t                //   address-literal  = \"[\" ( IPv4-address-literal /\n\t                //                    IPv6-address-literal /\n\t                //                    General-address-literal ) \"]\"\n\t                //                    ; See Section 4.1.3\n\t\n\t                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n\t                //      Note: A liberal syntax for the domain portion of addr-spec is\n\t                //      given here.  However, the domain portion contains addressing\n\t                //      information specified by and used in other protocols (e.g.,\n\t                //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\n\t                //      incumbent upon implementations to conform to the syntax of\n\t                //      addresses for the context in which they are used.\n\t                //\n\t                // is_email() author's note: it's not clear how to interpret this in\n\t                // he context of a general email address validator. The conclusion I\n\t                // have reached is this: \"addressing information\" must comply with\n\t                // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\n\t                // invisible\" must comply only with RFC 5322.\n\t                switch (token) {\n\t                    // Comment\n\t                    case '(':\n\t                        if (elementLength === 0) {\n\t                            // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\n\t                            // http://tools.ietf.org/html/rfc5322#section-3.4.1\n\t                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\n\t                        } else {\n\t                            // We can't start a comment mid-element, better be at the end\n\t                            assertEnd = true;\n\t                            updateResult(internals.diagnoses.cfwsComment);\n\t                        }\n\t\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextComment;\n\t                        break;\n\t\n\t                    // Next dot-atom element\n\t                    case '.':\n\t                        if (elementLength === 0) {\n\t                            // Another dot, already? Fatal error.\n\t                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n\t                        } else if (hyphenFlag) {\n\t                            // Previous subdomain ended in a hyphen. Fatal error.\n\t                            updateResult(internals.diagnoses.errDomainHyphenEnd);\n\t                        } else if (elementLength > 63) {\n\t                            // Nowhere in RFC 5321 does it say explicitly that the domain part of a Mailbox must be a valid domain according to the\n\t                            // DNS standards set out in RFC 1035, but this *is* implied in several places. For instance, wherever the idea of host\n\t                            // routing is discussed the RFC says that the domain must be looked up in the DNS. This would be nonsense unless the\n\t                            // domain was designed to be a valid DNS domain. Hence we must conclude that the RFC 1035 restriction on label length\n\t                            // also applies to RFC 5321 domains.\n\t                            //\n\t                            // http://tools.ietf.org/html/rfc1035#section-2.3.4\n\t                            // labels          63 octets or less\n\t\n\t                            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n\t                        }\n\t\n\t                        // CFWS is OK again now we're at the beginning of an element (although\n\t                        // it may be obsolete CFWS)\n\t                        assertEnd = false;\n\t                        elementLength = 0;\n\t                        ++elementCount;\n\t                        atomData.domains[elementCount] = '';\n\t                        parseData.domain += token;\n\t\n\t                        break;\n\t\n\t                    // Domain literal\n\t                    case '[':\n\t                        if (parseData.domain.length === 0) {\n\t                            // Domain literal must be the only component\n\t                            assertEnd = true;\n\t                            ++elementLength;\n\t                            context.stack.push(context.now);\n\t                            context.now = internals.components.literal;\n\t                            parseData.domain += token;\n\t                            atomData.domains[elementCount] += token;\n\t                            parseData.literal = '';\n\t                        } else {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errExpectingATEXT);\n\t                        }\n\t\n\t                        break;\n\t\n\t                    // Folding white space\n\t                    case '\\r':\n\t                        if (emailLength === ++i || email[i] !== '\\n') {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errCRNoLF);\n\t                            break;\n\t                        }\n\t\n\t                    // Fallthrough\n\t\n\t                    case ' ':\n\t                    case '\\t':\n\t                        if (elementLength === 0) {\n\t                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\n\t                        } else {\n\t                            // We can't start FWS in the middle of an element, so this better be the end\n\t                            updateResult(internals.diagnoses.cfwsFWS);\n\t                            assertEnd = true;\n\t                        }\n\t\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextFWS;\n\t                        prevToken = token;\n\t                        break;\n\t\n\t                    // This must be ATEXT\n\t                    default:\n\t                        // RFC 5322 allows any atext...\n\t                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n\t                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n\t                        //            \"!\" / \"#\" /     ;  characters not including\n\t                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n\t                        //            \"&\" / \"'\" /\n\t                        //            \"*\" / \"+\" /\n\t                        //            \"-\" / \"/\" /\n\t                        //            \"=\" / \"?\" /\n\t                        //            \"^\" / \"_\" /\n\t                        //            \"`\" / \"{\" /\n\t                        //            \"|\" / \"}\" /\n\t                        //            \"~\"\n\t\n\t                        // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\n\t                        //   (RFCs 1034 & 1123)\n\t                        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n\t                        //   sub-domain     = Let-dig [Ldh-str]\n\t                        //\n\t                        //   Let-dig        = ALPHA / DIGIT\n\t                        //\n\t                        //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\n\t                        //\n\t                        if (assertEnd) {\n\t                            // We have encountered ATEXT where it is no longer valid\n\t                            switch (context.prev) {\n\t                                case internals.components.contextComment:\n\t                                case internals.components.contextFWS:\n\t                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n\t                                    break;\n\t\n\t                                case internals.components.literal:\n\t                                    updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\n\t                                    break;\n\t\n\t                                // $lab:coverage:off$\n\t                                default:\n\t                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n\t                                // $lab:coverage:on$\n\t                            }\n\t                        }\n\t\n\t                        charCode = token.charCodeAt(0);\n\t                        // Assume this token isn't a hyphen unless we discover it is\n\t                        hyphenFlag = false;\n\t\n\t                        if (charCode < 33 || charCode > 126 || internals.specials(charCode)) {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errExpectingATEXT);\n\t                        } else if (token === '-') {\n\t                            if (elementLength === 0) {\n\t                                // Hyphens cannot be at the beginning of a subdomain, fatal error\n\t                                updateResult(internals.diagnoses.errDomainHyphenStart);\n\t                            }\n\t\n\t                            hyphenFlag = true;\n\t                        }\n\t                        // Check if it's a neither a number nor a latin letter\n\t                        else if (charCode < 48 || charCode > 122 || charCode > 57 && charCode < 65 || charCode > 90 && charCode < 97) {\n\t                                // This is not an RFC 5321 subdomain, but still OK by RFC 5322\n\t                                updateResult(internals.diagnoses.rfc5322Domain);\n\t                            }\n\t\n\t                        parseData.domain += token;\n\t                        atomData.domains[elementCount] += token;\n\t                        ++elementLength;\n\t                }\n\t\n\t                break;\n\t\n\t            // Domain literal\n\t            case internals.components.literal:\n\t                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n\t                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n\t                //\n\t                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n\t                //                       %d94-126 /         ;  characters not including\n\t                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n\t                //\n\t                //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\n\t                switch (token) {\n\t                    // End of domain literal\n\t                    case ']':\n\t                        if (maxResult < internals.categories.deprecated) {\n\t                            // Could be a valid RFC 5321 address literal, so let's check\n\t\n\t                            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n\t                            //   address-literal  = \"[\" ( IPv4-address-literal /\n\t                            //                    IPv6-address-literal /\n\t                            //                    General-address-literal ) \"]\"\n\t                            //                    ; See Section 4.1.3\n\t                            //\n\t                            // http://tools.ietf.org/html/rfc5321#section-4.1.3\n\t                            //   IPv4-address-literal  = Snum 3(\".\"  Snum)\n\t                            //\n\t                            //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\n\t                            //\n\t                            //   General-address-literal  = Standardized-tag \":\" 1*dcontent\n\t                            //\n\t                            //   Standardized-tag  = Ldh-str\n\t                            //                     ; Standardized-tag MUST be specified in a\n\t                            //                     ; Standards-Track RFC and registered with IANA\n\t                            //\n\t                            //   dcontent      = %d33-90 / ; Printable US-ASCII\n\t                            //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\n\t                            //\n\t                            //   Snum          = 1*3DIGIT\n\t                            //                 ; representing a decimal integer\n\t                            //                 ; value in the range 0 through 255\n\t                            //\n\t                            //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\n\t                            //\n\t                            //   IPv6-hex      = 1*4HEXDIG\n\t                            //\n\t                            //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\n\t                            //\n\t                            //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\n\t                            //                 [IPv6-hex *5(\":\" IPv6-hex)]\n\t                            //                 ; The \"::\" represents at least 2 16-bit groups of\n\t                            //                 ; zeros.  No more than 6 groups in addition to the\n\t                            //                 ; \"::\" may be present.\n\t                            //\n\t                            //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\n\t                            //\n\t                            //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\n\t                            //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\n\t                            //                 IPv4-address-literal\n\t                            //                 ; The \"::\" represents at least 2 16-bit groups of\n\t                            //                 ; zeros.  No more than 4 groups in addition to the\n\t                            //                 ; \"::\" and IPv4-address-literal may be present.\n\t\n\t                            var index = -1;\n\t                            var addressLiteral = parseData.literal;\n\t                            var matchesIP = internals.regex.ipV4.exec(addressLiteral);\n\t\n\t                            // Maybe extract IPv4 part from the end of the address-literal\n\t                            if (matchesIP) {\n\t                                index = matchesIP.index;\n\t                                if (index !== 0) {\n\t                                    // Convert IPv4 part to IPv6 format for futher testing\n\t                                    addressLiteral = addressLiteral.slice(0, index) + '0:0';\n\t                                }\n\t                            }\n\t\n\t                            if (index === 0) {\n\t                                // Nothing there except a valid IPv4 address, so...\n\t                                updateResult(internals.diagnoses.rfc5321AddressLiteral);\n\t                            } else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\n\t                                updateResult(internals.diagnoses.rfc5322DomainLiteral);\n\t                            } else {\n\t                                var match = addressLiteral.slice(5);\n\t                                var maxGroups = internals.maxIPv6Groups;\n\t                                var groups = match.split(':');\n\t                                index = match.indexOf('::');\n\t\n\t                                if (! ~index) {\n\t                                    // Need exactly the right number of groups\n\t                                    if (groups.length !== maxGroups) {\n\t                                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\n\t                                    }\n\t                                } else if (index !== match.lastIndexOf('::')) {\n\t                                    updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\n\t                                } else {\n\t                                    if (index === 0 || index === match.length - 2) {\n\t                                        // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\n\t                                        ++maxGroups;\n\t                                    }\n\t\n\t                                    if (groups.length > maxGroups) {\n\t                                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\n\t                                    } else if (groups.length === maxGroups) {\n\t                                        // Eliding a single \"::\"\n\t                                        updateResult(internals.diagnoses.deprecatedIPv6);\n\t                                    }\n\t                                }\n\t\n\t                                // IPv6 testing strategy\n\t                                if (match[0] === ':' && match[1] !== ':') {\n\t                                    updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\n\t                                } else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\n\t                                    updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\n\t                                } else if (internals.checkIpV6(groups)) {\n\t                                    updateResult(internals.diagnoses.rfc5321AddressLiteral);\n\t                                } else {\n\t                                    updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\n\t                                }\n\t                            }\n\t                        } else {\n\t                            updateResult(internals.diagnoses.rfc5322DomainLiteral);\n\t                        }\n\t\n\t                        parseData.domain += token;\n\t                        atomData.domains[elementCount] += token;\n\t                        ++elementLength;\n\t                        context.prev = context.now;\n\t                        context.now = context.stack.pop();\n\t                        break;\n\t\n\t                    case '\\\\':\n\t                        updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextQuotedPair;\n\t                        break;\n\t\n\t                    // Folding white space\n\t                    case '\\r':\n\t                        if (emailLength === ++i || email[i] !== '\\n') {\n\t                            updateResult(internals.diagnoses.errCRNoLF);\n\t                            break;\n\t                        }\n\t\n\t                    // Fallthrough\n\t\n\t                    case ' ':\n\t                    case '\\t':\n\t                        updateResult(internals.diagnoses.cfwsFWS);\n\t\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextFWS;\n\t                        prevToken = token;\n\t                        break;\n\t\n\t                    // DTEXT\n\t                    default:\n\t                        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n\t                        //   dtext         =   %d33-90 /  ; Printable US-ASCII\n\t                        //                     %d94-126 / ;  characters not including\n\t                        //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\n\t                        //\n\t                        //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\n\t                        //\n\t                        //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\n\t                        //                     %d11 /     ;  characters that do not\n\t                        //                     %d12 /     ;  include the carriage\n\t                        //                     %d14-31 /  ;  return, line feed, and\n\t                        //                     %d127      ;  white space characters\n\t                        charCode = token.charCodeAt(0);\n\t\n\t                        // '\\r', '\\n', ' ', and '\\t' have already been parsed above\n\t                        if (charCode > 127 || charCode === 0 || token === '[') {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errExpectingDTEXT);\n\t                            break;\n\t                        } else if (charCode < 33 || charCode === 127) {\n\t                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n\t                        }\n\t\n\t                        parseData.literal += token;\n\t                        parseData.domain += token;\n\t                        atomData.domains[elementCount] += token;\n\t                        ++elementLength;\n\t                }\n\t\n\t                break;\n\t\n\t            // Quoted string\n\t            case internals.components.contextQuotedString:\n\t                // http://tools.ietf.org/html/rfc5322#section-3.2.4\n\t                //   quoted-string = [CFWS]\n\t                //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n\t                //                   [CFWS]\n\t                //\n\t                //   qcontent      = qtext / quoted-pair\n\t                switch (token) {\n\t                    // Quoted pair\n\t                    case '\\\\':\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextQuotedPair;\n\t                        break;\n\t\n\t                    // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\n\t                    case '\\r':\n\t                        if (emailLength === ++i || email[i] !== '\\n') {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errCRNoLF);\n\t                            break;\n\t                        }\n\t\n\t                    // Fallthrough\n\t\n\t                    case '\\t':\n\t                        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n\t                        //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\n\t                        //   a structured header field are semantically interpreted as a single\n\t                        //   space character.\n\t\n\t                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n\t                        //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\n\t                        //   semantically \"invisible\" and therefore not part of the\n\t                        //   quoted-string\n\t\n\t                        parseData.local += ' ';\n\t                        atomData.locals[elementCount] += ' ';\n\t                        ++elementLength;\n\t\n\t                        updateResult(internals.diagnoses.cfwsFWS);\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextFWS;\n\t                        prevToken = token;\n\t                        break;\n\t\n\t                    // End of quoted string\n\t                    case '\"':\n\t                        parseData.local += token;\n\t                        atomData.locals[elementCount] += token;\n\t                        ++elementLength;\n\t                        context.prev = context.now;\n\t                        context.now = context.stack.pop();\n\t                        break;\n\t\n\t                    // QTEXT\n\t                    default:\n\t                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n\t                        //   qtext          =   %d33 /             ; Printable US-ASCII\n\t                        //                      %d35-91 /          ;  characters not including\n\t                        //                      %d93-126 /         ;  \"\\\" or the quote character\n\t                        //                      obs-qtext\n\t                        //\n\t                        //   obs-qtext      =   obs-NO-WS-CTL\n\t                        //\n\t                        //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\n\t                        //                      %d11 /             ;  characters that do not\n\t                        //                      %d12 /             ;  include the carriage\n\t                        //                      %d14-31 /          ;  return, line feed, and\n\t                        //                      %d127              ;  white space characters\n\t                        charCode = token.charCodeAt(0);\n\t\n\t                        if (charCode > 127 || charCode === 0 || charCode === 10) {\n\t                            updateResult(internals.diagnoses.errExpectingQTEXT);\n\t                        } else if (charCode < 32 || charCode === 127) {\n\t                            updateResult(internals.diagnoses.deprecatedQTEXT);\n\t                        }\n\t\n\t                        parseData.local += token;\n\t                        atomData.locals[elementCount] += token;\n\t                        ++elementLength;\n\t                }\n\t\n\t                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n\t                //   If the string can be represented as a dot-atom (that is, it contains\n\t                //   no characters other than atext characters or \".\" surrounded by atext\n\t                //   characters), then the dot-atom form SHOULD be used and the quoted-\n\t                //   string form SHOULD NOT be used.\n\t\n\t                break;\n\t            // Quoted pair\n\t            case internals.components.contextQuotedPair:\n\t                // http://tools.ietf.org/html/rfc5322#section-3.2.1\n\t                //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\n\t                //\n\t                //   VCHAR           =  %d33-126   ; visible (printing) characters\n\t                //   WSP             =  SP / HTAB  ; white space\n\t                //\n\t                //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\n\t                //\n\t                //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\n\t                //                       %d11 /    ;  characters that do not\n\t                //                       %d12 /    ;  include the carriage\n\t                //                       %d14-31 / ;  return, line feed, and\n\t                //                       %d127     ;  white space characters\n\t                //\n\t                // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\n\t                charCode = token.charCodeAt(0);\n\t\n\t                if (charCode > 127) {\n\t                    // Fatal error\n\t                    updateResult(internals.diagnoses.errExpectingQPair);\n\t                } else if (charCode < 31 && charCode !== 9 || charCode === 127) {\n\t                    // ' ' and '\\t' are allowed\n\t                    updateResult(internals.diagnoses.deprecatedQP);\n\t                }\n\t\n\t                // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\n\t                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n\t                //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\n\t\n\t                context.prev = context.now;\n\t                // End of qpair\n\t                context.now = context.stack.pop();\n\t                token = '\\\\' + token;\n\t\n\t                switch (context.now) {\n\t                    case internals.components.contextComment:\n\t                        break;\n\t\n\t                    case internals.components.contextQuotedString:\n\t                        parseData.local += token;\n\t                        atomData.locals[elementCount] += token;\n\t\n\t                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n\t                        elementLength += 2;\n\t                        break;\n\t\n\t                    case internals.components.literal:\n\t                        parseData.domain += token;\n\t                        atomData.domains[elementCount] += token;\n\t\n\t                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n\t                        elementLength += 2;\n\t                        break;\n\t\n\t                    // $lab:coverage:off$\n\t                    default:\n\t                        throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\n\t                    // $lab:coverage:on$\n\t                }\n\t                break;\n\t\n\t            // Comment\n\t            case internals.components.contextComment:\n\t                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n\t                //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\n\t                //\n\t                //   ccontent = ctext / quoted-pair / comment\n\t                switch (token) {\n\t                    // Nested comment\n\t                    case '(':\n\t                        // Nested comments are ok\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextComment;\n\t                        break;\n\t\n\t                    // End of comment\n\t                    case ')':\n\t                        context.prev = context.now;\n\t                        context.now = context.stack.pop();\n\t                        break;\n\t\n\t                    // Quoted pair\n\t                    case '\\\\':\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextQuotedPair;\n\t                        break;\n\t\n\t                    // Folding white space\n\t                    case '\\r':\n\t                        if (emailLength === ++i || email[i] !== '\\n') {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errCRNoLF);\n\t                            break;\n\t                        }\n\t\n\t                    // Fallthrough\n\t\n\t                    case ' ':\n\t                    case '\\t':\n\t                        updateResult(internals.diagnoses.cfwsFWS);\n\t\n\t                        context.stack.push(context.now);\n\t                        context.now = internals.components.contextFWS;\n\t                        prevToken = token;\n\t                        break;\n\t\n\t                    // CTEXT\n\t                    default:\n\t                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n\t                        //   ctext         = %d33-39 /  ; Printable US-ASCII\n\t                        //                   %d42-91 /  ;  characters not including\n\t                        //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\n\t                        //                   obs-ctext\n\t                        //\n\t                        //   obs-ctext     = obs-NO-WS-CTL\n\t                        //\n\t                        //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\n\t                        //                   %d11 /     ;  characters that do not\n\t                        //                   %d12 /     ;  include the carriage\n\t                        //                   %d14-31 /  ;  return, line feed, and\n\t                        //                   %d127      ;  white space characters\n\t                        charCode = token.charCodeAt(0);\n\t\n\t                        if (charCode > 127 || charCode === 0 || charCode === 10) {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errExpectingCTEXT);\n\t                            break;\n\t                        } else if (charCode < 32 || charCode === 127) {\n\t                            updateResult(internals.diagnoses.deprecatedCTEXT);\n\t                        }\n\t                }\n\t\n\t                break;\n\t\n\t            // Folding white space\n\t            case internals.components.contextFWS:\n\t                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n\t                //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\n\t                //                                   ; Folding white space\n\t\n\t                // But note the erratum:\n\t                // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\n\t                //   In the obsolete syntax, any amount of folding white space MAY be\n\t                //   inserted where the obs-FWS rule is allowed.  This creates the\n\t                //   possibility of having two consecutive \"folds\" in a line, and\n\t                //   therefore the possibility that a line which makes up a folded header\n\t                //   field could be composed entirely of white space.\n\t                //\n\t                //   obs-FWS =   1*([CRLF] WSP)\n\t\n\t                if (prevToken === '\\r') {\n\t                    if (token === '\\r') {\n\t                        // Fatal error\n\t                        updateResult(internals.diagnoses.errFWSCRLFx2);\n\t                        break;\n\t                    }\n\t\n\t                    if (++crlfCount > 1) {\n\t                        // Multiple folds => obsolete FWS\n\t                        updateResult(internals.diagnoses.deprecatedFWS);\n\t                    } else {\n\t                        crlfCount = 1;\n\t                    }\n\t                }\n\t\n\t                switch (token) {\n\t                    case '\\r':\n\t                        if (emailLength === ++i || email[i] !== '\\n') {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errCRNoLF);\n\t                        }\n\t\n\t                        break;\n\t\n\t                    case ' ':\n\t                    case '\\t':\n\t                        break;\n\t\n\t                    default:\n\t                        if (prevToken === '\\r') {\n\t                            // Fatal error\n\t                            updateResult(internals.diagnoses.errFWSCRLFEnd);\n\t                        }\n\t\n\t                        crlfCount = 0;\n\t\n\t                        // End of FWS\n\t                        context.prev = context.now;\n\t                        context.now = context.stack.pop();\n\t\n\t                        // Look at this token again in the parent context\n\t                        --i;\n\t                }\n\t\n\t                prevToken = token;\n\t                break;\n\t\n\t            // Unexpected context\n\t            // $lab:coverage:off$\n\t            default:\n\t                throw new Error('unknown context: ' + context.now);\n\t            // $lab:coverage:on$\n\t        } // Primary state machine\n\t\n\t        if (maxResult > internals.categories.rfc5322) {\n\t            // Fatal error, no point continuing\n\t            break;\n\t        }\n\t    } // Token loop\n\t\n\t    // Check for errors\n\t    if (maxResult < internals.categories.rfc5322) {\n\t        // Fatal errors\n\t        if (context.now === internals.components.contextQuotedString) {\n\t            updateResult(internals.diagnoses.errUnclosedQuotedString);\n\t        } else if (context.now === internals.components.contextQuotedPair) {\n\t            updateResult(internals.diagnoses.errBackslashEnd);\n\t        } else if (context.now === internals.components.contextComment) {\n\t            updateResult(internals.diagnoses.errUnclosedComment);\n\t        } else if (context.now === internals.components.literal) {\n\t            updateResult(internals.diagnoses.errUnclosedDomainLiteral);\n\t        } else if (token === '\\r') {\n\t            updateResult(internals.diagnoses.errFWSCRLFEnd);\n\t        } else if (parseData.domain.length === 0) {\n\t            updateResult(internals.diagnoses.errNoDomain);\n\t        } else if (elementLength === 0) {\n\t            updateResult(internals.diagnoses.errDotEnd);\n\t        } else if (hyphenFlag) {\n\t            updateResult(internals.diagnoses.errDomainHyphenEnd);\n\t        }\n\t\n\t        // Other errors\n\t        else if (parseData.domain.length > 255) {\n\t                // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\n\t                //   The maximum total length of a domain name or number is 255 octets.\n\t                updateResult(internals.diagnoses.rfc5322DomainTooLong);\n\t            } else if (parseData.local.length + parseData.domain.length + /* '@' */1 > 254) {\n\t                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n\t                //   Forward-path   = Path\n\t                //\n\t                //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\n\t                //\n\t                // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n\t                //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\n\t                //\n\t                // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\n\t                // erratum to RFC 3696:\n\t                //\n\t                // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\n\t                //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\n\t                //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\n\t                //   to be 254.\n\t                updateResult(internals.diagnoses.rfc5322TooLong);\n\t            } else if (elementLength > 63) {\n\t                // http://tools.ietf.org/html/rfc1035#section-2.3.4\n\t                // labels   63 octets or less\n\t                updateResult(internals.diagnoses.rfc5322LabelTooLong);\n\t            } else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms) {\n\t                updateResult(internals.diagnoses.errDomainTooShort);\n\t            } else if (options.tldWhitelist || options.tldBlacklist) {\n\t                var tldAtom = atomData.domains[elementCount];\n\t\n\t                if (!internals.validDomain(tldAtom, options)) {\n\t                    updateResult(internals.diagnoses.errUnknownTLD);\n\t                }\n\t            }\n\t    } // Check for errors\n\t\n\t    var dnsPositive = false;\n\t    var finishImmediately = false;\n\t\n\t    var finish = function finish() {\n\t\n\t        if (!dnsPositive && maxResult < internals.categories.dnsWarn) {\n\t            // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\n\t            var code = atomData.domains[elementCount].charCodeAt(0);\n\t            if (code <= 57) {\n\t                updateResult(internals.diagnoses.rfc5321TLDNumeric);\n\t            } else if (elementCount === 0) {\n\t                updateResult(internals.diagnoses.rfc5321TLD);\n\t            }\n\t        }\n\t\n\t        if (maxResult < threshold) {\n\t            maxResult = internals.diagnoses.valid;\n\t        }\n\t\n\t        var finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;\n\t\n\t        if (callback) {\n\t            if (finishImmediately) {\n\t                callback(finishResult);\n\t            } else {\n\t                internals.defer(callback.bind(null, finishResult));\n\t            }\n\t        }\n\t\n\t        return finishResult;\n\t    }; // Finish\n\t\n\t    if (options.checkDNS && maxResult < internals.categories.dnsWarn) {\n\t        (function () {\n\t            // http://tools.ietf.org/html/rfc5321#section-2.3.5\n\t            //   Names that can be resolved to MX RRs or address (i.e., A or AAAA) RRs (as discussed in Section 5) are permitted, as are CNAME RRs whose\n\t            //   targets can be resolved, in turn, to MX or address RRs.\n\t            //\n\t            // http://tools.ietf.org/html/rfc5321#section-5.1\n\t            //   The lookup first attempts to locate an MX record associated with the name.  If a CNAME record is found, the resulting name is processed\n\t            //   as if it were the initial name. ... If an empty list of MXs is returned, the address is treated as if it was associated with an implicit\n\t            //   MX RR, with a preference of 0, pointing to that host.\n\t            //\n\t            // isEmail() author's note: We will regard the existence of a CNAME to be sufficient evidence of the domain's existence. For performance\n\t            // reasons we will not repeat the DNS lookup for the CNAME's target, but we will raise a warning because we didn't immediately find an MX\n\t            // record.\n\t            if (elementCount === 0) {\n\t                // Checking TLD DNS only works if you explicitly check from the root\n\t                parseData.domain += '.';\n\t            }\n\t\n\t            var dnsDomain = parseData.domain;\n\t            Dns.resolveMx(dnsDomain, function (err, mxRecords) {\n\t\n\t                // If we have a fatal error, then we must assume that there are no records\n\t                if (err && err.code !== Dns.NODATA) {\n\t                    updateResult(internals.diagnoses.dnsWarnNoRecord);\n\t                    return finish();\n\t                }\n\t\n\t                if (mxRecords && mxRecords.length) {\n\t                    dnsPositive = true;\n\t                    return finish();\n\t                }\n\t\n\t                var count = 3;\n\t                var done = false;\n\t                updateResult(internals.diagnoses.dnsWarnNoMXRecord);\n\t\n\t                var handleRecords = function handleRecords(err, records) {\n\t\n\t                    if (done) {\n\t                        return;\n\t                    }\n\t\n\t                    --count;\n\t\n\t                    if (records && records.length) {\n\t                        done = true;\n\t                        return finish();\n\t                    }\n\t\n\t                    if (count === 0) {\n\t                        // No usable records for the domain can be found\n\t                        updateResult(internals.diagnoses.dnsWarnNoRecord);\n\t                        done = true;\n\t                        finish();\n\t                    }\n\t                };\n\t\n\t                Dns.resolveCname(dnsDomain, handleRecords);\n\t                Dns.resolve4(dnsDomain, handleRecords);\n\t                Dns.resolve6(dnsDomain, handleRecords);\n\t            });\n\t\n\t            finishImmediately = true;\n\t        })();\n\t    } else {\n\t        var result = finish();\n\t        finishImmediately = true;\n\t        return result;\n\t    } // CheckDNS\n\t};\n\t\n\texports.diagnoses = internals.validate.diagnoses = (function () {\n\t\n\t    var diag = {};\n\t    var keys = Object.keys(internals.diagnoses);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        diag[key] = internals.diagnoses[key];\n\t    }\n\t\n\t    return diag;\n\t})();\n\n/***/ },\n/* 23 */\n/*!***************************!*\\\n  !*** ./lib/string/uri.js ***!\n  \\***************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load Modules\n\t\n\tvar RFC3986 = __webpack_require__(/*! ./rfc3986 */ 24);\n\t\n\t// Declare internals\n\t\n\tvar internals = {\n\t    Uri: {\n\t        createUriRegex: function createUriRegex(optionalScheme) {\n\t\n\t            var scheme = RFC3986.scheme;\n\t\n\t            // If we were passed a scheme, use it instead of the generic one\n\t            if (optionalScheme) {\n\t\n\t                // Have to put this in a non-capturing group to handle the OR statements\n\t                scheme = '(?:' + optionalScheme + ')';\n\t            }\n\t\n\t            /**\n\t             * URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n\t             */\n\t            return new RegExp('^' + scheme + ':' + RFC3986.hierPart + '(?:\\\\?' + RFC3986.query + ')?' + '(?:#' + RFC3986.fragment + ')?$');\n\t        }\n\t    }\n\t};\n\t\n\tmodule.exports = internals.Uri;\n\n/***/ },\n/* 24 */\n/*!*******************************!*\\\n  !*** ./lib/string/rfc3986.js ***!\n  \\*******************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\t// Delcare internals\n\t\n\tvar internals = {\n\t  rfc3986: {}\n\t};\n\t\n\tinternals.generate = function () {\n\t\n\t  /**\n\t   * elements separated by forward slash (\"/\") are alternatives.\n\t   */\n\t  var or = '|';\n\t\n\t  /**\n\t   * DIGIT = %x30-39 ; 0-9\n\t   */\n\t  var digit = '0-9';\n\t  var digitOnly = '[' + digit + ']';\n\t\n\t  /**\n\t   * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z\n\t   */\n\t  var alpha = 'a-zA-Z';\n\t  var alphaOnly = '[' + alpha + ']';\n\t\n\t  /**\n\t   * cidr       = DIGIT                ; 0-9\n\t   *            / %x31-32 DIGIT         ; 10-29\n\t   *            / \"3\" %x30-32           ; 30-32\n\t   */\n\t  internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';\n\t\n\t  /**\n\t   * HEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n\t   */\n\t  var hexDigit = digit + 'A-Fa-f';\n\t  var hexDigitOnly = '[' + hexDigit + ']';\n\t\n\t  /**\n\t   * unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\t   */\n\t  var unreserved = alpha + digit + '-\\\\._~';\n\t\n\t  /**\n\t   * sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\t   */\n\t  var subDelims = '!\\\\$&\\'\\\\(\\\\)\\\\*\\\\+,;=';\n\t\n\t  /**\n\t   * pct-encoded = \"%\" HEXDIG HEXDIG\n\t   */\n\t  var pctEncoded = '%' + hexDigit;\n\t\n\t  /**\n\t   * pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n\t   */\n\t  var pchar = unreserved + pctEncoded + subDelims + ':@';\n\t  var pcharOnly = '[' + pchar + ']';\n\t\n\t  /**\n\t   * Rule to support zero-padded addresses.\n\t   */\n\t  var zeroPad = '0?';\n\t\n\t  /**\n\t   * dec-octet   = DIGIT                 ; 0-9\n\t   *            / %x31-39 DIGIT         ; 10-99\n\t   *            / \"1\" 2DIGIT            ; 100-199\n\t   *            / \"2\" %x30-34 DIGIT     ; 200-249\n\t   *            / \"25\" %x30-35          ; 250-255\n\t   */\n\t  var decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';\n\t\n\t  /**\n\t   * IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n\t   */\n\t  internals.rfc3986.IPv4address = '(?:' + decOctect + '\\\\.){3}' + decOctect;\n\t\n\t  /**\n\t   * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal\n\t   * ls32 = ( h16 \":\" h16 ) / IPv4address ; least-significant 32 bits of address\n\t   * IPv6address =                            6( h16 \":\" ) ls32\n\t   *             /                       \"::\" 5( h16 \":\" ) ls32\n\t   *             / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t   *             / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t   *             / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t   *             / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t   *             / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t   *             / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t   *             / [ *6( h16 \":\" ) h16 ] \"::\"\n\t   */\n\t  var h16 = hexDigitOnly + '{1,4}';\n\t  var ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';\n\t  var IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;\n\t  var IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;\n\t  var IPv6FourHex = h16 + '::(?:' + h16 + ':){4}' + ls32;\n\t  var IPv6ThreeHex = '(?:' + h16 + ':){0,1}' + h16 + '::(?:' + h16 + ':){3}' + ls32;\n\t  var IPv6TwoHex = '(?:' + h16 + ':){0,2}' + h16 + '::(?:' + h16 + ':){2}' + ls32;\n\t  var IPv6OneHex = '(?:' + h16 + ':){0,3}' + h16 + '::' + h16 + ':' + ls32;\n\t  var IPv6NoneHex = '(?:' + h16 + ':){0,4}' + h16 + '::' + ls32;\n\t  var IPv6NoneHex2 = '(?:' + h16 + ':){0,5}' + h16 + '::' + h16;\n\t  var IPv6NoneHex3 = '(?:' + h16 + ':){0,6}' + h16 + '::';\n\t  internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';\n\t\n\t  /**\n\t   * IPvFuture = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n\t   */\n\t  internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\\\.[' + unreserved + subDelims + ':]+';\n\t\n\t  /**\n\t   * scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\t   */\n\t  internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\\\.]*';\n\t\n\t  /**\n\t   * userinfo = *( unreserved / pct-encoded / sub-delims / \":\" )\n\t   */\n\t  var userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';\n\t\n\t  /**\n\t   * IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n\t   */\n\t  var IPLiteral = '\\\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\\\]';\n\t\n\t  /**\n\t   * reg-name = *( unreserved / pct-encoded / sub-delims )\n\t   */\n\t  var regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';\n\t\n\t  /**\n\t   * host = IP-literal / IPv4address / reg-name\n\t   */\n\t  var host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';\n\t\n\t  /**\n\t   * port = *DIGIT\n\t   */\n\t  var port = digitOnly + '*';\n\t\n\t  /**\n\t   * authority   = [ userinfo \"@\" ] host [ \":\" port ]\n\t   */\n\t  var authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';\n\t\n\t  /**\n\t   * segment       = *pchar\n\t   * segment-nz    = 1*pchar\n\t   * path          = path-abempty    ; begins with \"/\" or is empty\n\t   *               / path-absolute   ; begins with \"/\" but not \"//\"\n\t   *               / path-noscheme   ; begins with a non-colon segment\n\t   *               / path-rootless   ; begins with a segment\n\t   *               / path-empty      ; zero characters\n\t   * path-abempty  = *( \"/\" segment )\n\t   * path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n\t   * path-rootless = segment-nz *( \"/\" segment )\n\t   */\n\t  var segment = pcharOnly + '*';\n\t  var segmentNz = pcharOnly + '+';\n\t  var pathAbEmpty = '(?:\\\\/' + segment + ')*';\n\t  var pathAbsolute = '\\\\/(?:' + segmentNz + pathAbEmpty + ')?';\n\t  var pathRootless = segmentNz + pathAbEmpty;\n\t\n\t  /**\n\t   * hier-part = \"//\" authority path\n\t   */\n\t  internals.rfc3986.hierPart = '(?:\\\\/\\\\/' + authority + pathAbEmpty + or + pathAbsolute + or + pathRootless + ')';\n\t\n\t  /**\n\t   * query = *( pchar / \"/\" / \"?\" )\n\t   */\n\t  internals.rfc3986.query = '[' + pchar + '\\\\/\\\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.\n\t\n\t  /**\n\t   * fragment = *( pchar / \"/\" / \"?\" )\n\t   */\n\t  internals.rfc3986.fragment = '[' + pchar + '\\\\/\\\\?]*';\n\t};\n\t\n\tinternals.generate();\n\t\n\tmodule.exports = internals.rfc3986;\n\n/***/ },\n/* 25 */\n/*!**************************!*\\\n  !*** ./lib/string/ip.js ***!\n  \\**************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar RFC3986 = __webpack_require__(/*! ./rfc3986 */ 24);\n\t\n\t// Declare internals\n\t\n\tvar internals = {\n\t    Ip: {\n\t        cidrs: {\n\t            required: '\\\\/(?:' + RFC3986.cidr + ')',\n\t            optional: '(?:\\\\/(?:' + RFC3986.cidr + '))?',\n\t            forbidden: ''\n\t        },\n\t        versions: {\n\t            ipv4: RFC3986.IPv4address,\n\t            ipv6: RFC3986.IPv6address,\n\t            ipvfuture: RFC3986.IPvFuture\n\t        }\n\t    }\n\t};\n\t\n\tinternals.Ip.createIpRegex = function (versions, cidr) {\n\t\n\t    var regex = undefined;\n\t    for (var i = 0; i < versions.length; ++i) {\n\t        var version = versions[i];\n\t        if (!regex) {\n\t            regex = '^(?:' + internals.Ip.versions[version];\n\t        }\n\t        regex = regex + '|' + internals.Ip.versions[version];\n\t    }\n\t\n\t    return new RegExp(regex + ')' + internals.Ip.cidrs[cidr] + '$');\n\t};\n\t\n\tmodule.exports = internals.Ip;\n\n/***/ },\n/* 26 */\n/*!***********************!*\\\n  !*** ./lib/number.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Ref = __webpack_require__(/*! ./ref */ 12);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.Number = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'number';\n\t    this._invalids.add(Infinity);\n\t    this._invalids.add(-Infinity);\n\t};\n\t\n\tHoek.inherits(internals.Number, Any);\n\t\n\tinternals.compare = function (type, compare) {\n\t\n\t    return function (limit) {\n\t\n\t        var isRef = Ref.isRef(limit);\n\t        var isNumber = typeof limit === 'number' && !isNaN(limit);\n\t\n\t        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');\n\t\n\t        return this._test(type, limit, function (value, state, options) {\n\t\n\t            var compareTo = undefined;\n\t            if (isRef) {\n\t                compareTo = limit(state.parent, options);\n\t\n\t                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {\n\t                    return Errors.create('number.ref', { ref: limit.key }, state, options);\n\t                }\n\t            } else {\n\t                compareTo = limit;\n\t            }\n\t\n\t            if (compare(value, compareTo)) {\n\t                return null;\n\t            }\n\t\n\t            return Errors.create('number.' + type, { limit: compareTo, value: value }, state, options);\n\t        });\n\t    };\n\t};\n\t\n\tinternals.Number.prototype._base = function (value, state, options) {\n\t\n\t    var result = {\n\t        errors: null,\n\t        value: value\n\t    };\n\t\n\t    if (typeof value === 'string' && options.convert) {\n\t\n\t        var number = parseFloat(value);\n\t        result.value = isNaN(number) || !isFinite(value) ? NaN : number;\n\t    }\n\t\n\t    var isNumber = typeof result.value === 'number' && !isNaN(result.value);\n\t\n\t    if (options.convert && 'precision' in this._flags && isNumber) {\n\t\n\t        // This is conceptually equivalent to using toFixed but it should be much faster\n\t        var precision = Math.pow(10, this._flags.precision);\n\t        result.value = Math.round(result.value * precision) / precision;\n\t    }\n\t\n\t    result.errors = isNumber ? null : Errors.create('number.base', null, state, options);\n\t    return result;\n\t};\n\t\n\tinternals.Number.prototype.min = internals.compare('min', function (value, limit) {\n\t    return value >= limit;\n\t});\n\tinternals.Number.prototype.max = internals.compare('max', function (value, limit) {\n\t    return value <= limit;\n\t});\n\tinternals.Number.prototype.greater = internals.compare('greater', function (value, limit) {\n\t    return value > limit;\n\t});\n\tinternals.Number.prototype.less = internals.compare('less', function (value, limit) {\n\t    return value < limit;\n\t});\n\t\n\tinternals.Number.prototype.multiple = function (base) {\n\t\n\t    Hoek.assert(Hoek.isInteger(base), 'multiple must be an integer');\n\t    Hoek.assert(base > 0, 'multiple must be greater than 0');\n\t\n\t    return this._test('multiple', base, function (value, state, options) {\n\t\n\t        if (value % base === 0) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('number.multiple', { multiple: base, value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Number.prototype.integer = function () {\n\t\n\t    return this._test('integer', undefined, function (value, state, options) {\n\t\n\t        return Hoek.isInteger(value) ? null : Errors.create('number.integer', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Number.prototype.negative = function () {\n\t\n\t    return this._test('negative', undefined, function (value, state, options) {\n\t\n\t        if (value < 0) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('number.negative', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Number.prototype.positive = function () {\n\t\n\t    return this._test('positive', undefined, function (value, state, options) {\n\t\n\t        if (value > 0) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('number.positive', { value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.precisionRx = /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/;\n\t\n\tinternals.Number.prototype.precision = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');\n\t    Hoek.assert(!('precision' in this._flags), 'precision already set');\n\t\n\t    var obj = this._test('precision', limit, function (value, state, options) {\n\t\n\t        var places = value.toString().match(internals.precisionRx);\n\t        var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n\t        if (decimals <= limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('number.precision', { limit: limit, value: value }, state, options);\n\t    });\n\t\n\t    obj._flags.precision = limit;\n\t    return obj;\n\t};\n\t\n\tmodule.exports = new internals.Number();\n\n/***/ },\n/* 27 */\n/*!************************!*\\\n  !*** ./lib/boolean.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.Boolean = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'boolean';\n\t};\n\t\n\tHoek.inherits(internals.Boolean, Any);\n\t\n\tinternals.Boolean.prototype._base = function (value, state, options) {\n\t\n\t    var result = {\n\t        value: value\n\t    };\n\t\n\t    if (typeof value === 'string' && options.convert) {\n\t\n\t        var lower = value.toLowerCase();\n\t        result.value = lower === 'true' || lower === 'yes' || lower === 'on' ? true : lower === 'false' || lower === 'no' || lower === 'off' ? false : value;\n\t    }\n\t\n\t    result.errors = typeof result.value === 'boolean' ? null : Errors.create('boolean.base', null, state, options);\n\t    return result;\n\t};\n\t\n\tmodule.exports = new internals.Boolean();\n\n/***/ },\n/* 28 */\n/*!*****************************!*\\\n  !*** ./lib/alternatives.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Cast = __webpack_require__(/*! ./cast */ 15);\n\tvar Ref = __webpack_require__(/*! ./ref */ 12);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.Alternatives = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'alternatives';\n\t    this._invalids.remove(null);\n\t\n\t    this._inner.matches = [];\n\t};\n\t\n\tHoek.inherits(internals.Alternatives, Any);\n\t\n\tinternals.Alternatives.prototype._base = function (value, state, options) {\n\t\n\t    var errors = [];\n\t    for (var i = 0; i < this._inner.matches.length; ++i) {\n\t        var item = this._inner.matches[i];\n\t        var schema = item.schema;\n\t        if (!schema) {\n\t            var failed = item.is._validate(item.ref(state.parent, options), null, options, state.parent).errors;\n\t            schema = failed ? item.otherwise : item.then;\n\t            if (!schema) {\n\t                continue;\n\t            }\n\t        }\n\t\n\t        var result = schema._validate(value, state, options);\n\t        if (!result.errors) {\n\t            // Found a valid match\n\t            return result;\n\t        }\n\t\n\t        errors = errors.concat(result.errors);\n\t    }\n\t\n\t    return { errors: errors.length ? errors : Errors.create('alternatives.base', null, state, options) };\n\t};\n\t\n\tinternals.Alternatives.prototype['try'] = function () /* schemas */{\n\t\n\t    var schemas = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n\t\n\t    var obj = this.clone();\n\t\n\t    for (var i = 0; i < schemas.length; ++i) {\n\t        var cast = Cast.schema(schemas[i]);\n\t        if (cast._refs.length) {\n\t            obj._refs = obj._refs.concat(cast._refs);\n\t        }\n\t        obj._inner.matches.push({ schema: cast });\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Alternatives.prototype.when = function (ref, options) {\n\t\n\t    Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);\n\t    Hoek.assert(options, 'Missing options');\n\t    Hoek.assert(typeof options === 'object', 'Invalid options');\n\t    Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n\t    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\t\n\t    var obj = this.clone();\n\t    var is = Cast.schema(options.is);\n\t\n\t    if (options.is === null || !options.is.isJoi) {\n\t\n\t        // Only apply required if this wasn't already a schema, we'll suppose people know what they're doing\n\t        is = is.required();\n\t    }\n\t\n\t    var item = {\n\t        ref: Cast.ref(ref),\n\t        is: is,\n\t        then: options.then !== undefined ? Cast.schema(options.then) : undefined,\n\t        otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined\n\t    };\n\t\n\t    Ref.push(obj._refs, item.ref);\n\t    obj._refs = obj._refs.concat(item.is._refs);\n\t\n\t    if (item.then && item.then._refs) {\n\t        obj._refs = obj._refs.concat(item.then._refs);\n\t    }\n\t\n\t    if (item.otherwise && item.otherwise._refs) {\n\t        obj._refs = obj._refs.concat(item.otherwise._refs);\n\t    }\n\t\n\t    obj._inner.matches.push(item);\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Alternatives.prototype.describe = function () {\n\t\n\t    var description = Any.prototype.describe.call(this);\n\t    var alternatives = [];\n\t    for (var i = 0; i < this._inner.matches.length; ++i) {\n\t        var item = this._inner.matches[i];\n\t        if (item.schema) {\n\t\n\t            // try()\n\t\n\t            alternatives.push(item.schema.describe());\n\t        } else {\n\t\n\t            // when()\n\t\n\t            var when = {\n\t                ref: item.ref.toString(),\n\t                is: item.is.describe()\n\t            };\n\t\n\t            if (item.then) {\n\t                when.then = item.then.describe();\n\t            }\n\t\n\t            if (item.otherwise) {\n\t                when.otherwise = item.otherwise.describe();\n\t            }\n\t\n\t            alternatives.push(when);\n\t        }\n\t    }\n\t\n\t    description.alternatives = alternatives;\n\t    return description;\n\t};\n\t\n\tmodule.exports = new internals.Alternatives();\n\n/***/ },\n/* 29 */\n/*!***********************!*\\\n  !*** ./lib/object.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\tvar Topo = __webpack_require__(/*! topo */ 30);\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Cast = __webpack_require__(/*! ./cast */ 15);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.Object = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'object';\n\t    this._inner.children = null;\n\t    this._inner.renames = [];\n\t    this._inner.dependencies = [];\n\t    this._inner.patterns = [];\n\t};\n\t\n\tHoek.inherits(internals.Object, Any);\n\t\n\tinternals.Object.prototype._base = function (value, state, options) {\n\t\n\t    var target = value;\n\t    var errors = [];\n\t    var finish = function finish() {\n\t\n\t        return {\n\t            value: target,\n\t            errors: errors.length ? errors : null\n\t        };\n\t    };\n\t\n\t    if (typeof value === 'string' && options.convert) {\n\t\n\t        try {\n\t            value = JSON.parse(value);\n\t        } catch (parseErr) {}\n\t    }\n\t\n\t    var type = this._flags.func ? 'function' : 'object';\n\t    if (!value || typeof value !== type || Array.isArray(value)) {\n\t\n\t        errors.push(Errors.create(type + '.base', null, state, options));\n\t        return finish();\n\t    }\n\t\n\t    // Skip if there are no other rules to test\n\t\n\t    if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n\t    !this._inner.patterns.length) {\n\t\n\t        target = value;\n\t        return finish();\n\t    }\n\t\n\t    // Ensure target is a local copy (parsed) or shallow copy\n\t\n\t    if (target === value) {\n\t        if (type === 'object') {\n\t            target = Object.create(Object.getPrototypeOf(value));\n\t        } else {\n\t            target = function () {\n\t\n\t                return value.apply(this, arguments);\n\t            };\n\t\n\t            target.prototype = Hoek.clone(value.prototype);\n\t        }\n\t\n\t        var valueKeys = Object.keys(value);\n\t        for (var i = 0; i < valueKeys.length; ++i) {\n\t            target[valueKeys[i]] = value[valueKeys[i]];\n\t        }\n\t    } else {\n\t        target = value;\n\t    }\n\t\n\t    // Rename keys\n\t\n\t    var renamed = {};\n\t    for (var i = 0; i < this._inner.renames.length; ++i) {\n\t        var item = this._inner.renames[i];\n\t\n\t        if (item.options.ignoreUndefined && target[item.from] === undefined) {\n\t            continue;\n\t        }\n\t\n\t        if (!item.options.multiple && renamed[item.to]) {\n\t\n\t            errors.push(Errors.create('object.rename.multiple', { from: item.from, to: item.to }, state, options));\n\t            if (options.abortEarly) {\n\t                return finish();\n\t            }\n\t        }\n\t\n\t        if (Object.prototype.hasOwnProperty.call(target, item.to) && !item.options.override && !renamed[item.to]) {\n\t\n\t            errors.push(Errors.create('object.rename.override', { from: item.from, to: item.to }, state, options));\n\t            if (options.abortEarly) {\n\t                return finish();\n\t            }\n\t        }\n\t\n\t        if (target[item.from] === undefined) {\n\t            delete target[item.to];\n\t        } else {\n\t            target[item.to] = target[item.from];\n\t        }\n\t\n\t        renamed[item.to] = true;\n\t\n\t        if (!item.options.alias) {\n\t            delete target[item.from];\n\t        }\n\t    }\n\t\n\t    // Validate schema\n\t\n\t    if (!this._inner.children && // null allows any keys\n\t    !this._inner.patterns.length && !this._inner.dependencies.length) {\n\t\n\t        return finish();\n\t    }\n\t\n\t    var unprocessed = Hoek.mapToObject(Object.keys(target));\n\t\n\t    if (this._inner.children) {\n\t        for (var i = 0; i < this._inner.children.length; ++i) {\n\t            var child = this._inner.children[i];\n\t            var key = child.key;\n\t            var item = target[key];\n\t\n\t            delete unprocessed[key];\n\t\n\t            var localState = { key: key, path: (state.path || '') + (state.path && key ? '.' : '') + key, parent: target, reference: state.reference };\n\t            var result = child.schema._validate(item, localState, options);\n\t            if (result.errors) {\n\t                errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));\n\t\n\t                if (options.abortEarly) {\n\t                    return finish();\n\t                }\n\t            }\n\t\n\t            if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n\t                delete target[key];\n\t            } else if (result.value !== undefined) {\n\t                target[key] = result.value;\n\t            }\n\t        }\n\t    }\n\t\n\t    // Unknown keys\n\t\n\t    var unprocessedKeys = Object.keys(unprocessed);\n\t    if (unprocessedKeys.length && this._inner.patterns.length) {\n\t\n\t        for (var i = 0; i < unprocessedKeys.length; ++i) {\n\t            var key = unprocessedKeys[i];\n\t\n\t            for (var j = 0; j < this._inner.patterns.length; ++j) {\n\t                var pattern = this._inner.patterns[j];\n\t\n\t                if (pattern.regex.test(key)) {\n\t                    delete unprocessed[key];\n\t\n\t                    var item = target[key];\n\t                    var localState = { key: key, path: (state.path ? state.path + '.' : '') + key, parent: target, reference: state.reference };\n\t                    var result = pattern.rule._validate(item, localState, options);\n\t                    if (result.errors) {\n\t                        errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));\n\t\n\t                        if (options.abortEarly) {\n\t                            return finish();\n\t                        }\n\t                    }\n\t\n\t                    if (result.value !== undefined) {\n\t                        target[key] = result.value;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        unprocessedKeys = Object.keys(unprocessed);\n\t    }\n\t\n\t    if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {\n\t        if (options.stripUnknown || options.skipFunctions) {\n\t\n\t            for (var i = 0; i < unprocessedKeys.length; ++i) {\n\t                var key = unprocessedKeys[i];\n\t\n\t                if (options.stripUnknown) {\n\t                    delete target[key];\n\t                    delete unprocessed[key];\n\t                } else if (typeof target[key] === 'function') {\n\t                    delete unprocessed[key];\n\t                }\n\t            }\n\t\n\t            unprocessedKeys = Object.keys(unprocessed);\n\t        }\n\t\n\t        if (unprocessedKeys.length && (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\t\n\t            for (var i = 0; i < unprocessedKeys.length; ++i) {\n\t                errors.push(Errors.create('object.allowUnknown', null, { key: unprocessedKeys[i], path: state.path + (state.path ? '.' : '') + unprocessedKeys[i] }, options));\n\t            }\n\t        }\n\t    }\n\t\n\t    // Validate dependencies\n\t\n\t    for (var i = 0; i < this._inner.dependencies.length; ++i) {\n\t        var dep = this._inner.dependencies[i];\n\t        var err = internals[dep.type](dep.key !== null && value[dep.key], dep.peers, target, { key: dep.key, path: (state.path || '') + (dep.key ? '.' + dep.key : '') }, options);\n\t        if (err) {\n\t            errors.push(err);\n\t            if (options.abortEarly) {\n\t                return finish();\n\t            }\n\t        }\n\t    }\n\t\n\t    return finish();\n\t};\n\t\n\tinternals.Object.prototype._func = function () {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.func = true;\n\t    return obj;\n\t};\n\t\n\tinternals.Object.prototype.keys = function (schema) {\n\t\n\t    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n\t    Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');\n\t\n\t    var obj = this.clone();\n\t\n\t    if (!schema) {\n\t        obj._inner.children = null;\n\t        return obj;\n\t    }\n\t\n\t    var children = Object.keys(schema);\n\t\n\t    if (!children.length) {\n\t        obj._inner.children = [];\n\t        return obj;\n\t    }\n\t\n\t    var topo = new Topo();\n\t    if (obj._inner.children) {\n\t        for (var i = 0; i < obj._inner.children.length; ++i) {\n\t            var child = obj._inner.children[i];\n\t\n\t            // Only add the key if we are not going to replace it later\n\t            if (children.indexOf(child.key) === -1) {\n\t                topo.add(child, { after: child._refs, group: child.key });\n\t            }\n\t        }\n\t    }\n\t\n\t    for (var i = 0; i < children.length; ++i) {\n\t        var key = children[i];\n\t        var child = schema[key];\n\t        try {\n\t            var cast = Cast.schema(child);\n\t            topo.add({ key: key, schema: cast }, { after: cast._refs, group: key });\n\t        } catch (castErr) {\n\t            if (castErr.hasOwnProperty('path')) {\n\t                castErr.path = key + '.' + castErr.path;\n\t            } else {\n\t                castErr.path = key;\n\t            }\n\t            throw castErr;\n\t        }\n\t    }\n\t\n\t    obj._inner.children = topo.nodes;\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Object.prototype.unknown = function (allow) {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.allowUnknown = allow !== false;\n\t    return obj;\n\t};\n\t\n\tinternals.Object.prototype.length = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('length', limit, function (value, state, options) {\n\t\n\t        if (Object.keys(value).length === limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('object.length', { limit: limit }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Object.prototype.min = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('min', limit, function (value, state, options) {\n\t\n\t        if (Object.keys(value).length >= limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('object.min', { limit: limit }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Object.prototype.max = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('max', limit, function (value, state, options) {\n\t\n\t        if (Object.keys(value).length <= limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('object.max', { limit: limit }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Object.prototype.pattern = function (pattern, schema) {\n\t\n\t    Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');\n\t    Hoek.assert(schema !== undefined, 'Invalid rule');\n\t\n\t    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined); // Future version should break this and forbid unsupported regex flags\n\t\n\t    try {\n\t        schema = Cast.schema(schema);\n\t    } catch (castErr) {\n\t        if (castErr.hasOwnProperty('path')) {\n\t            castErr.message = castErr.message + '(' + castErr.path + ')';\n\t        }\n\t\n\t        throw castErr;\n\t    }\n\t\n\t    var obj = this.clone();\n\t    obj._inner.patterns.push({ regex: pattern, rule: schema });\n\t    return obj;\n\t};\n\t\n\tinternals.Object.prototype['with'] = function (key, peers) {\n\t\n\t    return this._dependency('with', key, peers);\n\t};\n\t\n\tinternals.Object.prototype.without = function (key, peers) {\n\t\n\t    return this._dependency('without', key, peers);\n\t};\n\t\n\tinternals.Object.prototype.xor = function () {\n\t\n\t    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    return this._dependency('xor', null, peers);\n\t};\n\t\n\tinternals.Object.prototype.or = function () {\n\t\n\t    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    return this._dependency('or', null, peers);\n\t};\n\t\n\tinternals.Object.prototype.and = function () {\n\t\n\t    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    return this._dependency('and', null, peers);\n\t};\n\t\n\tinternals.Object.prototype.nand = function () {\n\t\n\t    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    return this._dependency('nand', null, peers);\n\t};\n\t\n\tinternals.Object.prototype.requiredKeys = function (children) {\n\t\n\t    children = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    return this.applyFunctionToChildren(children, 'required');\n\t};\n\t\n\tinternals.Object.prototype.optionalKeys = function (children) {\n\t\n\t    children = Hoek.flatten(Array.prototype.slice.call(arguments));\n\t    return this.applyFunctionToChildren(children, 'optional');\n\t};\n\t\n\tinternals.renameDefaults = {\n\t    alias: false, // Keep old value in place\n\t    multiple: false, // Allow renaming multiple keys into the same target\n\t    override: false // Overrides an existing key\n\t};\n\t\n\tinternals.Object.prototype.rename = function (from, to, options) {\n\t\n\t    Hoek.assert(typeof from === 'string', 'Rename missing the from argument');\n\t    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n\t    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\t\n\t    for (var i = 0; i < this._inner.renames.length; ++i) {\n\t        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n\t    }\n\t\n\t    var obj = this.clone();\n\t\n\t    obj._inner.renames.push({\n\t        from: from,\n\t        to: to,\n\t        options: Hoek.applyToDefaults(internals.renameDefaults, options || {})\n\t    });\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.groupChildren = function (children) {\n\t\n\t    children.sort();\n\t\n\t    var grouped = {};\n\t\n\t    for (var i = 0; i < children.length; ++i) {\n\t        var child = children[i];\n\t        Hoek.assert(typeof child === 'string', 'children must be strings');\n\t        var group = child.split('.')[0];\n\t        var childGroup = grouped[group] = grouped[group] || [];\n\t        childGroup.push(child.substring(group.length + 1));\n\t    }\n\t\n\t    return grouped;\n\t};\n\t\n\tinternals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) {\n\t\n\t    children = [].concat(children);\n\t    Hoek.assert(children.length > 0, 'expected at least one children');\n\t\n\t    var groupedChildren = internals.groupChildren(children);\n\t    var obj = undefined;\n\t\n\t    if ('' in groupedChildren) {\n\t        obj = this[fn].apply(this, args);\n\t        delete groupedChildren[''];\n\t    } else {\n\t        obj = this.clone();\n\t    }\n\t\n\t    if (obj._inner.children) {\n\t        root = root ? root + '.' : '';\n\t\n\t        for (var i = 0; i < obj._inner.children.length; ++i) {\n\t            var child = obj._inner.children[i];\n\t            var group = groupedChildren[child.key];\n\t\n\t            if (group) {\n\t                obj._inner.children[i] = {\n\t                    key: child.key,\n\t                    _refs: child._refs,\n\t                    schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n\t                };\n\t\n\t                delete groupedChildren[child.key];\n\t            }\n\t        }\n\t    }\n\t\n\t    var remaining = Object.keys(groupedChildren);\n\t    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Object.prototype._dependency = function (type, key, peers) {\n\t\n\t    peers = [].concat(peers);\n\t    for (var i = 0; i < peers.length; ++i) {\n\t        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n\t    }\n\t\n\t    var obj = this.clone();\n\t    obj._inner.dependencies.push({ type: type, key: key, peers: peers });\n\t    return obj;\n\t};\n\t\n\tinternals['with'] = function (value, peers, parent, state, options) {\n\t\n\t    if (value === undefined) {\n\t        return null;\n\t    }\n\t\n\t    for (var i = 0; i < peers.length; ++i) {\n\t        var peer = peers[i];\n\t        if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n\t\n\t            return Errors.create('object.with', { peer: peer }, state, options);\n\t        }\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\tinternals.without = function (value, peers, parent, state, options) {\n\t\n\t    if (value === undefined) {\n\t        return null;\n\t    }\n\t\n\t    for (var i = 0; i < peers.length; ++i) {\n\t        var peer = peers[i];\n\t        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n\t\n\t            return Errors.create('object.without', { peer: peer }, state, options);\n\t        }\n\t    }\n\t\n\t    return null;\n\t};\n\t\n\tinternals.xor = function (value, peers, parent, state, options) {\n\t\n\t    var present = [];\n\t    for (var i = 0; i < peers.length; ++i) {\n\t        var peer = peers[i];\n\t        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n\t\n\t            present.push(peer);\n\t        }\n\t    }\n\t\n\t    if (present.length === 1) {\n\t        return null;\n\t    }\n\t\n\t    if (present.length === 0) {\n\t        return Errors.create('object.missing', { peers: peers }, state, options);\n\t    }\n\t\n\t    return Errors.create('object.xor', { peers: peers }, state, options);\n\t};\n\t\n\tinternals.or = function (value, peers, parent, state, options) {\n\t\n\t    for (var i = 0; i < peers.length; ++i) {\n\t        var peer = peers[i];\n\t        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n\t            return null;\n\t        }\n\t    }\n\t\n\t    return Errors.create('object.missing', { peers: peers }, state, options);\n\t};\n\t\n\tinternals.and = function (value, peers, parent, state, options) {\n\t\n\t    var missing = [];\n\t    var present = [];\n\t    var count = peers.length;\n\t    for (var i = 0; i < count; ++i) {\n\t        var peer = peers[i];\n\t        if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === undefined) {\n\t\n\t            missing.push(peer);\n\t        } else {\n\t            present.push(peer);\n\t        }\n\t    }\n\t\n\t    var aon = missing.length === count || present.length === count;\n\t    return !aon ? Errors.create('object.and', { present: present, missing: missing }, state, options) : null;\n\t};\n\t\n\tinternals.nand = function (value, peers, parent, state, options) {\n\t\n\t    var present = [];\n\t    for (var i = 0; i < peers.length; ++i) {\n\t        var peer = peers[i];\n\t        if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== undefined) {\n\t\n\t            present.push(peer);\n\t        }\n\t    }\n\t\n\t    var values = Hoek.clone(peers);\n\t    var main = values.splice(0, 1)[0];\n\t    var allPresent = present.length === peers.length;\n\t    return allPresent ? Errors.create('object.nand', { main: main, peers: values }, state, options) : null;\n\t};\n\t\n\tinternals.Object.prototype.describe = function (shallow) {\n\t\n\t    var description = Any.prototype.describe.call(this);\n\t\n\t    if (this._inner.children && !shallow) {\n\t\n\t        description.children = {};\n\t        for (var i = 0; i < this._inner.children.length; ++i) {\n\t            var child = this._inner.children[i];\n\t            description.children[child.key] = child.schema.describe();\n\t        }\n\t    }\n\t\n\t    if (this._inner.dependencies.length) {\n\t        description.dependencies = Hoek.clone(this._inner.dependencies);\n\t    }\n\t\n\t    if (this._inner.patterns.length) {\n\t        description.patterns = [];\n\t\n\t        for (var i = 0; i < this._inner.patterns.length; ++i) {\n\t            var pattern = this._inner.patterns[i];\n\t            description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n\t        }\n\t    }\n\t\n\t    return description;\n\t};\n\t\n\tinternals.Object.prototype.assert = function (ref, schema, message) {\n\t\n\t    ref = Cast.ref(ref);\n\t    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n\t    message = message || 'pass the assertion test';\n\t\n\t    var cast = undefined;\n\t    try {\n\t        cast = Cast.schema(schema);\n\t    } catch (castErr) {\n\t        if (castErr.hasOwnProperty('path')) {\n\t            castErr.message = castErr.message + '(' + castErr.path + ')';\n\t        }\n\t\n\t        throw castErr;\n\t    }\n\t\n\t    var key = ref.path[ref.path.length - 1];\n\t    var path = ref.path.join('.');\n\t\n\t    return this._test('assert', { cast: cast, ref: ref }, function (value, state, options) {\n\t\n\t        var result = cast._validate(ref(value), null, options, value);\n\t        if (!result.errors) {\n\t            return null;\n\t        }\n\t\n\t        var localState = Hoek.merge({}, state);\n\t        localState.key = key;\n\t        localState.path = path;\n\t        return Errors.create('object.assert', { ref: localState.path, message: message }, localState, options);\n\t    });\n\t};\n\t\n\tinternals.Object.prototype.type = function (constructor, name) {\n\t\n\t    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n\t    name = name || constructor.name;\n\t\n\t    return this._test('type', name, function (value, state, options) {\n\t\n\t        if (value instanceof constructor) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('object.type', { type: name }, state, options);\n\t    });\n\t};\n\t\n\tmodule.exports = new internals.Object();\n\n/***/ },\n/* 30 */\n/*!*****************************!*\\\n  !*** ./~/topo/lib/index.js ***!\n  \\*****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\texports = module.exports = internals.Topo = function () {\n\t\n\t    this._items = [];\n\t    this.nodes = [];\n\t};\n\t\n\tinternals.Topo.prototype.add = function (nodes, options) {\n\t    var _this = this;\n\t\n\t    options = options || {};\n\t\n\t    // Validate rules\n\t\n\t    var before = [].concat(options.before || []);\n\t    var after = [].concat(options.after || []);\n\t    var group = options.group || '?';\n\t    var sort = options.sort || 0; // Used for merging only\n\t\n\t    Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);\n\t    Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');\n\t    Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);\n\t    Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');\n\t\n\t    [].concat(nodes).forEach(function (node, i) {\n\t\n\t        var item = {\n\t            seq: _this._items.length,\n\t            sort: sort,\n\t            before: before,\n\t            after: after,\n\t            group: group,\n\t            node: node\n\t        };\n\t\n\t        _this._items.push(item);\n\t    });\n\t\n\t    // Insert event\n\t\n\t    var error = this._sort();\n\t    Hoek.assert(!error, 'item', group !== '?' ? 'added into group ' + group : '', 'created a dependencies error');\n\t\n\t    return this.nodes;\n\t};\n\t\n\tinternals.Topo.prototype.merge = function (others) {\n\t\n\t    others = [].concat(others);\n\t    for (var i = 0; i < others.length; ++i) {\n\t        var other = others[i];\n\t        if (other) {\n\t            for (var j = 0; j < other._items.length; ++j) {\n\t                var item = Hoek.shallow(other._items[j]);\n\t                this._items.push(item);\n\t            }\n\t        }\n\t    }\n\t\n\t    // Sort items\n\t\n\t    this._items.sort(internals.mergeSort);\n\t    for (var i = 0; i < this._items.length; ++i) {\n\t        this._items[i].seq = i;\n\t    }\n\t\n\t    var error = this._sort();\n\t    Hoek.assert(!error, 'merge created a dependencies error');\n\t\n\t    return this.nodes;\n\t};\n\t\n\tinternals.mergeSort = function (a, b) {\n\t\n\t    return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n\t};\n\t\n\tinternals.Topo.prototype._sort = function () {\n\t\n\t    // Construct graph\n\t\n\t    var groups = {};\n\t    var graph = {};\n\t    var graphAfters = {};\n\t\n\t    for (var i = 0; i < this._items.length; ++i) {\n\t        var item = this._items[i];\n\t        var seq = item.seq; // Unique across all items\n\t        var group = item.group;\n\t\n\t        // Determine Groups\n\t\n\t        groups[group] = groups[group] || [];\n\t        groups[group].push(seq);\n\t\n\t        // Build intermediary graph using 'before'\n\t\n\t        graph[seq] = item.before;\n\t\n\t        // Build second intermediary graph with 'after'\n\t\n\t        var after = item.after;\n\t        for (var j = 0; j < after.length; ++j) {\n\t            graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n\t        }\n\t    }\n\t\n\t    // Expand intermediary graph\n\t\n\t    var graphNodes = Object.keys(graph);\n\t    for (var i = 0; i < graphNodes.length; ++i) {\n\t        var node = graphNodes[i];\n\t        var expandedGroups = [];\n\t\n\t        var graphNodeItems = Object.keys(graph[node]);\n\t        for (var j = 0; j < graphNodeItems.length; ++j) {\n\t            var group = graph[node][graphNodeItems[j]];\n\t            groups[group] = groups[group] || [];\n\t\n\t            for (var k = 0; k < groups[group].length; ++k) {\n\t\n\t                expandedGroups.push(groups[group][k]);\n\t            }\n\t        }\n\t        graph[node] = expandedGroups;\n\t    }\n\t\n\t    // Merge intermediary graph using graphAfters into final graph\n\t\n\t    var afterNodes = Object.keys(graphAfters);\n\t    for (var i = 0; i < afterNodes.length; ++i) {\n\t        var group = afterNodes[i];\n\t\n\t        if (groups[group]) {\n\t            for (var j = 0; j < groups[group].length; ++j) {\n\t                var node = groups[group][j];\n\t                graph[node] = graph[node].concat(graphAfters[group]);\n\t            }\n\t        }\n\t    }\n\t\n\t    // Compile ancestors\n\t\n\t    var children = undefined;\n\t    var ancestors = {};\n\t    graphNodes = Object.keys(graph);\n\t    for (var i = 0; i < graphNodes.length; ++i) {\n\t        var node = graphNodes[i];\n\t        children = graph[node];\n\t\n\t        for (var j = 0; j < children.length; ++j) {\n\t            ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n\t        }\n\t    }\n\t\n\t    // Topo sort\n\t\n\t    var visited = {};\n\t    var sorted = [];\n\t\n\t    for (var i = 0; i < this._items.length; ++i) {\n\t        var next = i;\n\t\n\t        if (ancestors[i]) {\n\t            next = null;\n\t            for (var j = 0; j < this._items.length; ++j) {\n\t                if (visited[j] === true) {\n\t                    continue;\n\t                }\n\t\n\t                if (!ancestors[j]) {\n\t                    ancestors[j] = [];\n\t                }\n\t\n\t                var shouldSeeCount = ancestors[j].length;\n\t                var seenCount = 0;\n\t                for (var k = 0; k < shouldSeeCount; ++k) {\n\t                    if (sorted.indexOf(ancestors[j][k]) >= 0) {\n\t                        ++seenCount;\n\t                    }\n\t                }\n\t\n\t                if (seenCount === shouldSeeCount) {\n\t                    next = j;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (next !== null) {\n\t            next = next.toString(); // Normalize to string TODO: replace with seq\n\t            visited[next] = true;\n\t            sorted.push(next);\n\t        }\n\t    }\n\t\n\t    if (sorted.length !== this._items.length) {\n\t        return new Error('Invalid dependencies');\n\t    }\n\t\n\t    var seqIndex = {};\n\t    for (var i = 0; i < this._items.length; ++i) {\n\t        var item = this._items[i];\n\t        seqIndex[item.seq] = item;\n\t    }\n\t\n\t    var sortedNodes = [];\n\t    this._items = sorted.map(function (value) {\n\t\n\t        var sortedItem = seqIndex[value];\n\t        sortedNodes.push(sortedItem.node);\n\t        return sortedItem;\n\t    });\n\t\n\t    this.nodes = sortedNodes;\n\t};\n\n/***/ },\n/* 31 */\n/*!**********************!*\\\n  !*** ./lib/array.js ***!\n  \\**********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// Load modules\n\t\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Cast = __webpack_require__(/*! ./cast */ 15);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.fastSplice = function (arr, i) {\n\t\n\t    var pos = i;\n\t    while (pos < arr.length) {\n\t        arr[pos++] = arr[pos];\n\t    }\n\t\n\t    --arr.length;\n\t};\n\t\n\tinternals.Array = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'array';\n\t    this._inner.items = [];\n\t    this._inner.ordereds = [];\n\t    this._inner.inclusions = [];\n\t    this._inner.exclusions = [];\n\t    this._inner.requireds = [];\n\t    this._flags.sparse = false;\n\t};\n\t\n\tHoek.inherits(internals.Array, Any);\n\t\n\tinternals.Array.prototype._base = function (value, state, options) {\n\t\n\t    var result = {\n\t        value: value\n\t    };\n\t\n\t    if (typeof value === 'string' && options.convert) {\n\t\n\t        try {\n\t            var converted = JSON.parse(value);\n\t            if (Array.isArray(converted)) {\n\t                result.value = converted;\n\t            }\n\t        } catch (e) {}\n\t    }\n\t\n\t    var isArray = Array.isArray(result.value);\n\t    var wasArray = isArray;\n\t    if (options.convert && this._flags.single && !isArray) {\n\t        result.value = [result.value];\n\t        isArray = true;\n\t    }\n\t\n\t    if (!isArray) {\n\t        result.errors = Errors.create('array.base', null, state, options);\n\t        return result;\n\t    }\n\t\n\t    if (this._inner.inclusions.length || this._inner.exclusions.length || !this._flags.sparse) {\n\t\n\t        // Clone the array so that we don't modify the original\n\t        if (wasArray) {\n\t            result.value = result.value.slice(0);\n\t        }\n\t\n\t        result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);\n\t\n\t        if (result.errors && wasArray && options.convert && this._flags.single) {\n\t\n\t            // Attempt a 2nd pass by putting the array inside one.\n\t            var previousErrors = result.errors;\n\t\n\t            result.value = [result.value];\n\t            result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);\n\t\n\t            if (result.errors) {\n\t\n\t                // Restore previous errors and value since this didn't validate either.\n\t                result.errors = previousErrors;\n\t                result.value = result.value[0];\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t};\n\t\n\tinternals.checkItems = function (items, wasArray, state, options) {\n\t\n\t    var errors = [];\n\t    var errored = undefined;\n\t\n\t    var requireds = this._inner.requireds.slice();\n\t    var ordereds = this._inner.ordereds.slice();\n\t    var inclusions = this._inner.inclusions.concat(requireds);\n\t\n\t    var il = items.length;\n\t    for (var i = 0; i < il; ++i) {\n\t        errored = false;\n\t        var item = items[i];\n\t        var isValid = false;\n\t        var localState = { key: i, path: (state.path ? state.path + '.' : '') + i, parent: items, reference: state.reference };\n\t        var res = undefined;\n\t\n\t        // Sparse\n\t\n\t        if (!this._flags.sparse && item === undefined) {\n\t            errors.push(Errors.create('array.sparse', null, { key: state.key, path: localState.path }, options));\n\t\n\t            if (options.abortEarly) {\n\t                return errors;\n\t            }\n\t\n\t            continue;\n\t        }\n\t\n\t        // Exclusions\n\t\n\t        for (var j = 0; j < this._inner.exclusions.length; ++j) {\n\t            res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults\n\t\n\t            if (!res.errors) {\n\t                errors.push(Errors.create(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\t                errored = true;\n\t\n\t                if (options.abortEarly) {\n\t                    return errors;\n\t                }\n\t\n\t                break;\n\t            }\n\t        }\n\t\n\t        if (errored) {\n\t            continue;\n\t        }\n\t\n\t        // Ordered\n\t        if (this._inner.ordereds.length) {\n\t            if (ordereds.length > 0) {\n\t                var ordered = ordereds.shift();\n\t                res = ordered._validate(item, localState, options);\n\t                if (!res.errors) {\n\t                    if (ordered._flags.strip) {\n\t                        internals.fastSplice(items, i);\n\t                        --i;\n\t                        --il;\n\t                    } else {\n\t                        items[i] = res.value;\n\t                    }\n\t                } else {\n\t                    errors.push(Errors.create('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n\t                    if (options.abortEarly) {\n\t                        return errors;\n\t                    }\n\t                }\n\t                continue;\n\t            } else if (!this._inner.items.length) {\n\t                errors.push(Errors.create('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));\n\t                if (options.abortEarly) {\n\t                    return errors;\n\t                }\n\t                continue;\n\t            }\n\t        }\n\t\n\t        // Requireds\n\t\n\t        var requiredChecks = [];\n\t        var jl = requireds.length;\n\t        for (var j = 0; j < jl; ++j) {\n\t            res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n\t            if (!res.errors) {\n\t                items[i] = res.value;\n\t                isValid = true;\n\t                internals.fastSplice(requireds, j);\n\t                --j;\n\t                --jl;\n\t                break;\n\t            }\n\t        }\n\t\n\t        if (isValid) {\n\t            continue;\n\t        }\n\t\n\t        // Inclusions\n\t\n\t        jl = inclusions.length;\n\t        for (var j = 0; j < jl; ++j) {\n\t            var inclusion = inclusions[j];\n\t\n\t            // Avoid re-running requireds that already didn't match in the previous loop\n\t            var previousCheck = requireds.indexOf(inclusion);\n\t            if (previousCheck !== -1) {\n\t                res = requiredChecks[previousCheck];\n\t            } else {\n\t                res = inclusion._validate(item, localState, options);\n\t\n\t                if (!res.errors) {\n\t                    if (inclusion._flags.strip) {\n\t                        internals.fastSplice(items, i);\n\t                        --i;\n\t                        --il;\n\t                    } else {\n\t                        items[i] = res.value;\n\t                    }\n\t                    isValid = true;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            // Return the actual error if only one inclusion defined\n\t            if (jl === 1) {\n\t                if (options.stripUnknown) {\n\t                    internals.fastSplice(items, i);\n\t                    --i;\n\t                    --il;\n\t                    isValid = true;\n\t                    break;\n\t                }\n\t\n\t                errors.push(Errors.create(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n\t                errored = true;\n\t\n\t                if (options.abortEarly) {\n\t                    return errors;\n\t                }\n\t\n\t                break;\n\t            }\n\t        }\n\t\n\t        if (errored) {\n\t            continue;\n\t        }\n\t\n\t        if (this._inner.inclusions.length && !isValid) {\n\t            if (options.stripUnknown) {\n\t                internals.fastSplice(items, i);\n\t                --i;\n\t                --il;\n\t                continue;\n\t            }\n\t\n\t            errors.push(Errors.create(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\t\n\t            if (options.abortEarly) {\n\t                return errors;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (requireds.length) {\n\t        internals.fillMissedErrors(errors, requireds, state, options);\n\t    }\n\t\n\t    if (ordereds.length) {\n\t        internals.fillOrderedErrors(errors, ordereds, state, options);\n\t    }\n\t\n\t    return errors.length ? errors : null;\n\t};\n\t\n\tinternals.fillMissedErrors = function (errors, requireds, state, options) {\n\t\n\t    var knownMisses = [];\n\t    var unknownMisses = 0;\n\t    for (var i = 0; i < requireds.length; ++i) {\n\t        var label = Hoek.reach(requireds[i], '_settings.language.label');\n\t        if (label) {\n\t            knownMisses.push(label);\n\t        } else {\n\t            ++unknownMisses;\n\t        }\n\t    }\n\t\n\t    if (knownMisses.length) {\n\t        if (unknownMisses) {\n\t            errors.push(Errors.create('array.includesRequiredBoth', { knownMisses: knownMisses, unknownMisses: unknownMisses }, { key: state.key, path: state.patk }, options));\n\t        } else {\n\t            errors.push(Errors.create('array.includesRequiredKnowns', { knownMisses: knownMisses }, { key: state.key, path: state.path }, options));\n\t        }\n\t    } else {\n\t        errors.push(Errors.create('array.includesRequiredUnknowns', { unknownMisses: unknownMisses }, { key: state.key, path: state.path }, options));\n\t    }\n\t};\n\t\n\tinternals.fillOrderedErrors = function (errors, ordereds, state, options) {\n\t\n\t    var requiredOrdereds = [];\n\t\n\t    for (var i = 0; i < ordereds.length; ++i) {\n\t        var presence = Hoek.reach(ordereds[i], '_flags.presence');\n\t        if (presence === 'required') {\n\t            requiredOrdereds.push(ordereds[i]);\n\t        }\n\t    }\n\t\n\t    if (requiredOrdereds.length) {\n\t        internals.fillMissedErrors(errors, requiredOrdereds, state, options);\n\t    }\n\t};\n\t\n\tinternals.Array.prototype.describe = function () {\n\t\n\t    var description = Any.prototype.describe.call(this);\n\t\n\t    if (this._inner.ordereds.length) {\n\t        description.orderedItems = [];\n\t\n\t        for (var i = 0; i < this._inner.ordereds.length; ++i) {\n\t            description.orderedItems.push(this._inner.ordereds[i].describe());\n\t        }\n\t    }\n\t\n\t    if (this._inner.items.length) {\n\t        description.items = [];\n\t\n\t        for (var i = 0; i < this._inner.items.length; ++i) {\n\t            description.items.push(this._inner.items[i].describe());\n\t        }\n\t    }\n\t\n\t    return description;\n\t};\n\t\n\tinternals.Array.prototype.items = function () {\n\t\n\t    var obj = this.clone();\n\t\n\t    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {\n\t\n\t        try {\n\t            type = Cast.schema(type);\n\t        } catch (castErr) {\n\t            if (castErr.hasOwnProperty('path')) {\n\t                castErr.path = index + '.' + castErr.path;\n\t            } else {\n\t                castErr.path = index;\n\t            }\n\t            castErr.message = castErr.message + '(' + castErr.path + ')';\n\t            throw castErr;\n\t        }\n\t\n\t        obj._inner.items.push(type);\n\t\n\t        if (type._flags.presence === 'required') {\n\t            obj._inner.requireds.push(type);\n\t        } else if (type._flags.presence === 'forbidden') {\n\t            obj._inner.exclusions.push(type.optional());\n\t        } else {\n\t            obj._inner.inclusions.push(type);\n\t        }\n\t    });\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Array.prototype.ordered = function () {\n\t\n\t    var obj = this.clone();\n\t\n\t    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach(function (type, index) {\n\t\n\t        try {\n\t            type = Cast.schema(type);\n\t        } catch (castErr) {\n\t            if (castErr.hasOwnProperty('path')) {\n\t                castErr.path = index + '.' + castErr.path;\n\t            } else {\n\t                castErr.path = index;\n\t            }\n\t            castErr.message = castErr.message + '(' + castErr.path + ')';\n\t            throw castErr;\n\t        }\n\t        obj._inner.ordereds.push(type);\n\t    });\n\t\n\t    return obj;\n\t};\n\t\n\tinternals.Array.prototype.min = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('min', limit, function (value, state, options) {\n\t\n\t        if (value.length >= limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('array.min', { limit: limit, value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Array.prototype.max = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('max', limit, function (value, state, options) {\n\t\n\t        if (value.length <= limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('array.max', { limit: limit, value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Array.prototype.length = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('length', limit, function (value, state, options) {\n\t\n\t        if (value.length === limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('array.length', { limit: limit, value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Array.prototype.unique = function () {\n\t\n\t    return this._test('unique', undefined, function (value, state, options) {\n\t\n\t        var found = {\n\t            string: {},\n\t            number: {},\n\t            undefined: {},\n\t            boolean: {},\n\t            object: [],\n\t            'function': []\n\t        };\n\t\n\t        for (var i = 0; i < value.length; ++i) {\n\t            var item = value[i];\n\t            var type = typeof item;\n\t            var records = found[type];\n\t\n\t            // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n\t            // I still want to keep the test for future js versions with new types (eg. Symbol).\n\t            if ( /* $lab:coverage:off$ */records /* $lab:coverage:on$ */) {\n\t                    if (Array.isArray(records)) {\n\t                        for (var j = 0; j < records.length; ++j) {\n\t                            if (Hoek.deepEqual(records[j], item)) {\n\t                                return Errors.create('array.unique', { pos: i, value: item }, state, options);\n\t                            }\n\t                        }\n\t\n\t                        records.push(item);\n\t                    } else {\n\t                        if (records[item]) {\n\t                            return Errors.create('array.unique', { pos: i, value: item }, state, options);\n\t                        }\n\t\n\t                        records[item] = true;\n\t                    }\n\t                }\n\t        }\n\t    });\n\t};\n\t\n\tinternals.Array.prototype.sparse = function (enabled) {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.sparse = enabled === undefined ? true : !!enabled;\n\t    return obj;\n\t};\n\t\n\tinternals.Array.prototype.single = function (enabled) {\n\t\n\t    var obj = this.clone();\n\t    obj._flags.single = enabled === undefined ? true : !!enabled;\n\t    return obj;\n\t};\n\t\n\tmodule.exports = new internals.Array();\n\n/***/ },\n/* 32 */\n/*!***********************!*\\\n  !*** ./lib/binary.js ***!\n  \\***********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\t// Load modules\n\t\n\tvar Any = __webpack_require__(/*! ./any */ 1);\n\tvar Errors = __webpack_require__(/*! ./errors */ 13);\n\tvar Hoek = __webpack_require__(/*! hoek */ 6);\n\t\n\t// Declare internals\n\t\n\tvar internals = {};\n\t\n\tinternals.Binary = function () {\n\t\n\t    Any.call(this);\n\t    this._type = 'binary';\n\t};\n\t\n\tHoek.inherits(internals.Binary, Any);\n\t\n\tinternals.Binary.prototype._base = function (value, state, options) {\n\t\n\t    var result = {\n\t        value: value\n\t    };\n\t\n\t    if (typeof value === 'string' && options.convert) {\n\t\n\t        try {\n\t            var converted = new Buffer(value, this._flags.encoding);\n\t            result.value = converted;\n\t        } catch (e) {}\n\t    }\n\t\n\t    result.errors = Buffer.isBuffer(result.value) ? null : Errors.create('binary.base', null, state, options);\n\t    return result;\n\t};\n\t\n\tinternals.Binary.prototype.encoding = function (encoding) {\n\t\n\t    Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\t\n\t    var obj = this.clone();\n\t    obj._flags.encoding = encoding;\n\t    return obj;\n\t};\n\t\n\tinternals.Binary.prototype.min = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('min', limit, function (value, state, options) {\n\t\n\t        if (value.length >= limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('binary.min', { limit: limit, value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Binary.prototype.max = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('max', limit, function (value, state, options) {\n\t\n\t        if (value.length <= limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('binary.max', { limit: limit, value: value }, state, options);\n\t    });\n\t};\n\t\n\tinternals.Binary.prototype.length = function (limit) {\n\t\n\t    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\t\n\t    return this._test('length', limit, function (value, state, options) {\n\t\n\t        if (value.length === limit) {\n\t            return null;\n\t        }\n\t\n\t        return Errors.create('binary.length', { limit: limit, value: value }, state, options);\n\t    });\n\t};\n\t\n\tmodule.exports = new internals.Binary();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/buffer/index.js */ 2).Buffer))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** joi-browser.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 25e58d7788228f1405cc\n **/","'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Cast = require('./cast');\nconst Ref = require('./ref');\n\n\n// Declare internals\n\nconst internals = {\n    alternatives: require('./alternatives'),\n    array: require('./array'),\n    boolean: require('./boolean'),\n    binary: require('./binary'),\n    date: require('./date'),\n    number: require('./number'),\n    object: require('./object'),\n    string: require('./string')\n};\n\n\ninternals.root = function () {\n\n    const any = new Any();\n\n    const root = any.clone();\n    root.any = function () {\n\n        return any;\n    };\n\n    root.alternatives = root.alt = function () {\n\n        return arguments.length ? internals.alternatives.try.apply(internals.alternatives, arguments) : internals.alternatives;\n    };\n\n    root.array = function () {\n\n        return internals.array;\n    };\n\n    root.boolean = root.bool = function () {\n\n        return internals.boolean;\n    };\n\n    root.binary = function () {\n\n        return internals.binary;\n    };\n\n    root.date = function () {\n\n        return internals.date;\n    };\n\n    root.func = function () {\n\n        return internals.object._func();\n    };\n\n    root.number = function () {\n\n        return internals.number;\n    };\n\n    root.object = function () {\n\n        return arguments.length ? internals.object.keys.apply(internals.object, arguments) : internals.object;\n    };\n\n    root.string = function () {\n\n        return internals.string;\n    };\n\n    root.ref = function () {\n\n        return Ref.create.apply(null, arguments);\n    };\n\n    root.isRef = function (ref) {\n\n        return Ref.isRef(ref);\n    };\n\n    root.validate = function (value /*, [schema], [options], callback */) {\n\n        const last = arguments[arguments.length - 1];\n        const callback = typeof last === 'function' ? last : null;\n\n        const count = arguments.length - (callback ? 1 : 0);\n        if (count === 1) {\n            return any.validate(value, callback);\n        }\n\n        const options = count === 3 ? arguments[2] : {};\n        const schema = root.compile(arguments[1]);\n\n        return schema._validateWithOptions(value, options, callback);\n    };\n\n    root.describe = function () {\n\n        const schema = arguments.length ? root.compile(arguments[0]) : any;\n        return schema.describe();\n    };\n\n    root.compile = function (schema) {\n\n        try {\n            return Cast.schema(schema);\n        }\n        catch (err) {\n            if (err.hasOwnProperty('path')) {\n                err.message = err.message + '(' + err.path + ')';\n            }\n            throw err;\n        }\n    };\n\n    root.assert = function (value, schema, message) {\n\n        root.attempt(value, schema, message);\n    };\n\n    root.attempt = function (value, schema, message) {\n\n        const result = root.validate(value, schema);\n        const error = result.error;\n        if (error) {\n            if (!message) {\n                error.message = error.annotate();\n                throw error;\n            }\n\n            if (!(message instanceof Error)) {\n                error.message = message + ' ' + error.annotate();\n                throw error;\n            }\n\n            throw message;\n        }\n\n        return result.value;\n    };\n\n    return root;\n};\n\n\nmodule.exports = internals.root();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/index.js\n **/","'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Ref = require('./ref');\nconst Errors = require('./errors');\nlet Alternatives = null;                // Delay-loaded to prevent circular dependencies\nlet Cast = null;\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.defaults = {\n    abortEarly: true,\n    convert: true,\n    allowUnknown: false,\n    skipFunctions: false,\n    stripUnknown: false,\n    language: {},\n    presence: 'optional',\n    raw: false,\n    strip: false,\n    noDefaults: false\n\n    // context: null\n};\n\n\ninternals.checkOptions = function (options) {\n\n    const optionType = {\n        abortEarly: 'boolean',\n        convert: 'boolean',\n        allowUnknown: 'boolean',\n        skipFunctions: 'boolean',\n        stripUnknown: 'boolean',\n        language: 'object',\n        presence: ['string', 'required', 'optional', 'forbidden', 'ignore'],\n        raw: 'boolean',\n        context: 'object',\n        strip: 'boolean',\n        noDefaults: 'boolean'\n    };\n\n    const keys = Object.keys(options);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const opt = optionType[key];\n        let type = opt;\n        let values = null;\n\n        if (Array.isArray(opt)) {\n            type = opt[0];\n            values = opt.slice(1);\n        }\n\n        Hoek.assert(type, 'unknown key ' + key);\n        Hoek.assert(typeof options[key] === type, key + ' should be of type ' + type);\n        if (values) {\n            Hoek.assert(values.indexOf(options[key]) >= 0, key + ' should be one of ' + values.join(', '));\n        }\n    }\n};\n\n\nmodule.exports = internals.Any = function () {\n\n    Cast = Cast || require('./cast');\n\n    this.isJoi = true;\n    this._type = 'any';\n    this._settings = null;\n    this._valids = new internals.Set();\n    this._invalids = new internals.Set();\n    this._tests = [];\n    this._refs = [];\n    this._flags = { /*\n        presence: 'optional',                   // optional, required, forbidden, ignore\n        allowOnly: false,\n        allowUnknown: undefined,\n        default: undefined,\n        forbidden: false,\n        encoding: undefined,\n        insensitive: false,\n        trim: false,\n        case: undefined,                        // upper, lower\n        empty: undefined,\n        func: false\n    */ };\n\n    this._description = null;\n    this._unit = null;\n    this._notes = [];\n    this._tags = [];\n    this._examples = [];\n    this._meta = [];\n\n    this._inner = {};                           // Hash of arrays of immutable objects\n};\n\n\ninternals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects\n\n\ninternals.Any.prototype.clone = function () {\n\n    const obj = Object.create(Object.getPrototypeOf(this));\n\n    obj.isJoi = true;\n    obj._type = this._type;\n    obj._settings = internals.concatSettings(this._settings);\n    obj._valids = Hoek.clone(this._valids);\n    obj._invalids = Hoek.clone(this._invalids);\n    obj._tests = this._tests.slice();\n    obj._refs = this._refs.slice();\n    obj._flags = Hoek.clone(this._flags);\n\n    obj._description = this._description;\n    obj._unit = this._unit;\n    obj._notes = this._notes.slice();\n    obj._tags = this._tags.slice();\n    obj._examples = this._examples.slice();\n    obj._meta = this._meta.slice();\n\n    obj._inner = {};\n    const inners = Object.keys(this._inner);\n    for (let i = 0; i < inners.length; ++i) {\n        const key = inners[i];\n        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n    }\n\n    return obj;\n};\n\n\ninternals.Any.prototype.concat = function (schema) {\n\n    Hoek.assert(schema && schema.isJoi, 'Invalid schema object');\n    Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n\n    let obj = this.clone();\n\n    if (this._type === 'any' && schema._type !== 'any') {\n\n        // Reset values as if we were \"this\"\n        const tmpObj = schema.clone();\n        const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\n            '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n        for (let i = 0; i < keysToRestore.length; ++i) {\n            tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n        }\n\n        obj = tmpObj;\n    }\n\n    obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;\n    obj._valids.merge(schema._valids, schema._invalids);\n    obj._invalids.merge(schema._invalids, schema._valids);\n    obj._tests = obj._tests.concat(schema._tests);\n    obj._refs = obj._refs.concat(schema._refs);\n    Hoek.merge(obj._flags, schema._flags);\n\n    obj._description = schema._description || obj._description;\n    obj._unit = schema._unit || obj._unit;\n    obj._notes = obj._notes.concat(schema._notes);\n    obj._tags = obj._tags.concat(schema._tags);\n    obj._examples = obj._examples.concat(schema._examples);\n    obj._meta = obj._meta.concat(schema._meta);\n\n    const inners = Object.keys(schema._inner);\n    const isObject = obj._type === 'object';\n    for (let i = 0; i < inners.length; ++i) {\n        const key = inners[i];\n        const source = schema._inner[key];\n        if (source) {\n            const target = obj._inner[key];\n            if (target) {\n                if (isObject && key === 'children') {\n                    const keys = {};\n\n                    for (let j = 0; j < target.length; ++j) {\n                        keys[target[j].key] = j;\n                    }\n\n                    for (let j = 0; j < source.length; ++j) {\n                        const sourceKey = source[j].key;\n                        if (keys[sourceKey] >= 0) {\n                            target[keys[sourceKey]] = {\n                                key: sourceKey,\n                                schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                            };\n                        }\n                        else {\n                            target.push(source[j]);\n                        }\n                    }\n                }\n                else {\n                    obj._inner[key] = obj._inner[key].concat(source);\n                }\n            }\n            else {\n                obj._inner[key] = source.slice();\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.Any.prototype._test = function (name, arg, func) {\n\n    Hoek.assert(!this._flags.allowOnly, 'Cannot define rules when valid values specified');\n\n    const obj = this.clone();\n    obj._tests.push({ func: func, name: name, arg: arg });\n    return obj;\n};\n\n\ninternals.Any.prototype.options = function (options) {\n\n    Hoek.assert(!options.context, 'Cannot override context');\n    internals.checkOptions(options);\n\n    const obj = this.clone();\n    obj._settings = internals.concatSettings(obj._settings, options);\n    return obj;\n};\n\n\ninternals.Any.prototype.strict = function (isStrict) {\n\n    const obj = this.clone();\n    obj._settings = obj._settings || {};\n    obj._settings.convert = isStrict === undefined ? false : !isStrict;\n    return obj;\n};\n\n\ninternals.Any.prototype.raw = function (isRaw) {\n\n    const obj = this.clone();\n    obj._settings = obj._settings || {};\n    obj._settings.raw = isRaw === undefined ? true : isRaw;\n    return obj;\n};\n\n\ninternals.Any.prototype._allow = function () {\n\n    const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n    for (let i = 0; i < values.length; ++i) {\n        const value = values[i];\n\n        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n        this._invalids.remove(value);\n        this._valids.add(value, this._refs);\n    }\n};\n\n\ninternals.Any.prototype.allow = function () {\n\n    const obj = this.clone();\n    obj._allow.apply(obj, arguments);\n    return obj;\n};\n\n\ninternals.Any.prototype.valid = internals.Any.prototype.only = internals.Any.prototype.equal = function () {\n\n    Hoek.assert(!this._tests.length, 'Cannot set valid values when rules specified');\n\n    const obj = this.allow.apply(this, arguments);\n    obj._flags.allowOnly = true;\n    return obj;\n};\n\n\ninternals.Any.prototype.invalid = internals.Any.prototype.disallow = internals.Any.prototype.not = function (value) {\n\n    const obj = this.clone();\n    const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n    for (let i = 0; i < values.length; ++i) {\n        value = values[i];\n\n        Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n        obj._valids.remove(value);\n        obj._invalids.add(value, this._refs);\n    }\n\n    return obj;\n};\n\n\ninternals.Any.prototype.required = internals.Any.prototype.exist = function () {\n\n    const obj = this.clone();\n    obj._flags.presence = 'required';\n    return obj;\n};\n\n\ninternals.Any.prototype.optional = function () {\n\n    const obj = this.clone();\n    obj._flags.presence = 'optional';\n    return obj;\n};\n\n\ninternals.Any.prototype.forbidden = function () {\n\n    const obj = this.clone();\n    obj._flags.presence = 'forbidden';\n    return obj;\n};\n\n\ninternals.Any.prototype.strip = function () {\n\n    const obj = this.clone();\n    obj._flags.strip = true;\n    return obj;\n};\n\n\ninternals.Any.prototype.applyFunctionToChildren = function (children, fn, args, root) {\n\n    children = [].concat(children);\n\n    if (children.length !== 1 || children[0] !== '') {\n        root = root ? (root + '.') : '';\n\n        const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\n\n            return root + child;\n        });\n\n        throw new Error('unknown key(s) ' + extraChildren.join(', '));\n    }\n\n    return this[fn].apply(this, args);\n};\n\n\ninternals.Any.prototype.default = function (value, description) {\n\n    if (typeof value === 'function' &&\n        !Ref.isRef(value)) {\n\n        if (!value.description &&\n            description) {\n\n            value.description = description;\n        }\n\n        if (!this._flags.func) {\n            Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n        }\n    }\n\n    const obj = this.clone();\n    obj._flags.default = value;\n    Ref.push(obj._refs, value);\n    return obj;\n};\n\n\ninternals.Any.prototype.empty = function (schema) {\n\n    if (schema === undefined) {\n        const obj = this.clone();\n        obj._flags.empty = undefined;\n        return obj;\n    }\n\n    schema = Cast.schema(schema);\n\n    const obj = this.clone();\n    obj._flags.empty = schema;\n    return obj;\n};\n\n\ninternals.Any.prototype.when = function (ref, options) {\n\n    Hoek.assert(options && typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n    const then = options.then ? this.concat(Cast.schema(options.then)) : this;\n    const otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;\n\n    Alternatives = Alternatives || require('./alternatives');\n    const obj = Alternatives.when(ref, { is: options.is, then: then, otherwise: otherwise });\n    obj._flags.presence = 'ignore';\n    return obj;\n};\n\n\ninternals.Any.prototype.description = function (desc) {\n\n    Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n    const obj = this.clone();\n    obj._description = desc;\n    return obj;\n};\n\n\ninternals.Any.prototype.notes = function (notes) {\n\n    Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n\n    const obj = this.clone();\n    obj._notes = obj._notes.concat(notes);\n    return obj;\n};\n\n\ninternals.Any.prototype.tags = function (tags) {\n\n    Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n\n    const obj = this.clone();\n    obj._tags = obj._tags.concat(tags);\n    return obj;\n};\n\ninternals.Any.prototype.meta = function (meta) {\n\n    Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n\n    const obj = this.clone();\n    obj._meta = obj._meta.concat(meta);\n    return obj;\n};\n\n\ninternals.Any.prototype.example = function (value) {\n\n    Hoek.assert(arguments.length, 'Missing example');\n    const result = this._validate(value, null, internals.defaults);\n    Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));\n\n    const obj = this.clone();\n    obj._examples = obj._examples.concat(value);\n    return obj;\n};\n\n\ninternals.Any.prototype.unit = function (name) {\n\n    Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n    const obj = this.clone();\n    obj._unit = name;\n    return obj;\n};\n\n\ninternals._try = function (fn, arg) {\n\n    let err;\n    let result;\n\n    try {\n        result = fn.call(null, arg);\n    }\n    catch (e) {\n        err = e;\n    }\n\n    return {\n        value: result,\n        error: err\n    };\n};\n\n\ninternals.Any.prototype._validate = function (value, state, options, reference) {\n\n    const originalValue = value;\n\n    // Setup state and settings\n\n    state = state || { key: '', path: '', parent: null, reference: reference };\n\n    if (this._settings) {\n        options = internals.concatSettings(options, this._settings);\n    }\n\n    let errors = [];\n    const finish = () => {\n\n        let finalValue;\n\n        if (!this._flags.strip) {\n            if (value !== undefined) {\n                finalValue = options.raw ? originalValue : value;\n            }\n            else if (options.noDefaults) {\n                finalValue = originalValue;\n            }\n            else if (Ref.isRef(this._flags.default)) {\n                finalValue = this._flags.default(state.parent, options);\n            }\n            else if (typeof this._flags.default === 'function' &&\n                    !(this._flags.func && !this._flags.default.description)) {\n\n                let arg;\n\n                if (state.parent !== null &&\n                    this._flags.default.length > 0) {\n\n                    arg = Hoek.clone(state.parent);\n                }\n\n                const defaultValue = internals._try(this._flags.default, arg);\n                finalValue = defaultValue.value;\n                if (defaultValue.error) {\n                    errors.push(Errors.create('any.default', defaultValue.error, state, options));\n                }\n            }\n            else {\n                finalValue = Hoek.clone(this._flags.default);\n            }\n        }\n\n        return {\n            value: finalValue,\n            errors: errors.length ? errors : null\n        };\n    };\n\n    // Check presence requirements\n\n    const presence = this._flags.presence || options.presence;\n    if (presence === 'optional') {\n        if (value === undefined) {\n            const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n            if (isDeepDefault && this._type === 'object') {\n                value = {};\n            }\n            else {\n                return finish();\n            }\n        }\n    }\n    else if (presence === 'required' &&\n            value === undefined) {\n\n        errors.push(Errors.create('any.required', null, state, options));\n        return finish();\n    }\n    else if (presence === 'forbidden') {\n        if (value === undefined) {\n            return finish();\n        }\n\n        errors.push(Errors.create('any.unknown', null, state, options));\n        return finish();\n    }\n\n    if (this._flags.empty && !this._flags.empty._validate(value, null, internals.defaults).errors) {\n        value = undefined;\n        return finish();\n    }\n\n    // Check allowed and denied values using the original value\n\n    if (this._valids.has(value, state, options, this._flags.insensitive)) {\n        return finish();\n    }\n\n    if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n        errors.push(Errors.create(value === '' ? 'any.empty' : 'any.invalid', null, state, options));\n        if (options.abortEarly ||\n            value === undefined) {          // No reason to keep validating missing value\n\n            return finish();\n        }\n    }\n\n    // Convert value and validate type\n\n    if (this._base) {\n        const base = this._base.call(this, value, state, options);\n        if (base.errors) {\n            value = base.value;\n            errors = errors.concat(base.errors);\n            return finish();                            // Base error always aborts early\n        }\n\n        if (base.value !== value) {\n            value = base.value;\n\n            // Check allowed and denied values using the converted value\n\n            if (this._valids.has(value, state, options, this._flags.insensitive)) {\n                return finish();\n            }\n\n            if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n                errors.push(Errors.create('any.invalid', null, state, options));\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n    }\n\n    // Required values did not match\n\n    if (this._flags.allowOnly) {\n        errors.push(Errors.create('any.allowOnly', { valids: this._valids.values({ stripUndefined: true }) }, state, options));\n        if (options.abortEarly) {\n            return finish();\n        }\n    }\n\n    // Helper.validate tests\n\n    for (let i = 0; i < this._tests.length; ++i) {\n        const test = this._tests[i];\n        const err = test.func.call(this, value, state, options);\n        if (err) {\n            errors.push(err);\n            if (options.abortEarly) {\n                return finish();\n            }\n        }\n    }\n\n    return finish();\n};\n\n\ninternals.Any.prototype._validateWithOptions = function (value, options, callback) {\n\n    if (options) {\n        internals.checkOptions(options);\n    }\n\n    const settings = internals.concatSettings(internals.defaults, options);\n    const result = this._validate(value, null, settings);\n    const errors = Errors.process(result.errors, value);\n\n    if (callback) {\n        return callback(errors, result.value);\n    }\n\n    return { error: errors, value: result.value };\n};\n\n\ninternals.Any.prototype.validate = function (value, callback) {\n\n    const result = this._validate(value, null, internals.defaults);\n    const errors = Errors.process(result.errors, value);\n\n    if (callback) {\n        return callback(errors, result.value);\n    }\n\n    return { error: errors, value: result.value };\n};\n\n\ninternals.Any.prototype.describe = function () {\n\n    const description = {\n        type: this._type\n    };\n\n    const flags = Object.keys(this._flags);\n    if (flags.length) {\n        if (this._flags.empty) {\n            description.flags = {};\n            for (let i = 0; i < flags.length; ++i) {\n                const flag = flags[i];\n                description.flags[flag] = flag === 'empty' ? this._flags[flag].describe() : this._flags[flag];\n            }\n        }\n        else {\n            description.flags = this._flags;\n        }\n    }\n\n    if (this._description) {\n        description.description = this._description;\n    }\n\n    if (this._notes.length) {\n        description.notes = this._notes;\n    }\n\n    if (this._tags.length) {\n        description.tags = this._tags;\n    }\n\n    if (this._meta.length) {\n        description.meta = this._meta;\n    }\n\n    if (this._examples.length) {\n        description.examples = this._examples;\n    }\n\n    if (this._unit) {\n        description.unit = this._unit;\n    }\n\n    const valids = this._valids.values();\n    if (valids.length) {\n        description.valids = valids;\n    }\n\n    const invalids = this._invalids.values();\n    if (invalids.length) {\n        description.invalids = invalids;\n    }\n\n    description.rules = [];\n\n    for (let i = 0; i < this._tests.length; ++i) {\n        const validator = this._tests[i];\n        const item = { name: validator.name };\n        if (validator.arg !== void 0) {\n            item.arg = validator.arg;\n        }\n        description.rules.push(item);\n    }\n\n    if (!description.rules.length) {\n        delete description.rules;\n    }\n\n    const label = Hoek.reach(this._settings, 'language.label');\n    if (label) {\n        description.label = label;\n    }\n\n    return description;\n};\n\ninternals.Any.prototype.label = function (name) {\n\n    Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n    const obj = this.clone();\n    const options = { language: { label: name } };\n\n    // If language.label is set, it should override this label\n    obj._settings = internals.concatSettings(options, obj._settings);\n    return obj;\n};\n\n\n// Set\n\ninternals.Set = function () {\n\n    this._set = [];\n};\n\n\ninternals.Set.prototype.add = function (value, refs) {\n\n    Hoek.assert(value === null || value === undefined || value instanceof Date || Buffer.isBuffer(value) || Ref.isRef(value) || (typeof value !== 'function' && typeof value !== 'object'), 'Value cannot be an object or function');\n\n    if (typeof value !== 'function' &&\n        this.has(value, null, null, false)) {\n\n        return;\n    }\n\n    Ref.push(refs, value);\n    this._set.push(value);\n};\n\n\ninternals.Set.prototype.merge = function (add, remove) {\n\n    for (let i = 0; i < add._set.length; ++i) {\n        this.add(add._set[i]);\n    }\n\n    for (let i = 0; i < remove._set.length; ++i) {\n        this.remove(remove._set[i]);\n    }\n};\n\n\ninternals.Set.prototype.remove = function (value) {\n\n    this._set = this._set.filter((item) => value !== item);\n};\n\n\ninternals.Set.prototype.has = function (value, state, options, insensitive) {\n\n    for (let i = 0; i < this._set.length; ++i) {\n        let items = this._set[i];\n\n        if (Ref.isRef(items)) {\n            items = items(state.reference || state.parent, options);\n        }\n\n        if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        for (let j = 0; j < items.length; ++j) {\n            const item = items[j];\n            if (typeof value !== typeof item) {\n                continue;\n            }\n\n            if (value === item ||\n                (value instanceof Date && item instanceof Date && value.getTime() === item.getTime()) ||\n                (insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase()) ||\n                (Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary'))) {\n\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n\ninternals.Set.prototype.values = function (options) {\n\n    if (options && options.stripUndefined) {\n        const values = [];\n\n        for (let i = 0; i < this._set.length; ++i) {\n            const item = this._set[i];\n            if (item !== undefined) {\n                values.push(item);\n            }\n        }\n\n        return values;\n    }\n\n    return this._set.slice();\n};\n\n\ninternals.concatSettings = function (target, source) {\n\n    // Used to avoid cloning context\n\n    if (!target &&\n        !source) {\n\n        return null;\n    }\n\n    const obj = {};\n\n    if (target) {\n        const tKeys = Object.keys(target);\n        for (let i = 0; i < tKeys.length; ++i) {\n            const key = tKeys[i];\n            obj[key] = target[key];\n        }\n    }\n\n    if (source) {\n        const sKeys = Object.keys(source);\n        for (let i = 0; i < sKeys.length; ++i) {\n            const key = sKeys[i];\n            if (key !== 'language' ||\n                !obj.hasOwnProperty(key)) {\n\n                obj[key] = source[key];\n            }\n            else {\n                obj[key] = Hoek.applyToDefaults(obj[key], source[key]);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/any.js\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/index.js\n ** module id = 2\n ** module chunks = 0 1\n **/","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/~/base64-js/lib/b64.js\n ** module id = 3\n ** module chunks = 0 1\n **/","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/~/ieee754/index.js\n ** module id = 4\n ** module chunks = 0 1\n **/","\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/~/is-array/index.js\n ** module id = 5\n ** module chunks = 0 1\n **/","'use strict';\n\n// Load modules\n\nconst Crypto = require('crypto');\nconst Path = require('path');\nconst Util = require('util');\nconst Escape = require('./escape');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Clone object or array\n\nexports.clone = function (obj, seen) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    seen = seen || { orig: [], copy: [] };\n\n    const lookup = seen.orig.indexOf(obj);\n    if (lookup !== -1) {\n        return seen.copy[lookup];\n    }\n\n    let newObj;\n    let cloneDeep = false;\n\n    if (!Array.isArray(obj)) {\n        if (Buffer.isBuffer(obj)) {\n            newObj = new Buffer(obj);\n        }\n        else if (obj instanceof Date) {\n            newObj = new Date(obj.getTime());\n        }\n        else if (obj instanceof RegExp) {\n            newObj = new RegExp(obj);\n        }\n        else {\n            const proto = Object.getPrototypeOf(obj);\n            if (proto &&\n                proto.isImmutable) {\n\n                newObj = obj;\n            }\n            else {\n                newObj = Object.create(proto);\n                cloneDeep = true;\n            }\n        }\n    }\n    else {\n        newObj = [];\n        cloneDeep = true;\n    }\n\n    seen.orig.push(obj);\n    seen.copy.push(newObj);\n\n    if (cloneDeep) {\n        const keys = Object.getOwnPropertyNames(obj);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n            if (descriptor &&\n                (descriptor.get ||\n                 descriptor.set)) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else {\n                newObj[key] = exports.clone(obj[key], seen);\n            }\n        }\n    }\n\n    return newObj;\n};\n\n\n// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\nexports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {\n/*eslint-enable */\n\n    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(exports.clone(source[i]));\n        }\n\n        return target;\n    }\n\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) ^ Array.isArray(value)) ||\n                value instanceof Date ||\n                Buffer.isBuffer(value) ||\n                value instanceof RegExp) {\n\n                target[key] = exports.clone(value);\n            }\n            else {\n                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (isNullOverride !== false) {                    // Defaults to true\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n\n\n// Apply options to a copy of the defaults\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.clone(defaults);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    return exports.merge(copy, options, isNullOverride === true, false);\n};\n\n\n// Clone an object except for the listed keys which are shallow copied\n\nexports.cloneWithShallow = function (source, keys) {\n\n    if (!source ||\n        typeof source !== 'object') {\n\n        return source;\n    }\n\n    const storage = internals.store(source, keys);    // Move shallow copy items to storage\n    const copy = exports.clone(source);               // Deep copy the rest\n    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.store = function (source, keys) {\n\n    const storage = {};\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = exports.reach(source, key);\n        if (value !== undefined) {\n            storage[key] = value;\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\ninternals.restore = function (copy, source, storage) {\n\n    const keys = Object.keys(storage);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        internals.reachSet(copy, key, storage[key]);\n        internals.reachSet(source, key, storage[key]);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n\n\n// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.cloneWithShallow(defaults, keys);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    const storage = internals.store(options, keys);   // Move shallow copy items to storage\n    exports.merge(copy, options, false, false);     // Deep copy the rest\n    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore\n    return copy;\n};\n\n\n// Deep object or array comparison\n\nexports.deepEqual = function (obj, ref, options, seen) {\n\n    options = options || { prototype: true };\n\n    const type = typeof obj;\n\n    if (type !== typeof ref) {\n        return false;\n    }\n\n    if (type !== 'object' ||\n        obj === null ||\n        ref === null) {\n\n        if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0\n        }\n\n        return obj !== obj && ref !== ref;                  // NaN\n    }\n\n    seen = seen || [];\n    if (seen.indexOf(obj) !== -1) {\n        return true;                            // If previous comparison failed, it would have stopped execution\n    }\n\n    seen.push(obj);\n\n    if (Array.isArray(obj)) {\n        if (!Array.isArray(ref)) {\n            return false;\n        }\n\n        if (!options.part && obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (options.part) {\n                let found = false;\n                for (let j = 0; j < ref.length; ++j) {\n                    if (exports.deepEqual(obj[i], ref[j], options)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                return found;\n            }\n\n            if (!exports.deepEqual(obj[i], ref[i], options)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (Buffer.isBuffer(obj)) {\n        if (!Buffer.isBuffer(ref)) {\n            return false;\n        }\n\n        if (obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (obj[i] !== ref[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (obj instanceof Date) {\n        return (ref instanceof Date && obj.getTime() === ref.getTime());\n    }\n\n    if (obj instanceof RegExp) {\n        return (ref instanceof RegExp && obj.toString() === ref.toString());\n    }\n\n    if (options.prototype) {\n        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n            return false;\n        }\n    }\n\n    const keys = Object.getOwnPropertyNames(obj);\n\n    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n        return false;\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor.get) {\n            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n                return false;\n            }\n        }\n        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n// Remove duplicate items from array\n\nexports.unique = function (array, key) {\n\n    const index = {};\n    const result = [];\n\n    for (let i = 0; i < array.length; ++i) {\n        const id = (key ? array[i][key] : array[i]);\n        if (index[id] !== true) {\n\n            result.push(array[i]);\n            index[id] = true;\n        }\n    }\n\n    return result;\n};\n\n\n// Convert array into object\n\nexports.mapToObject = function (array, key) {\n\n    if (!array) {\n        return null;\n    }\n\n    const obj = {};\n    for (let i = 0; i < array.length; ++i) {\n        if (key) {\n            if (array[i][key]) {\n                obj[array[i][key]] = true;\n            }\n        }\n        else {\n            obj[array[i]] = true;\n        }\n    }\n\n    return obj;\n};\n\n\n// Find the common unique items in two arrays\n\nexports.intersect = function (array1, array2, justFirst) {\n\n    if (!array1 || !array2) {\n        return [];\n    }\n\n    const common = [];\n    const hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);\n    const found = {};\n    for (let i = 0; i < array2.length; ++i) {\n        if (hash[array2[i]] && !found[array2[i]]) {\n            if (justFirst) {\n                return array2[i];\n            }\n\n            common.push(array2[i]);\n            found[array2[i]] = true;\n        }\n    }\n\n    return (justFirst ? null : common);\n};\n\n\n// Test if the reference contains the values\n\nexports.contain = function (ref, values, options) {\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    let valuePairs = null;\n    if (typeof ref === 'object' &&\n        typeof values === 'object' &&\n        !Array.isArray(ref) &&\n        !Array.isArray(values)) {\n\n        valuePairs = values;\n        values = Object.keys(values);\n    }\n    else {\n        values = [].concat(values);\n    }\n\n    options = options || {};            // deep, once, only, part\n\n    exports.assert(arguments.length >= 2, 'Insufficient arguments');\n    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n    exports.assert(values.length, 'Values array cannot be empty');\n\n    let compare;\n    let compareFlags;\n    if (options.deep) {\n        compare = exports.deepEqual;\n\n        const hasOnly = options.hasOwnProperty('only');\n        const hasPart = options.hasOwnProperty('part');\n\n        compareFlags = {\n            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n            part: hasOnly ? !options.only : hasPart ? options.part : true\n        };\n    }\n    else {\n        compare = (a, b) => a === b;\n    }\n\n    let misses = false;\n    const matches = new Array(values.length);\n    for (let i = 0; i < matches.length; ++i) {\n        matches[i] = 0;\n    }\n\n    if (typeof ref === 'string') {\n        let pattern = '(';\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n        }\n\n        const regex = new RegExp(pattern + ')', 'g');\n        const leftovers = ref.replace(regex, ($0, $1) => {\n\n            const index = values.indexOf($1);\n            ++matches[index];\n            return '';          // Remove from string\n        });\n\n        misses = !!leftovers;\n    }\n    else if (Array.isArray(ref)) {\n        for (let i = 0; i < ref.length; ++i) {\n            let matched = false;\n            for (let j = 0; j < values.length && matched === false; ++j) {\n                matched = compare(values[j], ref[i], compareFlags) && j;\n            }\n\n            if (matched !== false) {\n                ++matches[matched];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n    else {\n        const keys = Object.keys(ref);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const pos = values.indexOf(key);\n            if (pos !== -1) {\n                if (valuePairs &&\n                    !compare(valuePairs[key], ref[key], compareFlags)) {\n\n                    return false;\n                }\n\n                ++matches[pos];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n\n    let result = false;\n    for (let i = 0; i < matches.length; ++i) {\n        result = result || !!matches[i];\n        if ((options.once && matches[i] > 1) ||\n            (!options.part && !matches[i])) {\n\n            return false;\n        }\n    }\n\n    if (options.only &&\n        misses) {\n\n        return false;\n    }\n\n    return result;\n};\n\n\n// Flatten array\n\nexports.flatten = function (array, target) {\n\n    const result = target || [];\n\n    for (let i = 0; i < array.length; ++i) {\n        if (Array.isArray(array[i])) {\n            exports.flatten(array[i], result);\n        }\n        else {\n            result.push(array[i]);\n        }\n    }\n\n    return result;\n};\n\n\n// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\nexports.reach = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        typeof chain === 'undefined') {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const path = chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        if (key[0] === '-' && Array.isArray(ref)) {\n            key = key.slice(1, key.length);\n            key = ref.length - key;\n        }\n\n        if (!ref ||\n            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||\n            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties\n\n            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        ref = ref[key];\n    }\n\n    return ref;\n};\n\n\nexports.reachTemplate = function (obj, template, options) {\n\n    return template.replace(/{([^}]+)}/g, ($0, chain) => {\n\n        const value = exports.reach(obj, chain, options);\n        return (value === undefined || value === null ? '' : value);\n    });\n};\n\n\nexports.formatStack = function (stack) {\n\n    const trace = [];\n    for (let i = 0; i < stack.length; ++i) {\n        const item = stack[i];\n        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n    }\n\n    return trace;\n};\n\n\nexports.formatTrace = function (trace) {\n\n    const display = [];\n\n    for (let i = 0; i < trace.length; ++i) {\n        const row = trace[i];\n        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n    }\n\n    return display;\n};\n\n\nexports.callStack = function (slice) {\n\n    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\n    const v8 = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (err, stack) {\n\n        return stack;\n    };\n\n    const capture = {};\n    Error.captureStackTrace(capture, this);     // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result\n    const stack = capture.stack;\n\n    Error.prepareStackTrace = v8;\n\n    const trace = exports.formatStack(stack);\n\n    return trace.slice(1 + slice);\n};\n\n\nexports.displayStack = function (slice) {\n\n    const trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n\n    return exports.formatTrace(trace);\n};\n\n\nexports.abortThrow = false;\n\n\nexports.abort = function (message, hideStack) {\n\n    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n        throw new Error(message || 'Unknown error');\n    }\n\n    let stack = '';\n    if (!hideStack) {\n        stack = exports.displayStack(1).join('\\n\\t');\n    }\n    console.log('ABORT: ' + message + '\\n\\t' + stack);\n    process.exit(1);\n};\n\n\nexports.assert = function (condition /*, msg1, msg2, msg3 */) {\n\n    if (condition) {\n        return;\n    }\n\n    if (arguments.length === 2 && arguments[1] instanceof Error) {\n        throw arguments[1];\n    }\n\n    let msgs = [];\n    for (let i = 1; i < arguments.length; ++i) {\n        if (arguments[i] !== '') {\n            msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations\n        }\n    }\n\n    msgs = msgs.map((msg) => {\n\n        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);\n    });\n\n    throw new Error(msgs.join(' ') || 'Unknown error');\n};\n\n\nexports.Timer = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Timer.prototype.reset = function () {\n\n    this.ts = Date.now();\n};\n\n\nexports.Timer.prototype.elapsed = function () {\n\n    return Date.now() - this.ts;\n};\n\n\nexports.Bench = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Bench.prototype.reset = function () {\n\n    this.ts = exports.Bench.now();\n};\n\n\nexports.Bench.prototype.elapsed = function () {\n\n    return exports.Bench.now() - this.ts;\n};\n\n\nexports.Bench.now = function () {\n\n    const ts = process.hrtime();\n    return (ts[0] * 1e3) + (ts[1] / 1e6);\n};\n\n\n// Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\n// Base64url (RFC 4648) encode\n\nexports.base64urlEncode = function (value, encoding) {\n\n    const buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));\n    return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n};\n\n\n// Base64url (RFC 4648) decode\n\nexports.base64urlDecode = function (value, encoding) {\n\n    if (value &&\n        !/^[\\w\\-]*$/.test(value)) {\n\n        return new Error('Invalid character');\n    }\n\n    try {\n        const buf = new Buffer(value, 'base64');\n        return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));\n    }\n    catch (err) {\n        return err;\n    }\n};\n\n\n// Escape attribute value for use in HTTP header\n\nexports.escapeHeaderAttribute = function (attribute) {\n\n    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\n    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');                             // Escape quotes and slash\n};\n\n\nexports.escapeHtml = function (string) {\n\n    return Escape.escapeHtml(string);\n};\n\n\nexports.escapeJavaScript = function (string) {\n\n    return Escape.escapeJavaScript(string);\n};\n\n\nexports.nextTick = function (callback) {\n\n    return function () {\n\n        const args = arguments;\n        process.nextTick(() => {\n\n            callback.apply(null, args);\n        });\n    };\n};\n\n\nexports.once = function (method) {\n\n    if (method._hoekOnce) {\n        return method;\n    }\n\n    let once = false;\n    const wrapped = function () {\n\n        if (!once) {\n            once = true;\n            method.apply(null, arguments);\n        }\n    };\n\n    wrapped._hoekOnce = true;\n\n    return wrapped;\n};\n\n\nexports.isAbsolutePath = function (path, platform) {\n\n    if (!path) {\n        return false;\n    }\n\n    if (Path.isAbsolute) {                      // node >= 0.11\n        return Path.isAbsolute(path);\n    }\n\n    platform = platform || process.platform;\n\n    // Unix\n\n    if (platform !== 'win32') {\n        return path[0] === '/';\n    }\n\n    // Windows\n\n    return !!/^(?:[a-zA-Z]:[\\\\\\/])|(?:[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/])/.test(path);        // C:\\ or \\\\something\\something\n};\n\n\nexports.isInteger = function (value) {\n\n    return (typeof value === 'number' &&\n            parseFloat(value) === parseInt(value, 10) &&\n            !isNaN(value));\n};\n\n\nexports.ignore = function () { };\n\n\nexports.inherits = Util.inherits;\n\n\nexports.format = Util.format;\n\n\nexports.transform = function (source, transform, options) {\n\n    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n\n    if (Array.isArray(source)) {\n        const results = [];\n        for (let i = 0; i < source.length; ++i) {\n            results.push(exports.transform(source[i], transform, options));\n        }\n        return results;\n    }\n\n    const result = {};\n    const keys = Object.keys(transform);\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const path = key.split('.');\n        const sourcePath = transform[key];\n\n        exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n\n        let segment;\n        let res = result;\n\n        while (path.length > 1) {\n            segment = path.shift();\n            if (!res[segment]) {\n                res[segment] = {};\n            }\n            res = res[segment];\n        }\n        segment = path.shift();\n        res[segment] = exports.reach(source, sourcePath, options);\n    }\n\n    return result;\n};\n\n\nexports.uniqueFilename = function (path, extension) {\n\n    if (extension) {\n        extension = extension[0] !== '.' ? '.' + extension : extension;\n    }\n    else {\n        extension = '';\n    }\n\n    path = Path.resolve(path);\n    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n    return Path.join(path, name);\n};\n\n\nexports.stringify = function () {\n\n    try {\n        return JSON.stringify.apply(null, arguments);\n    }\n    catch (err) {\n        return '[Cannot display object: ' + err.message + ']';\n    }\n};\n\n\nexports.shallow = function (source) {\n\n    const target = {};\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        target[key] = source[key];\n    }\n\n    return target;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/hoek/lib/index.js\n **/","module.exports = {};\r\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/browser-stub.js\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/webpack/~/node-libs-browser/~/path-browserify/index.js\n **/","module.exports = {\r\n\tinherits: require('inherits'),\r\n};\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/browser-util.js\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/inherits/inherits_browser.js\n **/","'use strict';\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.escapeJavaScript = function (input) {\n\n    if (!input) {\n        return '';\n    }\n\n    let escaped = '';\n\n    for (let i = 0; i < input.length; ++i) {\n\n        const charCode = input.charCodeAt(i);\n\n        if (internals.isSafe(charCode)) {\n            escaped += input[i];\n        }\n        else {\n            escaped += internals.escapeJavaScriptChar(charCode);\n        }\n    }\n\n    return escaped;\n};\n\n\nexports.escapeHtml = function (input) {\n\n    if (!input) {\n        return '';\n    }\n\n    let escaped = '';\n\n    for (let i = 0; i < input.length; ++i) {\n\n        const charCode = input.charCodeAt(i);\n\n        if (internals.isSafe(charCode)) {\n            escaped += input[i];\n        }\n        else {\n            escaped += internals.escapeHtmlChar(charCode);\n        }\n    }\n\n    return escaped;\n};\n\n\ninternals.escapeJavaScriptChar = function (charCode) {\n\n    if (charCode >= 256) {\n        return '\\\\u' + internals.padLeft('' + charCode, 4);\n    }\n\n    const hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');\n    return '\\\\x' + internals.padLeft(hexValue, 2);\n};\n\n\ninternals.escapeHtmlChar = function (charCode) {\n\n    const namedEscape = internals.namedHtml[charCode];\n    if (typeof namedEscape !== 'undefined') {\n        return namedEscape;\n    }\n\n    if (charCode >= 256) {\n        return '&#' + charCode + ';';\n    }\n\n    const hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');\n    return '&#x' + internals.padLeft(hexValue, 2) + ';';\n};\n\n\ninternals.padLeft = function (str, len) {\n\n    while (str.length < len) {\n        str = '0' + str;\n    }\n\n    return str;\n};\n\n\ninternals.isSafe = function (charCode) {\n\n    return (typeof internals.safeCharCodes[charCode] !== 'undefined');\n};\n\n\ninternals.namedHtml = {\n    '38': '&amp;',\n    '60': '&lt;',\n    '62': '&gt;',\n    '34': '&quot;',\n    '160': '&nbsp;',\n    '162': '&cent;',\n    '163': '&pound;',\n    '164': '&curren;',\n    '169': '&copy;',\n    '174': '&reg;'\n};\n\n\ninternals.safeCharCodes = (function () {\n\n    const safe = {};\n\n    for (let i = 32; i < 123; ++i) {\n\n        if ((i >= 97) ||                    // a-z\n            (i >= 65 && i <= 90) ||         // A-Z\n            (i >= 48 && i <= 57) ||         // 0-9\n            i === 32 ||                     // space\n            i === 46 ||                     // .\n            i === 44 ||                     // ,\n            i === 45 ||                     // -\n            i === 58 ||                     // :\n            i === 95) {                     // _\n\n            safe[i] = null;\n        }\n    }\n\n    return safe;\n}());\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/hoek/lib/escape.js\n **/","'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.create = function (key, options) {\n\n    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);\n\n    const settings = Hoek.clone(options);         // options can be reused and modified\n\n    const ref = function (value, validationOptions) {\n\n        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);\n    };\n\n    ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));\n    ref.key = (ref.isContext ? key.slice(1) : key);\n    ref.path = ref.key.split((settings && settings.separator) || '.');\n    ref.depth = ref.path.length;\n    ref.root = ref.path[0];\n    ref.isJoi = true;\n\n    ref.toString = function () {\n\n        return (ref.isContext ? 'context:' : 'ref:') + ref.key;\n    };\n\n    return ref;\n};\n\n\nexports.isRef = function (ref) {\n\n    return typeof ref === 'function' && ref.isJoi;\n};\n\n\nexports.push = function (array, ref) {\n\n    if (exports.isRef(ref) &&\n        !ref.isContext) {\n\n        array.push(ref.root);\n    }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/ref.js\n **/","'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Language = require('./language');\n\n\n// Declare internals\n\nconst internals = {};\n\ninternals.stringify = function (value, wrapArrays) {\n\n    const type = typeof value;\n\n    if (value === null) {\n        return 'null';\n    }\n\n    if (type === 'string') {\n        return value;\n    }\n\n    if (value instanceof internals.Err || type === 'function') {\n        return value.toString();\n    }\n\n    if (type === 'object') {\n        if (Array.isArray(value)) {\n            let partial = '';\n\n            for (let i = 0; i < value.length; ++i) {\n                partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);\n            }\n\n            return wrapArrays ? '[' + partial + ']' : partial;\n        }\n\n        return value.toString();\n    }\n\n    return JSON.stringify(value);\n};\n\ninternals.Err = function (type, context, state, options) {\n\n    this.type = type;\n    this.context = context || {};\n    this.context.key = state.key;\n    this.path = state.path;\n    this.options = options;\n};\n\n\ninternals.Err.prototype.toString = function () {\n\n    const localized = this.options.language;\n\n    if (localized.label) {\n        this.context.key = localized.label;\n    }\n    else if (this.context.key === '' || this.context.key === null) {\n        this.context.key = localized.root || Language.errors.root;\n    }\n\n    let format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);\n    const hasKey = /\\{\\{\\!?key\\}\\}/.test(format);\n    const skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';\n\n    if (skipKey) {\n        format = format.slice(2);\n    }\n\n    if (!hasKey && !skipKey) {\n        format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;\n    }\n\n    let wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');\n    if (typeof wrapArrays !== 'boolean') {\n        wrapArrays = Language.errors.messages.wrapArrays;\n    }\n\n    const message = format.replace(/\\{\\{(\\!?)([^}]+)\\}\\}/g, ($0, isSecure, name) => {\n\n        const value = Hoek.reach(this.context, name);\n        const normalized = internals.stringify(value, wrapArrays);\n        return (isSecure ? Hoek.escapeHtml(normalized) : normalized);\n    });\n\n    return message;\n};\n\n\nexports.create = function (type, context, state, options) {\n\n    return new internals.Err(type, context, state, options);\n};\n\n\nexports.process = function (errors, object) {\n\n    if (!errors || !errors.length) {\n        return null;\n    }\n\n    // Construct error\n\n    let message = '';\n    const details = [];\n\n    const processErrors = function (localErrors, parent) {\n\n        for (let i = 0; i < localErrors.length; ++i) {\n            const item = localErrors[i];\n\n            const detail = {\n                message: item.toString(),\n                path: internals.getPath(item),\n                type: item.type,\n                context: item.context\n            };\n\n            if (!parent) {\n                message = message + (message ? '. ' : '') + detail.message;\n            }\n\n            // Do not push intermediate errors, we're only interested in leafs\n            if (item.context.reason && item.context.reason.length) {\n                processErrors(item.context.reason, item.path);\n            }\n            else {\n                details.push(detail);\n            }\n        }\n    };\n\n    processErrors(errors);\n\n    const error = new Error(message);\n    error.name = 'ValidationError';\n    error.details = details;\n    error._object = object;\n    error.annotate = internals.annotate;\n    return error;\n};\n\n\ninternals.getPath = function (item) {\n\n    const recursePath = (it) => {\n\n        const reachedItem = Hoek.reach(it, 'context.reason.0');\n        if (reachedItem && reachedItem.context) {\n            return recursePath(reachedItem);\n        }\n\n        return it.path;\n    };\n\n    return recursePath(item) || item.context.key;\n};\n\n\n// Inspired by json-stringify-safe\ninternals.safeStringify = function (obj, spaces) {\n\n    return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\ninternals.serializer = function () {\n\n    const keys = [];\n    const stack = [];\n\n    const cycleReplacer = (key, value) => {\n\n        if (stack[0] === value) {\n            return '[Circular ~]';\n        }\n\n        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n    };\n\n    return function (key, value) {\n\n        if (stack.length > 0) {\n            const thisPos = stack.indexOf(this);\n            if (~thisPos) {\n                stack.length = thisPos + 1;\n                keys.length = thisPos + 1;\n                keys[thisPos] = key;\n            }\n            else {\n                stack.push(this);\n                keys.push(key);\n            }\n\n            if (~stack.indexOf(value)) {\n                value = cycleReplacer.call(this, key, value);\n            }\n        }\n        else {\n            stack.push(value);\n        }\n\n        if (Array.isArray(value) && value.placeholders) {\n            const placeholders = value.placeholders;\n            const arrWithPlaceholders = [];\n            for (let i = 0; i < value.length; ++i) {\n                if (placeholders[i]) {\n                    arrWithPlaceholders.push(placeholders[i]);\n                }\n                arrWithPlaceholders.push(value[i]);\n            }\n\n            value = arrWithPlaceholders;\n        }\n\n        return value;\n    };\n};\n\n\ninternals.annotate = function () {\n\n    if (typeof this._object !== 'object') {\n        return this.details[0].message;\n    }\n\n    const obj = Hoek.clone(this._object || {});\n\n    const lookup = {};\n    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first\n        const pos = this.details.length - i;\n        const error = this.details[i];\n        const path = error.path.split('.');\n        let ref = obj;\n        for (let j = 0; j < path.length && ref; ++j) {\n            const seg = path[j];\n            if (j + 1 < path.length) {\n                ref = ref[seg];\n            }\n            else {\n                const value = ref[seg];\n                if (Array.isArray(ref)) {\n                    const arrayLabel = '_$idx$_' + (i + 1) + '_$end$_';\n                    if (!ref.placeholders) {\n                        ref.placeholders = {};\n                    }\n\n                    if (ref.placeholders[seg]) {\n                        ref.placeholders[seg] = ref.placeholders[seg].replace('_$end$_', ', ' + (i + 1) + '_$end$_');\n                    }\n                    else {\n                        ref.placeholders[seg] = arrayLabel;\n                    }\n                }\n                else {\n                    if (value !== undefined) {\n                        delete ref[seg];\n                        const objectLabel = seg + '_$key$_' + pos + '_$end$_';\n                        ref[objectLabel] = value;\n                        lookup[error.path] = objectLabel;\n                    }\n                    else if (lookup[error.path]) {\n                        const replacement = lookup[error.path];\n                        const appended = replacement.replace('_$end$_', ', ' + pos + '_$end$_');\n                        ref[appended] = ref[replacement];\n                        lookup[error.path] = appended;\n                        delete ref[replacement];\n                    }\n                    else {\n                        ref['_$miss$_' + seg + '|' + pos + '_$end$_'] = '__missing__';\n                    }\n                }\n            }\n        }\n    }\n\n    let message = internals.safeStringify(obj, 2)\n        .replace(/_\\$key\\$_([, \\d]+)_\\$end\\$_\\\"/g, ($0, $1) => {\n\n            return '\" \\u001b[31m[' + $1 + ']\\u001b[0m';\n        }).replace(/\\\"_\\$miss\\$_([^\\|]+)\\|(\\d+)_\\$end\\$_\\\"\\: \\\"__missing__\\\"/g, ($0, $1, $2) => {\n\n            return '\\u001b[41m\"' + $1 + '\"\\u001b[0m\\u001b[31m [' + $2 + ']: -- missing --\\u001b[0m';\n        }).replace(/\\s*\\\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\\\",?\\n(.*)/g, ($0, $1, $2) => {\n\n            return '\\n' + $2 + ' \\u001b[31m[' + $1 + ']\\u001b[0m';\n        });\n\n    message = message + '\\n\\u001b[31m';\n\n    for (let i = 0; i < this.details.length; ++i) {\n        message = message + '\\n[' + (i + 1) + '] ' + this.details[i].message;\n    }\n\n    message = message + '\\u001b[0m';\n\n    return message;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/errors.js\n **/","'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.errors = {\n    root: 'value',\n    key: '\"{{!key}}\" ',\n    messages: {\n        wrapArrays: true\n    },\n    any: {\n        unknown: 'is not allowed',\n        invalid: 'contains an invalid value',\n        empty: 'is not allowed to be empty',\n        required: 'is required',\n        allowOnly: 'must be one of {{valids}}',\n        default: 'threw an error when running default method'\n    },\n    alternatives: {\n        base: 'not matching any of the allowed alternatives'\n    },\n    array: {\n        base: 'must be an array',\n        includes: 'at position {{pos}} does not match any of the allowed types',\n        includesSingle: 'single value of \"{{!key}}\" does not match any of the allowed types',\n        includesOne: 'at position {{pos}} fails because {{reason}}',\n        includesOneSingle: 'single value of \"{{!key}}\" fails because {{reason}}',\n        includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',\n        includesRequiredKnowns: 'does not contain {{knownMisses}}',\n        includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',\n        excludes: 'at position {{pos}} contains an excluded value',\n        excludesSingle: 'single value of \"{{!key}}\" contains an excluded value',\n        min: 'must contain at least {{limit}} items',\n        max: 'must contain less than or equal to {{limit}} items',\n        length: 'must contain {{limit}} items',\n        ordered: 'at position {{pos}} fails because {{reason}}',\n        orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',\n        sparse: 'must not be a sparse array',\n        unique: 'position {{pos}} contains a duplicate value'\n    },\n    boolean: {\n        base: 'must be a boolean'\n    },\n    binary: {\n        base: 'must be a buffer or a string',\n        min: 'must be at least {{limit}} bytes',\n        max: 'must be less than or equal to {{limit}} bytes',\n        length: 'must be {{limit}} bytes'\n    },\n    date: {\n        base: 'must be a number of milliseconds or valid date string',\n        min: 'must be larger than or equal to \"{{limit}}\"',\n        max: 'must be less than or equal to \"{{limit}}\"',\n        isoDate: 'must be a valid ISO 8601 date',\n        ref: 'references \"{{ref}}\" which is not a date'\n    },\n    function: {\n        base: 'must be a Function'\n    },\n    object: {\n        base: 'must be an object',\n        child: 'child \"{{!key}}\" fails because {{reason}}',\n        min: 'must have at least {{limit}} children',\n        max: 'must have less than or equal to {{limit}} children',\n        length: 'must have {{limit}} children',\n        allowUnknown: 'is not allowed',\n        with: 'missing required peer \"{{peer}}\"',\n        without: 'conflict with forbidden peer \"{{peer}}\"',\n        missing: 'must contain at least one of {{peers}}',\n        xor: 'contains a conflict between exclusive peers {{peers}}',\n        or: 'must contain at least one of {{peers}}',\n        and: 'contains {{present}} without its required peers {{missing}}',\n        nand: '!!\"{{main}}\" must not exist simultaneously with {{peers}}',\n        assert: '!!\"{{ref}}\" validation failed because \"{{ref}}\" failed to {{message}}',\n        rename: {\n            multiple: 'cannot rename child \"{{from}}\" because multiple renames are disabled and another key was already renamed to \"{{to}}\"',\n            override: 'cannot rename child \"{{from}}\" because override is disabled and target \"{{to}}\" exists'\n        },\n        type: 'must be an instance of \"{{type}}\"'\n    },\n    number: {\n        base: 'must be a number',\n        min: 'must be larger than or equal to {{limit}}',\n        max: 'must be less than or equal to {{limit}}',\n        less: 'must be less than {{limit}}',\n        greater: 'must be greater than {{limit}}',\n        float: 'must be a float or double',\n        integer: 'must be an integer',\n        negative: 'must be a negative number',\n        positive: 'must be a positive number',\n        precision: 'must have no more than {{limit}} decimal places',\n        ref: 'references \"{{ref}}\" which is not a number',\n        multiple: 'must be a multiple of {{multiple}}'\n    },\n    string: {\n        base: 'must be a string',\n        min: 'length must be at least {{limit}} characters long',\n        max: 'length must be less than or equal to {{limit}} characters long',\n        length: 'length must be {{limit}} characters long',\n        alphanum: 'must only contain alpha-numeric characters',\n        token: 'must only contain alpha-numeric and underscore characters',\n        regex: {\n            base: 'with value \"{{!value}}\" fails to match the required pattern: {{pattern}}',\n            name: 'with value \"{{!value}}\" fails to match the {{name}} pattern'\n        },\n        email: 'must be a valid email',\n        uri: 'must be a valid uri',\n        uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',\n        isoDate: 'must be a valid ISO 8601 date',\n        guid: 'must be a valid GUID',\n        hex: 'must only contain hexadecimal characters',\n        hostname: 'must be a valid hostname',\n        lowercase: 'must only contain lowercase characters',\n        uppercase: 'must only contain uppercase characters',\n        trim: 'must not have leading or trailing whitespace',\n        creditCard: 'must be a credit card',\n        ref: 'references \"{{ref}}\" which is not a number',\n        ip: 'must be a valid ip address with a {{cidr}} CIDR',\n        ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'\n    }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/language.js\n **/","'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Ref = require('./ref');\n\n// Type modules are delay-loaded to prevent circular dependencies\n\n\n// Declare internals\n\nconst internals = {\n    any: null,\n    date: require('./date'),\n    string: require('./string'),\n    number: require('./number'),\n    boolean: require('./boolean'),\n    alt: null,\n    object: null\n};\n\n\nexports.schema = function (config) {\n\n    internals.any = internals.any || new (require('./any'))();\n    internals.alt = internals.alt || require('./alternatives');\n    internals.object = internals.object || require('./object');\n\n    if (config &&\n        typeof config === 'object') {\n\n        if (config.isJoi) {\n            return config;\n        }\n\n        if (Array.isArray(config)) {\n            return internals.alt.try(config);\n        }\n\n        if (config instanceof RegExp) {\n            return internals.string.regex(config);\n        }\n\n        if (config instanceof Date) {\n            return internals.date.valid(config);\n        }\n\n        return internals.object.keys(config);\n    }\n\n    if (typeof config === 'string') {\n        return internals.string.valid(config);\n    }\n\n    if (typeof config === 'number') {\n        return internals.number.valid(config);\n    }\n\n    if (typeof config === 'boolean') {\n        return internals.boolean.valid(config);\n    }\n\n    if (Ref.isRef(config)) {\n        return internals.any.valid(config);\n    }\n\n    Hoek.assert(config === null, 'Invalid schema content:', config);\n\n    return internals.any.valid(null);\n};\n\n\nexports.ref = function (id) {\n\n    return Ref.isRef(id) ? id : Ref.create(id);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/cast.js\n **/","'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Errors = require('./errors');\nconst Ref = require('./ref');\nconst Hoek = require('hoek');\nconst Moment = require('moment');\n\n\n// Declare internals\n\nconst internals = {};\n\ninternals.isoDate = /^(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/;\ninternals.invalidDate = new Date('');\ninternals.isIsoDate = (() => {\n\n    const isoString = internals.isoDate.toString();\n\n    return (date) => {\n\n        return date && (date.toString() === isoString);\n    };\n})();\n\ninternals.Date = function () {\n\n    Any.call(this);\n    this._type = 'date';\n};\n\nHoek.inherits(internals.Date, Any);\n\n\ninternals.Date.prototype._base = function (value, state, options) {\n\n    const result = {\n        value: (options.convert && internals.toDate(value, this._flags.format)) || value\n    };\n\n    if (result.value instanceof Date && !isNaN(result.value.getTime())) {\n        result.errors = null;\n    }\n    else {\n        result.errors = Errors.create(internals.isIsoDate(this._flags.format) ? 'date.isoDate' : 'date.base', null, state, options);\n    }\n\n    return result;\n};\n\n\ninternals.toDate = function (value, format) {\n\n    if (value instanceof Date) {\n        return value;\n    }\n\n    if (typeof value === 'string' ||\n        Hoek.isInteger(value)) {\n\n        if (typeof value === 'string' &&\n            /^[+-]?\\d+$/.test(value)) {\n\n            value = parseInt(value, 10);\n        }\n\n        let date;\n        if (format) {\n            if (internals.isIsoDate(format)) {\n                date = format.test(value) ? new Date(value) : internals.invalidDate;\n            }\n            else {\n                date = Moment(value, format, true);\n                date = date.isValid() ? date.toDate() : internals.invalidDate;\n            }\n        }\n        else {\n            date = new Date(value);\n        }\n\n        if (!isNaN(date.getTime())) {\n            return date;\n        }\n    }\n\n    return null;\n};\n\n\ninternals.compare = function (type, compare) {\n\n    return function (date) {\n\n        const isNow = date === 'now';\n        const isRef = Ref.isRef(date);\n\n        if (!isNow && !isRef) {\n            date = internals.toDate(date);\n        }\n\n        Hoek.assert(date, 'Invalid date format');\n\n        return this._test(type, date, (value, state, options) => {\n\n            let compareTo;\n            if (isNow) {\n                compareTo = Date.now();\n            }\n            else if (isRef) {\n                compareTo = internals.toDate(date(state.parent, options));\n\n                if (!compareTo) {\n                    return Errors.create('date.ref', { ref: date.key }, state, options);\n                }\n\n                compareTo = compareTo.getTime();\n            }\n            else {\n                compareTo = date.getTime();\n            }\n\n            if (compare(value.getTime(), compareTo)) {\n                return null;\n            }\n\n            return Errors.create('date.' + type, { limit: new Date(compareTo) }, state, options);\n        });\n    };\n};\n\n\ninternals.Date.prototype.min = internals.compare('min', (value, date) => value >= date);\ninternals.Date.prototype.max = internals.compare('max', (value, date) => value <= date);\n\n\ninternals.Date.prototype.format = function (format) {\n\n    Hoek.assert(typeof format === 'string' || (Array.isArray(format) && format.every((f) => typeof f === 'string')), 'Invalid format.');\n\n    const obj = this.clone();\n    obj._flags.format = format;\n    return obj;\n};\n\ninternals.Date.prototype.iso = function () {\n\n    const obj = this.clone();\n    obj._flags.format = internals.isoDate;\n    return obj;\n};\n\ninternals.Date.prototype._isIsoDate = function (value) {\n\n    return internals.isoDate.test(value);\n};\n\nmodule.exports = new internals.Date();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/date.js\n **/","module.exports = () => ({\r\n\tisValid: () => false\r\n});\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/browser-moment.js\n **/","'use strict';\n\n// Load modules\n\nconst Net = require('net');\nconst Hoek = require('hoek');\nconst Isemail = require('isemail');\nconst Any = require('./any');\nconst Ref = require('./ref');\nconst JoiDate = require('./date');\nconst Errors = require('./errors');\nconst Uri = require('./string/uri');\nconst Ip = require('./string/ip');\n\n// Declare internals\n\nconst internals = {\n    uriRegex: Uri.createUriRegex(),\n    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')\n};\n\ninternals.String = function () {\n\n    Any.call(this);\n    this._type = 'string';\n    this._invalids.add('');\n};\n\nHoek.inherits(internals.String, Any);\n\ninternals.compare = function (type, compare) {\n\n    return function (limit, encoding) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Hoek.isInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        return this._test(type, limit, (value, state, options) => {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.parent, options);\n\n                if (!Hoek.isInteger(compareTo)) {\n                    return Errors.create('string.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo, encoding)) {\n                return null;\n            }\n\n            return Errors.create('string.' + type, { limit: compareTo, value: value, encoding: encoding }, state, options);\n        });\n    };\n};\n\ninternals.String.prototype._base = function (value, state, options) {\n\n    if (typeof value === 'string' &&\n        options.convert) {\n\n        if (this._flags.case) {\n            value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());\n        }\n\n        if (this._flags.trim) {\n            value = value.trim();\n        }\n\n        if (this._inner.replacements) {\n\n            for (let i = 0; i < this._inner.replacements.length; ++i) {\n                const replacement = this._inner.replacements[i];\n                value = value.replace(replacement.pattern, replacement.replacement);\n            }\n        }\n    }\n\n    return {\n        value: value,\n        errors: (typeof value === 'string') ? null : Errors.create('string.base', { value: value }, state, options)\n    };\n};\n\n\ninternals.String.prototype.insensitive = function () {\n\n    const obj = this.clone();\n    obj._flags.insensitive = true;\n    return obj;\n};\n\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length >= limit;\n});\n\n\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length <= limit;\n});\n\n\ninternals.String.prototype.creditCard = function () {\n\n    return this._test('creditCard', undefined, (value, state, options) => {\n\n        let i = value.length;\n        let sum = 0;\n        let mul = 1;\n\n        while (i--) {\n            const char = value.charAt(i) * mul;\n            sum = sum + (char - (char > 9) * 9);\n            mul = mul ^ 3;\n        }\n\n        const check = (sum % 10 === 0) && (sum > 0);\n        return check ? null : Errors.create('string.creditCard', { value: value }, state, options);\n    });\n};\n\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length === limit;\n});\n\n\ninternals.String.prototype.regex = function (pattern, name) {\n\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n\n    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\n\n    return this._test('regex', pattern, (value, state, options) => {\n\n        if (pattern.test(value)) {\n            return null;\n        }\n\n        return Errors.create((name ? 'string.regex.name' : 'string.regex.base'), { name: name, pattern: pattern, value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.alphanum = function () {\n\n    return this._test('alphanum', undefined, (value, state, options) => {\n\n        if (/^[a-zA-Z0-9]+$/.test(value)) {\n            return null;\n        }\n\n        return Errors.create('string.alphanum', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.token = function () {\n\n    return this._test('token', undefined, (value, state, options) => {\n\n        if (/^\\w+$/.test(value)) {\n            return null;\n        }\n\n        return Errors.create('string.token', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.email = function (isEmailOptions) {\n\n    if (isEmailOptions) {\n        Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n        Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n        Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||\n            typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n        Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' ||\n            Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0,\n            'minDomainAtoms must be a positive integer');\n        Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' ||\n            (Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0),\n            'errorLevel must be a non-negative integer or boolean');\n    }\n\n    return this._test('email', isEmailOptions, (value, state, options) => {\n\n        try {\n            const result = Isemail.validate(value, isEmailOptions);\n            if (result === true || result === 0) {\n                return null;\n            }\n        }\n        catch (e) { }\n\n        return Errors.create('string.email', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.ip = function (ipOptions) {\n\n    let regex = internals.ipRegex;\n    ipOptions = ipOptions || {};\n    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n    if (ipOptions.cidr) {\n        Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n        ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\n        Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', '));\n\n        // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n        if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n            regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n        }\n    }\n    else {\n\n        // Set our default cidr strategy\n        ipOptions.cidr = 'optional';\n    }\n\n    let versions;\n    if (ipOptions.version) {\n        if (!Array.isArray(ipOptions.version)) {\n            ipOptions.version = [ipOptions.version];\n        }\n\n        Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\n        versions = [];\n        for (let i = 0; i < ipOptions.version.length; ++i) {\n            let version = ipOptions.version[i];\n            Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n            version = version.toLowerCase();\n            Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n            versions.push(version);\n        }\n\n        // Make sure we have a set of versions\n        versions = Hoek.unique(versions);\n\n        regex = Ip.createIpRegex(versions, ipOptions.cidr);\n    }\n\n    return this._test('ip', ipOptions, (value, state, options) => {\n\n        if (regex.test(value)) {\n            return null;\n        }\n\n        if (versions) {\n            return Errors.create('string.ipVersion', { value: value, cidr: ipOptions.cidr, version: versions }, state, options);\n        }\n\n        return Errors.create('string.ip', { value: value, cidr: ipOptions.cidr }, state, options);\n    });\n};\n\n\ninternals.String.prototype.uri = function (uriOptions) {\n\n    let customScheme = '';\n    let regex = internals.uriRegex;\n\n    if (uriOptions) {\n        Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n        if (uriOptions.scheme) {\n            Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n            if (!Array.isArray(uriOptions.scheme)) {\n                uriOptions.scheme = [uriOptions.scheme];\n            }\n\n            Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n            // Flatten the array into a string to be used to match the schemes.\n            for (let i = 0; i < uriOptions.scheme.length; ++i) {\n                const scheme = uriOptions.scheme[i];\n                Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n                // Add OR separators if a value already exists\n                customScheme = customScheme + (customScheme ? '|' : '');\n\n                // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                if (scheme instanceof RegExp) {\n                    customScheme = customScheme + scheme.source;\n                }\n                else {\n                    Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n                    customScheme = customScheme + Hoek.escapeRegex(scheme);\n                }\n            }\n        }\n    }\n\n    if (customScheme) {\n        regex = Uri.createUriRegex(customScheme);\n    }\n\n    return this._test('uri', uriOptions, (value, state, options) => {\n\n        if (regex.test(value)) {\n            return null;\n        }\n\n        if (customScheme) {\n            return Errors.create('string.uriCustomScheme', { scheme: customScheme, value: value }, state, options);\n        }\n\n        return Errors.create('string.uri', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.isoDate = function () {\n\n    return this._test('isoDate', undefined, (value, state, options) => {\n\n        if (JoiDate._isIsoDate(value)) {\n            return null;\n        }\n\n        return Errors.create('string.isoDate', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.guid = function () {\n\n    const regex = /^[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}$/i;\n    const regex2 = /^\\{[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}\\}$/i;\n\n    return this._test('guid', undefined, (value, state, options) => {\n\n        if (regex.test(value) || regex2.test(value)) {\n            return null;\n        }\n\n        return Errors.create('string.guid', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.hex = function () {\n\n    const regex = /^[a-f0-9]+$/i;\n\n    return this._test('hex', regex, (value, state, options) => {\n\n        if (regex.test(value)) {\n            return null;\n        }\n\n        return Errors.create('string.hex', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.hostname = function () {\n\n    const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\n    return this._test('hostname', undefined, (value, state, options) => {\n\n        if ((value.length <= 255 && regex.test(value)) ||\n            Net.isIPv6(value)) {\n\n            return null;\n        }\n\n        return Errors.create('string.hostname', { value: value }, state, options);\n    });\n};\n\n\ninternals.String.prototype.lowercase = function () {\n\n    const obj = this._test('lowercase', undefined, (value, state, options) => {\n\n        if (options.convert ||\n            value === value.toLocaleLowerCase()) {\n\n            return null;\n        }\n\n        return Errors.create('string.lowercase', { value: value }, state, options);\n    });\n\n    obj._flags.case = 'lower';\n    return obj;\n};\n\n\ninternals.String.prototype.uppercase = function () {\n\n    const obj = this._test('uppercase', undefined, (value, state, options) => {\n\n        if (options.convert ||\n            value === value.toLocaleUpperCase()) {\n\n            return null;\n        }\n\n        return Errors.create('string.uppercase', { value: value }, state, options);\n    });\n\n    obj._flags.case = 'upper';\n    return obj;\n};\n\n\ninternals.String.prototype.trim = function () {\n\n    const obj = this._test('trim', undefined, (value, state, options) => {\n\n        if (options.convert ||\n            value === value.trim()) {\n\n            return null;\n        }\n\n        return Errors.create('string.trim', { value: value }, state, options);\n    });\n\n    obj._flags.trim = true;\n    return obj;\n};\n\n\ninternals.String.prototype.replace = function (pattern, replacement) {\n\n    if (typeof pattern === 'string') {\n        pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n    }\n\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n    // This can not be considere a test like trim, we can't \"reject\"\n    // anything from this rule, so just clone the current object\n    const obj = this.clone();\n\n    if (!obj._inner.replacements) {\n        obj._inner.replacements = [];\n    }\n\n    obj._inner.replacements.push({\n        pattern: pattern,\n        replacement: replacement\n    });\n\n    return obj;\n};\n\nmodule.exports = new internals.String();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/string.js\n **/","module.exports = {\r\n\tisIPv6: require('is-ipv6-node'),\r\n};\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/browser-net.js\n **/","/**\n * @module index\n * @description Entry point for is-ipv6-node module.\n * @version 1.0.6\n * @author Anatoliy Gatt [anatoliy.gatt@aol.com]\n * @copyright Copyright (c) 2015 Anatoliy Gatt\n * @license MIT\n */\n\n'use strict';\n\n/**\n * @public\n * @description Expose function to check if {String} is an IPv6 address.\n * @returns {Function} - Function to check if {String} is an IPv6 address.\n */\n\nmodule.exports = require('./lib/is-ipv6');\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/is-ipv6-node/index.js\n **/","/**\n * @module is-ipv6\n * @description Provides function to check if {String} is an IPv6 address.\n * @version 1.0.6\n * @author Anatoliy Gatt [anatoliy.gatt@aol.com]\n * @copyright Copyright (c) 2015 Anatoliy Gatt\n * @license MIT\n */\n\n'use strict';\n\n/**\n * @public\n * @function isIPv6\n * @description Check if {String} is an IPv6 address.\n * @param {String} string - String to check.\n * @returns {Boolean} - Determine whether a {String} is an IPv6 address.\n */\n\nfunction isIPv6(string) {\n    return !!/(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/.test(string);\n}\n\n/**\n * @public\n * @description Expose function to check if {String} is an IPv6 address.\n * @param {String} string - String to check.\n * @returns {Boolean} - Determine whether a {String} is an IPv6 address.\n */\n\nmodule.exports = function (string) {\n    return isIPv6(string);\n};\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/is-ipv6-node/lib/is-ipv6.js\n **/","'use strict';\r\n\r\n// Load modules\r\n\r\nconst Dns = require('dns');\r\n\r\n\r\n// Declare internals\r\n\r\nconst internals = {\r\n    hasOwn: Object.prototype.hasOwnProperty,\r\n    indexOf: Array.prototype.indexOf,\r\n    defaultThreshold: 16,\r\n    maxIPv6Groups: 8,\r\n\r\n    categories: {\r\n        valid: 1,\r\n        dnsWarn: 7,\r\n        rfc5321: 15,\r\n        cfws: 31,\r\n        deprecated: 63,\r\n        rfc5322: 127,\r\n        error: 255\r\n    },\r\n\r\n    diagnoses: {\r\n\r\n        // Address is valid\r\n\r\n        valid: 0,\r\n\r\n        // Address is valid, but the DNS check failed\r\n\r\n        dnsWarnNoMXRecord: 5,\r\n        dnsWarnNoRecord: 6,\r\n\r\n        // Address is valid for SMTP but has unusual elements\r\n\r\n        rfc5321TLD: 9,\r\n        rfc5321TLDNumeric: 10,\r\n        rfc5321QuotedString: 11,\r\n        rfc5321AddressLiteral: 12,\r\n\r\n        // Address is valid for message, but must be modified for envelope\r\n\r\n        cfwsComment: 17,\r\n        cfwsFWS: 18,\r\n\r\n        // Address contains deprecated elements, but may still be valid in some contexts\r\n\r\n        deprecatedLocalPart: 33,\r\n        deprecatedFWS: 34,\r\n        deprecatedQTEXT: 35,\r\n        deprecatedQP: 36,\r\n        deprecatedComment: 37,\r\n        deprecatedCTEXT: 38,\r\n        deprecatedIPv6: 39,\r\n        deprecatedCFWSNearAt: 49,\r\n\r\n        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\r\n\r\n        rfc5322Domain: 65,\r\n        rfc5322TooLong: 66,\r\n        rfc5322LocalTooLong: 67,\r\n        rfc5322DomainTooLong: 68,\r\n        rfc5322LabelTooLong: 69,\r\n        rfc5322DomainLiteral: 70,\r\n        rfc5322DomainLiteralOBSDText: 71,\r\n        rfc5322IPv6GroupCount: 72,\r\n        rfc5322IPv62x2xColon: 73,\r\n        rfc5322IPv6BadCharacter: 74,\r\n        rfc5322IPv6MaxGroups: 75,\r\n        rfc5322IPv6ColonStart: 76,\r\n        rfc5322IPv6ColonEnd: 77,\r\n\r\n        // Address is invalid for any purpose\r\n\r\n        errExpectingDTEXT: 129,\r\n        errNoLocalPart: 130,\r\n        errNoDomain: 131,\r\n        errConsecutiveDots: 132,\r\n        errATEXTAfterCFWS: 133,\r\n        errATEXTAfterQS: 134,\r\n        errATEXTAfterDomainLiteral: 135,\r\n        errExpectingQPair: 136,\r\n        errExpectingATEXT: 137,\r\n        errExpectingQTEXT: 138,\r\n        errExpectingCTEXT: 139,\r\n        errBackslashEnd: 140,\r\n        errDotStart: 141,\r\n        errDotEnd: 142,\r\n        errDomainHyphenStart: 143,\r\n        errDomainHyphenEnd: 144,\r\n        errUnclosedQuotedString: 145,\r\n        errUnclosedComment: 146,\r\n        errUnclosedDomainLiteral: 147,\r\n        errFWSCRLFx2: 148,\r\n        errFWSCRLFEnd: 149,\r\n        errCRNoLF: 150,\r\n        errUnknownTLD: 160,\r\n        errDomainTooShort: 161\r\n    },\r\n\r\n    components: {\r\n        localpart: 0,\r\n        domain: 1,\r\n        literal: 2,\r\n        contextComment: 3,\r\n        contextFWS: 4,\r\n        contextQuotedString: 5,\r\n        contextQuotedPair: 6\r\n    }\r\n};\r\n\r\n\r\n// $lab:coverage:off$\r\ninternals.defer = typeof process !== 'undefined' && process && typeof process.nextTick === 'function' ?\r\n    process.nextTick.bind(process) :\r\n    function (callback) {\r\n\r\n        return setTimeout(callback, 0);\r\n    };\r\n// $lab:coverage:on$\r\n\r\n\r\ninternals.specials = function () {\r\n\r\n    const specials = '()<>[]:;@\\\\,.\"';        // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\r\n    const lookup = new Array(0x100);\r\n    for (let i = 0xff; i >= 0; --i) {\r\n        lookup[i] = false;\r\n    }\r\n\r\n    for (let i = 0; i < specials.length; ++i) {\r\n        lookup[specials.charCodeAt(i)] = true;\r\n    }\r\n\r\n    const body = 'return function (code) {\\n  return lookup[code];\\n}';\r\n    return (new Function('lookup', body))(lookup);\r\n}();\r\n\r\n\r\ninternals.regex = {\r\n    ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\r\n    ipV6: /^[a-fA-F\\d]{0,4}$/\r\n};\r\n\r\n\r\ninternals.checkIpV6 = function (items) {\r\n\r\n    return items.every((value) => internals.regex.ipV6.test(value));\r\n};\r\n\r\n\r\ninternals.validDomain = function (tldAtom, options) {\r\n\r\n    if (options.tldBlacklist) {\r\n        if (Array.isArray(options.tldBlacklist)) {\r\n            return internals.indexOf.call(options.tldBlacklist, tldAtom) === -1;\r\n        }\r\n\r\n        return !internals.hasOwn.call(options.tldBlacklist, tldAtom);\r\n    }\r\n\r\n    if (Array.isArray(options.tldWhitelist)) {\r\n        return internals.indexOf.call(options.tldWhitelist, tldAtom) !== -1;\r\n    }\r\n\r\n    return internals.hasOwn.call(options.tldWhitelist, tldAtom);\r\n};\r\n\r\n\r\n/**\r\n * Check that an email address conforms to RFCs 5321, 5322 and others\r\n *\r\n * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\r\n * addr-spec as defined by RFC 5322. Depending on the context, either can be\r\n * regarded as a valid email address. The RFC 5321 Mailbox specification is\r\n * more restrictive (comments, white space and obsolete forms are not allowed).\r\n *\r\n * @param {string} email The email address to check. See README for specifics.\r\n * @param {Object} options The (optional) options:\r\n *   {boolean} checkDNS If true then will check DNS for MX records. If\r\n *     true this call to isEmail _will_ be asynchronous.\r\n *   {*} errorLevel Determines the boundary between valid and invalid\r\n *     addresses.\r\n *   {*} tldBlacklist The set of domains to consider invalid.\r\n *   {*} tldWhitelist The set of domains to consider valid.\r\n *   {*} minDomainAtoms The minimum number of domain atoms which must be present\r\n *     for the address to be valid.\r\n * @param {function(number|boolean)} callback The (optional) callback handler.\r\n * @return {*}\r\n */\r\n\r\nexports.validate = internals.validate = function (email, options, callback) {\r\n\r\n    options = options || {};\r\n\r\n    if (typeof options === 'function') {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n\r\n    if (typeof callback !== 'function') {\r\n        if (options.checkDNS) {\r\n            throw new TypeError('expected callback function for checkDNS option');\r\n        }\r\n\r\n        callback = null;\r\n    }\r\n\r\n    let diagnose;\r\n    let threshold;\r\n\r\n    if (typeof options.errorLevel === 'number') {\r\n        diagnose = true;\r\n        threshold = options.errorLevel;\r\n    }\r\n    else {\r\n        diagnose = !!options.errorLevel;\r\n        threshold = internals.diagnoses.valid;\r\n    }\r\n\r\n    if (options.tldWhitelist) {\r\n        if (typeof options.tldWhitelist === 'string') {\r\n            options.tldWhitelist = [options.tldWhitelist];\r\n        }\r\n        else if (typeof options.tldWhitelist !== 'object') {\r\n            throw new TypeError('expected array or object tldWhitelist');\r\n        }\r\n    }\r\n\r\n    if (options.tldBlacklist) {\r\n        if (typeof options.tldBlacklist === 'string') {\r\n            options.tldBlacklist = [options.tldBlacklist];\r\n        }\r\n        else if (typeof options.tldBlacklist !== 'object') {\r\n            throw new TypeError('expected array or object tldBlacklist');\r\n        }\r\n    }\r\n\r\n    if (options.minDomainAtoms && (options.minDomainAtoms !== ((+options.minDomainAtoms) | 0) || options.minDomainAtoms < 0)) {\r\n        throw new TypeError('expected positive integer minDomainAtoms');\r\n    }\r\n\r\n    let maxResult = internals.diagnoses.valid;\r\n    const updateResult = (value) => {\r\n\r\n        if (value > maxResult) {\r\n            maxResult = value;\r\n        }\r\n    };\r\n\r\n    const context = {\r\n        now: internals.components.localpart,\r\n        prev: internals.components.localpart,\r\n        stack: [internals.components.localpart]\r\n    };\r\n\r\n    let prevToken = '';\r\n\r\n    const parseData = {\r\n        local: '',\r\n        domain: ''\r\n    };\r\n    const atomData = {\r\n        locals: [''],\r\n        domains: ['']\r\n    };\r\n\r\n    let elementCount = 0;\r\n    let elementLength = 0;\r\n    let crlfCount = 0;\r\n    let charCode;\r\n\r\n    let hyphenFlag = false;\r\n    let assertEnd = false;\r\n\r\n    const emailLength = email.length;\r\n\r\n    let token;                                      // Token is used outside the loop, must declare similarly\r\n    for (let i = 0; i < emailLength; ++i) {\r\n        token = email[i];\r\n\r\n        switch (context.now) {\r\n            // Local-part\r\n            case internals.components.localpart:\r\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\r\n                //   local-part      =   dot-atom / quoted-string / obs-local-part\r\n                //\r\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\r\n                //\r\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\r\n                //\r\n                //   quoted-string   =   [CFWS]\r\n                //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\r\n                //                       [CFWS]\r\n                //\r\n                //   obs-local-part  =   word *(\".\" word)\r\n                //\r\n                //   word            =   atom / quoted-string\r\n                //\r\n                //   atom            =   [CFWS] 1*atext [CFWS]\r\n                switch (token) {\r\n                    // Comment\r\n                    case '(':\r\n                        if (elementLength === 0) {\r\n                            // Comments are OK at the beginning of an element\r\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\r\n                        }\r\n                        else {\r\n                            updateResult(internals.diagnoses.cfwsComment);\r\n                            // Cannot start a comment in an element, should be end\r\n                            assertEnd = true;\r\n                        }\r\n\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextComment;\r\n                        break;\r\n\r\n                        // Next dot-atom element\r\n                    case '.':\r\n                        if (elementLength === 0) {\r\n                            // Another dot, already?\r\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\r\n                        }\r\n                        else {\r\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\r\n                            if (assertEnd) {\r\n                                updateResult(internals.diagnoses.deprecatedLocalPart);\r\n                            }\r\n\r\n                            // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\r\n                            assertEnd = false;\r\n                            elementLength = 0;\r\n                            ++elementCount;\r\n                            parseData.local += token;\r\n                            atomData.locals[elementCount] = '';\r\n                        }\r\n\r\n                        break;\r\n\r\n                        // Quoted string\r\n                    case '\"':\r\n                        if (elementLength === 0) {\r\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\r\n                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\r\n\r\n                            parseData.local += token;\r\n                            atomData.locals[elementCount] += token;\r\n                            ++elementLength;\r\n\r\n                            // Quoted string must be the entire element\r\n                            assertEnd = true;\r\n                            context.stack.push(context.now);\r\n                            context.now = internals.components.contextQuotedString;\r\n                        }\r\n                        else {\r\n                            updateResult(internals.diagnoses.errExpectingATEXT);\r\n                        }\r\n\r\n                        break;\r\n\r\n                        // Folding white space\r\n                    case '\\r':\r\n                        if (emailLength === ++i || email[i] !== '\\n') {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errCRNoLF);\r\n                            break;\r\n                        }\r\n\r\n                        // Fallthrough\r\n\r\n                    case ' ':\r\n                    case '\\t':\r\n                        if (elementLength === 0) {\r\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\r\n                        }\r\n                        else {\r\n                            // We can't start FWS in the middle of an element, better be end\r\n                            assertEnd = true;\r\n                        }\r\n\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextFWS;\r\n                        prevToken = token;\r\n                        break;\r\n\r\n                    case '@':\r\n                        // At this point we should have a valid local-part\r\n                        // $lab:coverage:off$\r\n                        if (context.stack.length !== 1) {\r\n                            throw new Error('unexpected item on context stack');\r\n                        }\r\n                        // $lab:coverage:on$\r\n\r\n                        if (parseData.local.length === 0) {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errNoLocalPart);\r\n                        }\r\n                        else if (elementLength === 0) {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errDotEnd);\r\n                        }\r\n                            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\r\n                            //    octets\r\n                        else if (parseData.local.length > 64) {\r\n                            updateResult(internals.diagnoses.rfc5322LocalTooLong);\r\n                        }\r\n                            // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\r\n                            //    addr-spec\r\n                            //\r\n                            // http://tools.ietf.org/html/rfc2119\r\n                            // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\r\n                            //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\r\n                            //    and the case carefully weighed before implementing any behavior described with this label.\r\n                        else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\r\n                            updateResult(internals.diagnoses.deprecatedCFWSNearAt);\r\n                        }\r\n\r\n                        // Clear everything down for the domain parsing\r\n                        context.now = internals.components.domain;\r\n                        context.stack[0] = internals.components.domain;\r\n                        elementCount = 0;\r\n                        elementLength = 0;\r\n                        assertEnd = false; // CFWS can only appear at the end of the element\r\n                        break;\r\n\r\n                        // ATEXT\r\n                    default:\r\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\r\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\r\n                        //            \"!\" / \"#\" /     ;  characters not including\r\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\r\n                        //            \"&\" / \"'\" /\r\n                        //            \"*\" / \"+\" /\r\n                        //            \"-\" / \"/\" /\r\n                        //            \"=\" / \"?\" /\r\n                        //            \"^\" / \"_\" /\r\n                        //            \"`\" / \"{\" /\r\n                        //            \"|\" / \"}\" /\r\n                        //            \"~\"\r\n                        if (assertEnd) {\r\n                            // We have encountered atext where it is no longer valid\r\n                            switch (context.prev) {\r\n                                case internals.components.contextComment:\r\n                                case internals.components.contextFWS:\r\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\r\n                                    break;\r\n\r\n                                case internals.components.contextQuotedString:\r\n                                    updateResult(internals.diagnoses.errATEXTAfterQS);\r\n                                    break;\r\n\r\n                                    // $lab:coverage:off$\r\n                                default:\r\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\r\n                                    // $lab:coverage:on$\r\n                            }\r\n                        }\r\n                        else {\r\n                            context.prev = context.now;\r\n                            charCode = token.charCodeAt(0);\r\n\r\n                            // Especially if charCode == 10\r\n                            if (charCode < 33 || charCode > 126 || internals.specials(charCode)) {\r\n\r\n                                // Fatal error\r\n                                updateResult(internals.diagnoses.errExpectingATEXT);\r\n                            }\r\n\r\n                            parseData.local += token;\r\n                            atomData.locals[elementCount] += token;\r\n                            ++elementLength;\r\n                        }\r\n                }\r\n\r\n                break;\r\n\r\n            case internals.components.domain:\r\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\r\n                //   domain          =   dot-atom / domain-literal / obs-domain\r\n                //\r\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\r\n                //\r\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\r\n                //\r\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\r\n                //\r\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\r\n                //                       %d94-126 /         ;  characters not including\r\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\r\n                //\r\n                //   obs-domain      =   atom *(\".\" atom)\r\n                //\r\n                //   atom            =   [CFWS] 1*atext [CFWS]\r\n\r\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\r\n                //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\r\n                //\r\n                //   Domain         = sub-domain *(\".\" sub-domain)\r\n                //\r\n                //   address-literal  = \"[\" ( IPv4-address-literal /\r\n                //                    IPv6-address-literal /\r\n                //                    General-address-literal ) \"]\"\r\n                //                    ; See Section 4.1.3\r\n\r\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\r\n                //      Note: A liberal syntax for the domain portion of addr-spec is\r\n                //      given here.  However, the domain portion contains addressing\r\n                //      information specified by and used in other protocols (e.g.,\r\n                //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\r\n                //      incumbent upon implementations to conform to the syntax of\r\n                //      addresses for the context in which they are used.\r\n                //\r\n                // is_email() author's note: it's not clear how to interpret this in\r\n                // he context of a general email address validator. The conclusion I\r\n                // have reached is this: \"addressing information\" must comply with\r\n                // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\r\n                // invisible\" must comply only with RFC 5322.\r\n                switch (token) {\r\n                    // Comment\r\n                    case '(':\r\n                        if (elementLength === 0) {\r\n                            // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\r\n                            // http://tools.ietf.org/html/rfc5322#section-3.4.1\r\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\r\n                        }\r\n                        else {\r\n                            // We can't start a comment mid-element, better be at the end\r\n                            assertEnd = true;\r\n                            updateResult(internals.diagnoses.cfwsComment);\r\n                        }\r\n\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextComment;\r\n                        break;\r\n\r\n                        // Next dot-atom element\r\n                    case '.':\r\n                        if (elementLength === 0) {\r\n                            // Another dot, already? Fatal error.\r\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\r\n                        }\r\n                        else if (hyphenFlag) {\r\n                            // Previous subdomain ended in a hyphen. Fatal error.\r\n                            updateResult(internals.diagnoses.errDomainHyphenEnd);\r\n                        }\r\n                        else if (elementLength > 63) {\r\n                            // Nowhere in RFC 5321 does it say explicitly that the domain part of a Mailbox must be a valid domain according to the\r\n                            // DNS standards set out in RFC 1035, but this *is* implied in several places. For instance, wherever the idea of host\r\n                            // routing is discussed the RFC says that the domain must be looked up in the DNS. This would be nonsense unless the\r\n                            // domain was designed to be a valid DNS domain. Hence we must conclude that the RFC 1035 restriction on label length\r\n                            // also applies to RFC 5321 domains.\r\n                            //\r\n                            // http://tools.ietf.org/html/rfc1035#section-2.3.4\r\n                            // labels          63 octets or less\r\n\r\n                            updateResult(internals.diagnoses.rfc5322LabelTooLong);\r\n                        }\r\n\r\n                        // CFWS is OK again now we're at the beginning of an element (although\r\n                        // it may be obsolete CFWS)\r\n                        assertEnd = false;\r\n                        elementLength = 0;\r\n                        ++elementCount;\r\n                        atomData.domains[elementCount] = '';\r\n                        parseData.domain += token;\r\n\r\n                        break;\r\n\r\n                        // Domain literal\r\n                    case '[':\r\n                        if (parseData.domain.length === 0) {\r\n                            // Domain literal must be the only component\r\n                            assertEnd = true;\r\n                            ++elementLength;\r\n                            context.stack.push(context.now);\r\n                            context.now = internals.components.literal;\r\n                            parseData.domain += token;\r\n                            atomData.domains[elementCount] += token;\r\n                            parseData.literal = '';\r\n                        }\r\n                        else {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errExpectingATEXT);\r\n                        }\r\n\r\n                        break;\r\n\r\n                        // Folding white space\r\n                    case '\\r':\r\n                        if (emailLength === ++i || email[i] !== '\\n') {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errCRNoLF);\r\n                            break;\r\n                        }\r\n\r\n                        // Fallthrough\r\n\r\n                    case ' ':\r\n                    case '\\t':\r\n                        if (elementLength === 0) {\r\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\r\n                        }\r\n                        else {\r\n                            // We can't start FWS in the middle of an element, so this better be the end\r\n                            updateResult(internals.diagnoses.cfwsFWS);\r\n                            assertEnd = true;\r\n                        }\r\n\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextFWS;\r\n                        prevToken = token;\r\n                        break;\r\n\r\n                        // This must be ATEXT\r\n                    default:\r\n                        // RFC 5322 allows any atext...\r\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\r\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\r\n                        //            \"!\" / \"#\" /     ;  characters not including\r\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\r\n                        //            \"&\" / \"'\" /\r\n                        //            \"*\" / \"+\" /\r\n                        //            \"-\" / \"/\" /\r\n                        //            \"=\" / \"?\" /\r\n                        //            \"^\" / \"_\" /\r\n                        //            \"`\" / \"{\" /\r\n                        //            \"|\" / \"}\" /\r\n                        //            \"~\"\r\n\r\n                        // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\r\n                        //   (RFCs 1034 & 1123)\r\n                        // http://tools.ietf.org/html/rfc5321#section-4.1.2\r\n                        //   sub-domain     = Let-dig [Ldh-str]\r\n                        //\r\n                        //   Let-dig        = ALPHA / DIGIT\r\n                        //\r\n                        //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\r\n                        //\r\n                        if (assertEnd) {\r\n                            // We have encountered ATEXT where it is no longer valid\r\n                            switch (context.prev) {\r\n                                case internals.components.contextComment:\r\n                                case internals.components.contextFWS:\r\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\r\n                                    break;\r\n\r\n                                case internals.components.literal:\r\n                                    updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\r\n                                    break;\r\n\r\n                                    // $lab:coverage:off$\r\n                                default:\r\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\r\n                                    // $lab:coverage:on$\r\n                            }\r\n                        }\r\n\r\n                        charCode = token.charCodeAt(0);\r\n                        // Assume this token isn't a hyphen unless we discover it is\r\n                        hyphenFlag = false;\r\n\r\n                        if (charCode < 33 || charCode > 126 || internals.specials(charCode)) {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errExpectingATEXT);\r\n                        }\r\n                        else if (token === '-') {\r\n                            if (elementLength === 0) {\r\n                                // Hyphens cannot be at the beginning of a subdomain, fatal error\r\n                                updateResult(internals.diagnoses.errDomainHyphenStart);\r\n                            }\r\n\r\n                            hyphenFlag = true;\r\n                        }\r\n                            // Check if it's a neither a number nor a latin letter\r\n                        else if (charCode < 48 || charCode > 122 || (charCode > 57 && charCode < 65) || (charCode > 90 && charCode < 97)) {\r\n                            // This is not an RFC 5321 subdomain, but still OK by RFC 5322\r\n                            updateResult(internals.diagnoses.rfc5322Domain);\r\n                        }\r\n\r\n                        parseData.domain += token;\r\n                        atomData.domains[elementCount] += token;\r\n                        ++elementLength;\r\n                }\r\n\r\n                break;\r\n\r\n                // Domain literal\r\n            case internals.components.literal:\r\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\r\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\r\n                //\r\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\r\n                //                       %d94-126 /         ;  characters not including\r\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\r\n                //\r\n                //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\r\n                switch (token) {\r\n                    // End of domain literal\r\n                    case ']':\r\n                        if (maxResult < internals.categories.deprecated) {\r\n                            // Could be a valid RFC 5321 address literal, so let's check\r\n\r\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.2\r\n                            //   address-literal  = \"[\" ( IPv4-address-literal /\r\n                            //                    IPv6-address-literal /\r\n                            //                    General-address-literal ) \"]\"\r\n                            //                    ; See Section 4.1.3\r\n                            //\r\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.3\r\n                            //   IPv4-address-literal  = Snum 3(\".\"  Snum)\r\n                            //\r\n                            //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\r\n                            //\r\n                            //   General-address-literal  = Standardized-tag \":\" 1*dcontent\r\n                            //\r\n                            //   Standardized-tag  = Ldh-str\r\n                            //                     ; Standardized-tag MUST be specified in a\r\n                            //                     ; Standards-Track RFC and registered with IANA\r\n                            //\r\n                            //   dcontent      = %d33-90 / ; Printable US-ASCII\r\n                            //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\r\n                            //\r\n                            //   Snum          = 1*3DIGIT\r\n                            //                 ; representing a decimal integer\r\n                            //                 ; value in the range 0 through 255\r\n                            //\r\n                            //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\r\n                            //\r\n                            //   IPv6-hex      = 1*4HEXDIG\r\n                            //\r\n                            //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\r\n                            //\r\n                            //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\r\n                            //                 [IPv6-hex *5(\":\" IPv6-hex)]\r\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\r\n                            //                 ; zeros.  No more than 6 groups in addition to the\r\n                            //                 ; \"::\" may be present.\r\n                            //\r\n                            //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\r\n                            //\r\n                            //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\r\n                            //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\r\n                            //                 IPv4-address-literal\r\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\r\n                            //                 ; zeros.  No more than 4 groups in addition to the\r\n                            //                 ; \"::\" and IPv4-address-literal may be present.\r\n\r\n                            let index = -1;\r\n                            let addressLiteral = parseData.literal;\r\n                            const matchesIP = internals.regex.ipV4.exec(addressLiteral);\r\n\r\n                            // Maybe extract IPv4 part from the end of the address-literal\r\n                            if (matchesIP) {\r\n                                index = matchesIP.index;\r\n                                if (index !== 0) {\r\n                                    // Convert IPv4 part to IPv6 format for futher testing\r\n                                    addressLiteral = addressLiteral.slice(0, index) + '0:0';\r\n                                }\r\n                            }\r\n\r\n                            if (index === 0) {\r\n                                // Nothing there except a valid IPv4 address, so...\r\n                                updateResult(internals.diagnoses.rfc5321AddressLiteral);\r\n                            }\r\n                            else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\r\n                                updateResult(internals.diagnoses.rfc5322DomainLiteral);\r\n                            }\r\n                            else {\r\n                                const match = addressLiteral.slice(5);\r\n                                let maxGroups = internals.maxIPv6Groups;\r\n                                const groups = match.split(':');\r\n                                index = match.indexOf('::');\r\n\r\n                                if (!~index) {\r\n                                    // Need exactly the right number of groups\r\n                                    if (groups.length !== maxGroups) {\r\n                                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\r\n                                    }\r\n                                }\r\n                                else if (index !== match.lastIndexOf('::')) {\r\n                                    updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\r\n                                }\r\n                                else {\r\n                                    if (index === 0 || index === match.length - 2) {\r\n                                        // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\r\n                                        ++maxGroups;\r\n                                    }\r\n\r\n                                    if (groups.length > maxGroups) {\r\n                                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\r\n                                    }\r\n                                    else if (groups.length === maxGroups) {\r\n                                        // Eliding a single \"::\"\r\n                                        updateResult(internals.diagnoses.deprecatedIPv6);\r\n                                    }\r\n                                }\r\n\r\n                                // IPv6 testing strategy\r\n                                if (match[0] === ':' && match[1] !== ':') {\r\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\r\n                                }\r\n                                else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\r\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\r\n                                }\r\n                                else if (internals.checkIpV6(groups)) {\r\n                                    updateResult(internals.diagnoses.rfc5321AddressLiteral);\r\n                                }\r\n                                else {\r\n                                    updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            updateResult(internals.diagnoses.rfc5322DomainLiteral);\r\n                        }\r\n\r\n                        parseData.domain += token;\r\n                        atomData.domains[elementCount] += token;\r\n                        ++elementLength;\r\n                        context.prev = context.now;\r\n                        context.now = context.stack.pop();\r\n                        break;\r\n\r\n                    case '\\\\':\r\n                        updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextQuotedPair;\r\n                        break;\r\n\r\n                        // Folding white space\r\n                    case '\\r':\r\n                        if (emailLength === ++i || email[i] !== '\\n') {\r\n                            updateResult(internals.diagnoses.errCRNoLF);\r\n                            break;\r\n                        }\r\n\r\n                        // Fallthrough\r\n\r\n                    case ' ':\r\n                    case '\\t':\r\n                        updateResult(internals.diagnoses.cfwsFWS);\r\n\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextFWS;\r\n                        prevToken = token;\r\n                        break;\r\n\r\n                        // DTEXT\r\n                    default:\r\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1\r\n                        //   dtext         =   %d33-90 /  ; Printable US-ASCII\r\n                        //                     %d94-126 / ;  characters not including\r\n                        //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\r\n                        //\r\n                        //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\r\n                        //\r\n                        //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\r\n                        //                     %d11 /     ;  characters that do not\r\n                        //                     %d12 /     ;  include the carriage\r\n                        //                     %d14-31 /  ;  return, line feed, and\r\n                        //                     %d127      ;  white space characters\r\n                        charCode = token.charCodeAt(0);\r\n\r\n                        // '\\r', '\\n', ' ', and '\\t' have already been parsed above\r\n                        if (charCode > 127 || charCode === 0 || token === '[') {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errExpectingDTEXT);\r\n                            break;\r\n                        }\r\n                        else if (charCode < 33 || charCode === 127) {\r\n                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\r\n                        }\r\n\r\n                        parseData.literal += token;\r\n                        parseData.domain += token;\r\n                        atomData.domains[elementCount] += token;\r\n                        ++elementLength;\r\n                }\r\n\r\n                break;\r\n\r\n                // Quoted string\r\n            case internals.components.contextQuotedString:\r\n                // http://tools.ietf.org/html/rfc5322#section-3.2.4\r\n                //   quoted-string = [CFWS]\r\n                //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\r\n                //                   [CFWS]\r\n                //\r\n                //   qcontent      = qtext / quoted-pair\r\n                switch (token) {\r\n                    // Quoted pair\r\n                    case '\\\\':\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextQuotedPair;\r\n                        break;\r\n\r\n                        // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\r\n                    case '\\r':\r\n                        if (emailLength === ++i || email[i] !== '\\n') {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errCRNoLF);\r\n                            break;\r\n                        }\r\n\r\n                        // Fallthrough\r\n\r\n                    case '\\t':\r\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.2\r\n                        //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\r\n                        //   a structured header field are semantically interpreted as a single\r\n                        //   space character.\r\n\r\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\r\n                        //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\r\n                        //   semantically \"invisible\" and therefore not part of the\r\n                        //   quoted-string\r\n\r\n                        parseData.local += ' ';\r\n                        atomData.locals[elementCount] += ' ';\r\n                        ++elementLength;\r\n\r\n                        updateResult(internals.diagnoses.cfwsFWS);\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextFWS;\r\n                        prevToken = token;\r\n                        break;\r\n\r\n                        // End of quoted string\r\n                    case '\"':\r\n                        parseData.local += token;\r\n                        atomData.locals[elementCount] += token;\r\n                        ++elementLength;\r\n                        context.prev = context.now;\r\n                        context.now = context.stack.pop();\r\n                        break;\r\n\r\n                        // QTEXT\r\n                    default:\r\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\r\n                        //   qtext          =   %d33 /             ; Printable US-ASCII\r\n                        //                      %d35-91 /          ;  characters not including\r\n                        //                      %d93-126 /         ;  \"\\\" or the quote character\r\n                        //                      obs-qtext\r\n                        //\r\n                        //   obs-qtext      =   obs-NO-WS-CTL\r\n                        //\r\n                        //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\r\n                        //                      %d11 /             ;  characters that do not\r\n                        //                      %d12 /             ;  include the carriage\r\n                        //                      %d14-31 /          ;  return, line feed, and\r\n                        //                      %d127              ;  white space characters\r\n                        charCode = token.charCodeAt(0);\r\n\r\n                        if (charCode > 127 || charCode === 0 || charCode === 10) {\r\n                            updateResult(internals.diagnoses.errExpectingQTEXT);\r\n                        }\r\n                        else if (charCode < 32 || charCode === 127) {\r\n                            updateResult(internals.diagnoses.deprecatedQTEXT);\r\n                        }\r\n\r\n                        parseData.local += token;\r\n                        atomData.locals[elementCount] += token;\r\n                        ++elementLength;\r\n                }\r\n\r\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\r\n                //   If the string can be represented as a dot-atom (that is, it contains\r\n                //   no characters other than atext characters or \".\" surrounded by atext\r\n                //   characters), then the dot-atom form SHOULD be used and the quoted-\r\n                //   string form SHOULD NOT be used.\r\n\r\n                break;\r\n                // Quoted pair\r\n            case internals.components.contextQuotedPair:\r\n                // http://tools.ietf.org/html/rfc5322#section-3.2.1\r\n                //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\r\n                //\r\n                //   VCHAR           =  %d33-126   ; visible (printing) characters\r\n                //   WSP             =  SP / HTAB  ; white space\r\n                //\r\n                //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\r\n                //\r\n                //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\r\n                //                       %d11 /    ;  characters that do not\r\n                //                       %d12 /    ;  include the carriage\r\n                //                       %d14-31 / ;  return, line feed, and\r\n                //                       %d127     ;  white space characters\r\n                //\r\n                // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\r\n                charCode = token.charCodeAt(0);\r\n\r\n                if (charCode > 127) {\r\n                    // Fatal error\r\n                    updateResult(internals.diagnoses.errExpectingQPair);\r\n                }\r\n                else if ((charCode < 31 && charCode !== 9) || charCode === 127) {\r\n                    // ' ' and '\\t' are allowed\r\n                    updateResult(internals.diagnoses.deprecatedQP);\r\n                }\r\n\r\n                // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\r\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\r\n                //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\r\n\r\n                context.prev = context.now;\r\n                // End of qpair\r\n                context.now = context.stack.pop();\r\n                token = '\\\\' + token;\r\n\r\n                switch (context.now) {\r\n                    case internals.components.contextComment:\r\n                        break;\r\n\r\n                    case internals.components.contextQuotedString:\r\n                        parseData.local += token;\r\n                        atomData.locals[elementCount] += token;\r\n\r\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\r\n                        elementLength += 2;\r\n                        break;\r\n\r\n                    case internals.components.literal:\r\n                        parseData.domain += token;\r\n                        atomData.domains[elementCount] += token;\r\n\r\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\r\n                        elementLength += 2;\r\n                        break;\r\n\r\n                        // $lab:coverage:off$\r\n                    default:\r\n                        throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\r\n                        // $lab:coverage:on$\r\n                }\r\n                break;\r\n\r\n                // Comment\r\n            case internals.components.contextComment:\r\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\r\n                //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\r\n                //\r\n                //   ccontent = ctext / quoted-pair / comment\r\n                switch (token) {\r\n                    // Nested comment\r\n                    case '(':\r\n                        // Nested comments are ok\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextComment;\r\n                        break;\r\n\r\n                        // End of comment\r\n                    case ')':\r\n                        context.prev = context.now;\r\n                        context.now = context.stack.pop();\r\n                        break;\r\n\r\n                        // Quoted pair\r\n                    case '\\\\':\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextQuotedPair;\r\n                        break;\r\n\r\n                        // Folding white space\r\n                    case '\\r':\r\n                        if (emailLength === ++i || email[i] !== '\\n') {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errCRNoLF);\r\n                            break;\r\n                        }\r\n\r\n                        // Fallthrough\r\n\r\n                    case ' ':\r\n                    case '\\t':\r\n                        updateResult(internals.diagnoses.cfwsFWS);\r\n\r\n                        context.stack.push(context.now);\r\n                        context.now = internals.components.contextFWS;\r\n                        prevToken = token;\r\n                        break;\r\n\r\n                        // CTEXT\r\n                    default:\r\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\r\n                        //   ctext         = %d33-39 /  ; Printable US-ASCII\r\n                        //                   %d42-91 /  ;  characters not including\r\n                        //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\r\n                        //                   obs-ctext\r\n                        //\r\n                        //   obs-ctext     = obs-NO-WS-CTL\r\n                        //\r\n                        //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\r\n                        //                   %d11 /     ;  characters that do not\r\n                        //                   %d12 /     ;  include the carriage\r\n                        //                   %d14-31 /  ;  return, line feed, and\r\n                        //                   %d127      ;  white space characters\r\n                        charCode = token.charCodeAt(0);\r\n\r\n                        if (charCode > 127 || charCode === 0 || charCode === 10) {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errExpectingCTEXT);\r\n                            break;\r\n                        }\r\n                        else if (charCode < 32 || charCode === 127) {\r\n                            updateResult(internals.diagnoses.deprecatedCTEXT);\r\n                        }\r\n                }\r\n\r\n                break;\r\n\r\n                // Folding white space\r\n            case internals.components.contextFWS:\r\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\r\n                //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\r\n                //                                   ; Folding white space\r\n\r\n                // But note the erratum:\r\n                // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\r\n                //   In the obsolete syntax, any amount of folding white space MAY be\r\n                //   inserted where the obs-FWS rule is allowed.  This creates the\r\n                //   possibility of having two consecutive \"folds\" in a line, and\r\n                //   therefore the possibility that a line which makes up a folded header\r\n                //   field could be composed entirely of white space.\r\n                //\r\n                //   obs-FWS =   1*([CRLF] WSP)\r\n\r\n                if (prevToken === '\\r') {\r\n                    if (token === '\\r') {\r\n                        // Fatal error\r\n                        updateResult(internals.diagnoses.errFWSCRLFx2);\r\n                        break;\r\n                    }\r\n\r\n                    if (++crlfCount > 1) {\r\n                        // Multiple folds => obsolete FWS\r\n                        updateResult(internals.diagnoses.deprecatedFWS);\r\n                    }\r\n                    else {\r\n                        crlfCount = 1;\r\n                    }\r\n                }\r\n\r\n                switch (token) {\r\n                    case '\\r':\r\n                        if (emailLength === ++i || email[i] !== '\\n') {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errCRNoLF);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case ' ':\r\n                    case '\\t':\r\n                        break;\r\n\r\n                    default:\r\n                        if (prevToken === '\\r') {\r\n                            // Fatal error\r\n                            updateResult(internals.diagnoses.errFWSCRLFEnd);\r\n                        }\r\n\r\n                        crlfCount = 0;\r\n\r\n                        // End of FWS\r\n                        context.prev = context.now;\r\n                        context.now = context.stack.pop();\r\n\r\n                        // Look at this token again in the parent context\r\n                        --i;\r\n                }\r\n\r\n                prevToken = token;\r\n                break;\r\n\r\n                // Unexpected context\r\n                // $lab:coverage:off$\r\n            default:\r\n                throw new Error('unknown context: ' + context.now);\r\n                // $lab:coverage:on$\r\n        } // Primary state machine\r\n\r\n        if (maxResult > internals.categories.rfc5322) {\r\n            // Fatal error, no point continuing\r\n            break;\r\n        }\r\n    } // Token loop\r\n\r\n    // Check for errors\r\n    if (maxResult < internals.categories.rfc5322) {\r\n        // Fatal errors\r\n        if (context.now === internals.components.contextQuotedString) {\r\n            updateResult(internals.diagnoses.errUnclosedQuotedString);\r\n        }\r\n        else if (context.now === internals.components.contextQuotedPair) {\r\n            updateResult(internals.diagnoses.errBackslashEnd);\r\n        }\r\n        else if (context.now === internals.components.contextComment) {\r\n            updateResult(internals.diagnoses.errUnclosedComment);\r\n        }\r\n        else if (context.now === internals.components.literal) {\r\n            updateResult(internals.diagnoses.errUnclosedDomainLiteral);\r\n        }\r\n        else if (token === '\\r') {\r\n            updateResult(internals.diagnoses.errFWSCRLFEnd);\r\n        }\r\n        else if (parseData.domain.length === 0) {\r\n            updateResult(internals.diagnoses.errNoDomain);\r\n        }\r\n        else if (elementLength === 0) {\r\n            updateResult(internals.diagnoses.errDotEnd);\r\n        }\r\n        else if (hyphenFlag) {\r\n            updateResult(internals.diagnoses.errDomainHyphenEnd);\r\n        }\r\n\r\n            // Other errors\r\n        else if (parseData.domain.length > 255) {\r\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\r\n            //   The maximum total length of a domain name or number is 255 octets.\r\n            updateResult(internals.diagnoses.rfc5322DomainTooLong);\r\n        }\r\n        else if (parseData.local.length + parseData.domain.length + /* '@' */ 1 > 254) {\r\n            // http://tools.ietf.org/html/rfc5321#section-4.1.2\r\n            //   Forward-path   = Path\r\n            //\r\n            //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\r\n            //\r\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\r\n            //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\r\n            //\r\n            // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\r\n            // erratum to RFC 3696:\r\n            //\r\n            // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\r\n            //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\r\n            //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\r\n            //   to be 254.\r\n            updateResult(internals.diagnoses.rfc5322TooLong);\r\n        }\r\n        else if (elementLength > 63) {\r\n            // http://tools.ietf.org/html/rfc1035#section-2.3.4\r\n            // labels   63 octets or less\r\n            updateResult(internals.diagnoses.rfc5322LabelTooLong);\r\n        }\r\n        else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms) {\r\n            updateResult(internals.diagnoses.errDomainTooShort);\r\n        }\r\n        else if (options.tldWhitelist || options.tldBlacklist) {\r\n            const tldAtom = atomData.domains[elementCount];\r\n\r\n            if (!internals.validDomain(tldAtom, options)) {\r\n                updateResult(internals.diagnoses.errUnknownTLD);\r\n            }\r\n        }\r\n    } // Check for errors\r\n\r\n    let dnsPositive = false;\r\n    let finishImmediately = false;\r\n\r\n    const finish = () => {\r\n\r\n        if (!dnsPositive && maxResult < internals.categories.dnsWarn) {\r\n            // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\r\n            const code = atomData.domains[elementCount].charCodeAt(0);\r\n            if (code <= 57) {\r\n                updateResult(internals.diagnoses.rfc5321TLDNumeric);\r\n            }\r\n            else if (elementCount === 0) {\r\n                updateResult(internals.diagnoses.rfc5321TLD);\r\n            }\r\n        }\r\n\r\n        if (maxResult < threshold) {\r\n            maxResult = internals.diagnoses.valid;\r\n        }\r\n\r\n        const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;\r\n\r\n        if (callback) {\r\n            if (finishImmediately) {\r\n                callback(finishResult);\r\n            }\r\n            else {\r\n                internals.defer(callback.bind(null, finishResult));\r\n            }\r\n        }\r\n\r\n        return finishResult;\r\n    }; // Finish\r\n\r\n    if (options.checkDNS && maxResult < internals.categories.dnsWarn) {\r\n        // http://tools.ietf.org/html/rfc5321#section-2.3.5\r\n        //   Names that can be resolved to MX RRs or address (i.e., A or AAAA) RRs (as discussed in Section 5) are permitted, as are CNAME RRs whose\r\n        //   targets can be resolved, in turn, to MX or address RRs.\r\n        //\r\n        // http://tools.ietf.org/html/rfc5321#section-5.1\r\n        //   The lookup first attempts to locate an MX record associated with the name.  If a CNAME record is found, the resulting name is processed\r\n        //   as if it were the initial name. ... If an empty list of MXs is returned, the address is treated as if it was associated with an implicit\r\n        //   MX RR, with a preference of 0, pointing to that host.\r\n        //\r\n        // isEmail() author's note: We will regard the existence of a CNAME to be sufficient evidence of the domain's existence. For performance\r\n        // reasons we will not repeat the DNS lookup for the CNAME's target, but we will raise a warning because we didn't immediately find an MX\r\n        // record.\r\n        if (elementCount === 0) {\r\n            // Checking TLD DNS only works if you explicitly check from the root\r\n            parseData.domain += '.';\r\n        }\r\n\r\n        const dnsDomain = parseData.domain;\r\n        Dns.resolveMx(dnsDomain, (err, mxRecords) => {\r\n\r\n            // If we have a fatal error, then we must assume that there are no records\r\n            if (err && err.code !== Dns.NODATA) {\r\n                updateResult(internals.diagnoses.dnsWarnNoRecord);\r\n                return finish();\r\n            }\r\n\r\n            if (mxRecords && mxRecords.length) {\r\n                dnsPositive = true;\r\n                return finish();\r\n            }\r\n\r\n            let count = 3;\r\n            let done = false;\r\n            updateResult(internals.diagnoses.dnsWarnNoMXRecord);\r\n\r\n            const handleRecords = (err, records) => {\r\n\r\n                if (done) {\r\n                    return;\r\n                }\r\n\r\n                --count;\r\n\r\n                if (records && records.length) {\r\n                    done = true;\r\n                    return finish();\r\n                }\r\n\r\n                if (count === 0) {\r\n                    // No usable records for the domain can be found\r\n                    updateResult(internals.diagnoses.dnsWarnNoRecord);\r\n                    done = true;\r\n                    finish();\r\n                }\r\n            };\r\n\r\n            Dns.resolveCname(dnsDomain, handleRecords);\r\n            Dns.resolve4(dnsDomain, handleRecords);\r\n            Dns.resolve6(dnsDomain, handleRecords);\r\n        });\r\n\r\n        finishImmediately = true;\r\n    }\r\n    else {\r\n        const result = finish();\r\n        finishImmediately = true;\r\n        return result;\r\n    } // CheckDNS\r\n};\r\n\r\n\r\nexports.diagnoses = internals.validate.diagnoses = (function () {\r\n\r\n    const diag = {};\r\n    const keys = Object.keys(internals.diagnoses);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const key = keys[i];\r\n        diag[key] = internals.diagnoses[key];\r\n    }\r\n\r\n    return diag;\r\n})();\r\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/isemail/lib/index.js\n **/","'use strict';\n\n// Load Modules\n\nconst RFC3986 = require('./rfc3986');\n\n\n// Declare internals\n\nconst internals = {\n    Uri: {\n        createUriRegex: function (optionalScheme) {\n\n            let scheme = RFC3986.scheme;\n\n            // If we were passed a scheme, use it instead of the generic one\n            if (optionalScheme) {\n\n                // Have to put this in a non-capturing group to handle the OR statements\n                scheme = '(?:' + optionalScheme + ')';\n            }\n\n            /**\n             * URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n             */\n            return new RegExp('^' + scheme + ':' + RFC3986.hierPart + '(?:\\\\?' + RFC3986.query + ')?' + '(?:#' + RFC3986.fragment + ')?$');\n        }\n    }\n};\n\n\nmodule.exports = internals.Uri;\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/string/uri.js\n **/","'use strict';\n\n// Load modules\n\n\n// Delcare internals\n\nconst internals = {\n    rfc3986: {}\n};\n\n\ninternals.generate = function () {\n\n    /**\n     * elements separated by forward slash (\"/\") are alternatives.\n     */\n    const or = '|';\n\n    /**\n     * DIGIT = %x30-39 ; 0-9\n     */\n    const digit = '0-9';\n    const digitOnly = '[' + digit + ']';\n\n    /**\n     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z\n     */\n    const alpha = 'a-zA-Z';\n    const alphaOnly = '[' + alpha + ']';\n\n    /**\n     * cidr       = DIGIT                ; 0-9\n     *            / %x31-32 DIGIT         ; 10-29\n     *            / \"3\" %x30-32           ; 30-32\n     */\n    internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';\n\n    /**\n     * HEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n     */\n    const hexDigit = digit + 'A-Fa-f';\n    const hexDigitOnly = '[' + hexDigit + ']';\n\n    /**\n     * unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     */\n    const unreserved = alpha + digit + '-\\\\._~';\n\n    /**\n     * sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     */\n    const subDelims = '!\\\\$&\\'\\\\(\\\\)\\\\*\\\\+,;=';\n\n    /**\n     * pct-encoded = \"%\" HEXDIG HEXDIG\n     */\n    const pctEncoded = '%' + hexDigit;\n\n    /**\n     * pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n     */\n    const pchar = unreserved + pctEncoded + subDelims + ':@';\n    const pcharOnly = '[' + pchar + ']';\n\n    /**\n     * Rule to support zero-padded addresses.\n     */\n    const zeroPad = '0?';\n\n    /**\n     * dec-octet   = DIGIT                 ; 0-9\n     *            / %x31-39 DIGIT         ; 10-99\n     *            / \"1\" 2DIGIT            ; 100-199\n     *            / \"2\" %x30-34 DIGIT     ; 200-249\n     *            / \"25\" %x30-35          ; 250-255\n     */\n    const decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';\n\n    /**\n     * IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n     */\n    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\\\.){3}' + decOctect;\n\n    /**\n     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal\n     * ls32 = ( h16 \":\" h16 ) / IPv4address ; least-significant 32 bits of address\n     * IPv6address =                            6( h16 \":\" ) ls32\n     *             /                       \"::\" 5( h16 \":\" ) ls32\n     *             / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n     *             / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n     *             / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n     *             / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n     *             / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n     *             / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n     *             / [ *6( h16 \":\" ) h16 ] \"::\"\n     */\n    const h16 = hexDigitOnly + '{1,4}';\n    const ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';\n    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;\n    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;\n    const IPv6FourHex = h16 + '::(?:' + h16 + ':){4}' + ls32;\n    const IPv6ThreeHex = '(?:' + h16 + ':){0,1}' + h16 + '::(?:' + h16 + ':){3}' + ls32;\n    const IPv6TwoHex = '(?:' + h16 + ':){0,2}' + h16 + '::(?:' + h16 + ':){2}' + ls32;\n    const IPv6OneHex = '(?:' + h16 + ':){0,3}' + h16 + '::' + h16 + ':' + ls32;\n    const IPv6NoneHex = '(?:' + h16 + ':){0,4}' + h16 + '::' + ls32;\n    const IPv6NoneHex2 = '(?:' + h16 + ':){0,5}' + h16 + '::' + h16;\n    const IPv6NoneHex3 = '(?:' + h16 + ':){0,6}' + h16 + '::';\n    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';\n\n    /**\n     * IPvFuture = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n     */\n    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\\\.[' + unreserved + subDelims + ':]+';\n\n    /**\n     * scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n     */\n    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\\\.]*';\n\n    /**\n     * userinfo = *( unreserved / pct-encoded / sub-delims / \":\" )\n     */\n    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';\n\n    /**\n     * IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n     */\n    const IPLiteral = '\\\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\\\]';\n\n    /**\n     * reg-name = *( unreserved / pct-encoded / sub-delims )\n     */\n    const regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';\n\n    /**\n     * host = IP-literal / IPv4address / reg-name\n     */\n    const host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';\n\n    /**\n     * port = *DIGIT\n     */\n    const port = digitOnly + '*';\n\n    /**\n     * authority   = [ userinfo \"@\" ] host [ \":\" port ]\n     */\n    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';\n\n    /**\n     * segment       = *pchar\n     * segment-nz    = 1*pchar\n     * path          = path-abempty    ; begins with \"/\" or is empty\n     *               / path-absolute   ; begins with \"/\" but not \"//\"\n     *               / path-noscheme   ; begins with a non-colon segment\n     *               / path-rootless   ; begins with a segment\n     *               / path-empty      ; zero characters\n     * path-abempty  = *( \"/\" segment )\n     * path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n     * path-rootless = segment-nz *( \"/\" segment )\n     */\n    const segment = pcharOnly + '*';\n    const segmentNz = pcharOnly + '+';\n    const pathAbEmpty = '(?:\\\\/' + segment + ')*';\n    const pathAbsolute = '\\\\/(?:' + segmentNz + pathAbEmpty + ')?';\n    const pathRootless = segmentNz + pathAbEmpty;\n\n    /**\n     * hier-part = \"//\" authority path\n     */\n    internals.rfc3986.hierPart = '(?:\\\\/\\\\/' + authority + pathAbEmpty + or + pathAbsolute + or + pathRootless + ')';\n\n    /**\n     * query = *( pchar / \"/\" / \"?\" )\n     */\n    internals.rfc3986.query = '[' + pchar + '\\\\/\\\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.\n\n    /**\n     * fragment = *( pchar / \"/\" / \"?\" )\n     */\n    internals.rfc3986.fragment = '[' + pchar + '\\\\/\\\\?]*';\n};\n\n\ninternals.generate();\n\nmodule.exports = internals.rfc3986;\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/string/rfc3986.js\n **/","'use strict';\n\n// Load modules\n\nconst RFC3986 = require('./rfc3986');\n\n\n// Declare internals\n\nconst internals = {\n    Ip: {\n        cidrs: {\n            required: '\\\\/(?:' + RFC3986.cidr + ')',\n            optional: '(?:\\\\/(?:' + RFC3986.cidr + '))?',\n            forbidden: ''\n        },\n        versions: {\n            ipv4: RFC3986.IPv4address,\n            ipv6: RFC3986.IPv6address,\n            ipvfuture: RFC3986.IPvFuture\n        }\n    }\n};\n\n\ninternals.Ip.createIpRegex = function (versions, cidr) {\n\n    let regex;\n    for (let i = 0; i < versions.length; ++i) {\n        const version = versions[i];\n        if (!regex) {\n            regex = '^(?:' + internals.Ip.versions[version];\n        }\n        regex = regex + '|' + internals.Ip.versions[version];\n    }\n\n    return new RegExp(regex + ')' + internals.Ip.cidrs[cidr] + '$');\n};\n\nmodule.exports = internals.Ip;\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/string/ip.js\n **/","'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Ref = require('./ref');\nconst Errors = require('./errors');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Number = function () {\n\n    Any.call(this);\n    this._type = 'number';\n    this._invalids.add(Infinity);\n    this._invalids.add(-Infinity);\n};\n\nHoek.inherits(internals.Number, Any);\n\ninternals.compare = function (type, compare) {\n\n    return function (limit) {\n\n        const isRef = Ref.isRef(limit);\n        const isNumber = typeof limit === 'number' && !isNaN(limit);\n\n        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');\n\n        return this._test(type, limit, (value, state, options) => {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.parent, options);\n\n                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {\n                    return Errors.create('number.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo)) {\n                return null;\n            }\n\n            return Errors.create('number.' + type, { limit: compareTo, value: value }, state, options);\n        });\n    };\n};\n\n\ninternals.Number.prototype._base = function (value, state, options) {\n\n    const result = {\n        errors: null,\n        value: value\n    };\n\n    if (typeof value === 'string' &&\n        options.convert) {\n\n        const number = parseFloat(value);\n        result.value = (isNaN(number) || !isFinite(value)) ? NaN : number;\n    }\n\n    const isNumber = typeof result.value === 'number' && !isNaN(result.value);\n\n    if (options.convert && 'precision' in this._flags && isNumber) {\n\n        // This is conceptually equivalent to using toFixed but it should be much faster\n        const precision = Math.pow(10, this._flags.precision);\n        result.value = Math.round(result.value * precision) / precision;\n    }\n\n    result.errors = isNumber ? null : Errors.create('number.base', null, state, options);\n    return result;\n};\n\n\ninternals.Number.prototype.min = internals.compare('min', (value, limit) => value >= limit);\ninternals.Number.prototype.max = internals.compare('max', (value, limit) => value <= limit);\ninternals.Number.prototype.greater = internals.compare('greater', (value, limit) => value > limit);\ninternals.Number.prototype.less = internals.compare('less', (value, limit) => value < limit);\n\n\ninternals.Number.prototype.multiple = function (base) {\n\n    Hoek.assert(Hoek.isInteger(base), 'multiple must be an integer');\n    Hoek.assert(base > 0, 'multiple must be greater than 0');\n\n    return this._test('multiple', base, (value, state, options) => {\n\n        if (value % base === 0) {\n            return null;\n        }\n\n        return Errors.create('number.multiple', { multiple: base, value: value }, state, options);\n    });\n};\n\n\ninternals.Number.prototype.integer = function () {\n\n    return this._test('integer', undefined, (value, state, options) => {\n\n        return Hoek.isInteger(value) ? null : Errors.create('number.integer', { value: value }, state, options);\n    });\n};\n\n\ninternals.Number.prototype.negative = function () {\n\n    return this._test('negative', undefined, (value, state, options) => {\n\n        if (value < 0) {\n            return null;\n        }\n\n        return Errors.create('number.negative', { value: value }, state, options);\n    });\n};\n\n\ninternals.Number.prototype.positive = function () {\n\n    return this._test('positive', undefined, (value, state, options) => {\n\n        if (value > 0) {\n            return null;\n        }\n\n        return Errors.create('number.positive', { value: value }, state, options);\n    });\n};\n\n\ninternals.precisionRx = /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/;\n\n\ninternals.Number.prototype.precision = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');\n    Hoek.assert(!('precision' in this._flags), 'precision already set');\n\n    const obj = this._test('precision', limit, (value, state, options) => {\n\n        const places = value.toString().match(internals.precisionRx);\n        const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n        if (decimals <= limit) {\n            return null;\n        }\n\n        return Errors.create('number.precision', { limit: limit, value: value }, state, options);\n    });\n\n    obj._flags.precision = limit;\n    return obj;\n};\n\n\nmodule.exports = new internals.Number();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/number.js\n **/","'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Errors = require('./errors');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Boolean = function () {\n\n    Any.call(this);\n    this._type = 'boolean';\n};\n\nHoek.inherits(internals.Boolean, Any);\n\n\ninternals.Boolean.prototype._base = function (value, state, options) {\n\n    const result = {\n        value: value\n    };\n\n    if (typeof value === 'string' &&\n        options.convert) {\n\n        const lower = value.toLowerCase();\n        result.value = (lower === 'true' || lower === 'yes' || lower === 'on' ? true\n                                                                              : (lower === 'false' || lower === 'no' || lower === 'off' ? false : value));\n    }\n\n    result.errors = (typeof result.value === 'boolean') ? null : Errors.create('boolean.base', null, state, options);\n    return result;\n};\n\n\nmodule.exports = new internals.Boolean();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/boolean.js\n **/","'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Any = require('./any');\nconst Cast = require('./cast');\nconst Ref = require('./ref');\nconst Errors = require('./errors');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Alternatives = function () {\n\n    Any.call(this);\n    this._type = 'alternatives';\n    this._invalids.remove(null);\n\n    this._inner.matches = [];\n};\n\nHoek.inherits(internals.Alternatives, Any);\n\n\ninternals.Alternatives.prototype._base = function (value, state, options) {\n\n    let errors = [];\n    for (let i = 0; i < this._inner.matches.length; ++i) {\n        const item = this._inner.matches[i];\n        let schema = item.schema;\n        if (!schema) {\n            const failed = item.is._validate(item.ref(state.parent, options), null, options, state.parent).errors;\n            schema = failed ? item.otherwise : item.then;\n            if (!schema) {\n                continue;\n            }\n        }\n\n        const result = schema._validate(value, state, options);\n        if (!result.errors) {     // Found a valid match\n            return result;\n        }\n\n        errors = errors.concat(result.errors);\n    }\n\n    return { errors: errors.length ? errors : Errors.create('alternatives.base', null, state, options) };\n};\n\n\ninternals.Alternatives.prototype.try = function (/* schemas */) {\n\n\n    const schemas = Hoek.flatten(Array.prototype.slice.call(arguments));\n    Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n\n    const obj = this.clone();\n\n    for (let i = 0; i < schemas.length; ++i) {\n        const cast = Cast.schema(schemas[i]);\n        if (cast._refs.length) {\n            obj._refs = obj._refs.concat(cast._refs);\n        }\n        obj._inner.matches.push({ schema: cast });\n    }\n\n    return obj;\n};\n\n\ninternals.Alternatives.prototype.when = function (ref, options) {\n\n    Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);\n    Hoek.assert(options, 'Missing options');\n    Hoek.assert(typeof options === 'object', 'Invalid options');\n    Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n    const obj = this.clone();\n    let is = Cast.schema(options.is);\n\n    if (options.is === null || !options.is.isJoi) {\n\n        // Only apply required if this wasn't already a schema, we'll suppose people know what they're doing\n        is = is.required();\n    }\n\n    const item = {\n        ref: Cast.ref(ref),\n        is: is,\n        then: options.then !== undefined ? Cast.schema(options.then) : undefined,\n        otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined\n    };\n\n    Ref.push(obj._refs, item.ref);\n    obj._refs = obj._refs.concat(item.is._refs);\n\n    if (item.then && item.then._refs) {\n        obj._refs = obj._refs.concat(item.then._refs);\n    }\n\n    if (item.otherwise && item.otherwise._refs) {\n        obj._refs = obj._refs.concat(item.otherwise._refs);\n    }\n\n    obj._inner.matches.push(item);\n\n    return obj;\n};\n\n\ninternals.Alternatives.prototype.describe = function () {\n\n    const description = Any.prototype.describe.call(this);\n    const alternatives = [];\n    for (let i = 0; i < this._inner.matches.length; ++i) {\n        const item = this._inner.matches[i];\n        if (item.schema) {\n\n            // try()\n\n            alternatives.push(item.schema.describe());\n        }\n        else {\n\n            // when()\n\n            const when = {\n                ref: item.ref.toString(),\n                is: item.is.describe()\n            };\n\n            if (item.then) {\n                when.then = item.then.describe();\n            }\n\n            if (item.otherwise) {\n                when.otherwise = item.otherwise.describe();\n            }\n\n            alternatives.push(when);\n        }\n    }\n\n    description.alternatives = alternatives;\n    return description;\n};\n\n\nmodule.exports = new internals.Alternatives();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/alternatives.js\n **/","'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Topo = require('topo');\nconst Any = require('./any');\nconst Cast = require('./cast');\nconst Errors = require('./errors');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Object = function () {\n\n    Any.call(this);\n    this._type = 'object';\n    this._inner.children = null;\n    this._inner.renames = [];\n    this._inner.dependencies = [];\n    this._inner.patterns = [];\n};\n\nHoek.inherits(internals.Object, Any);\n\n\ninternals.Object.prototype._base = function (value, state, options) {\n\n    let target = value;\n    const errors = [];\n    const finish = () => {\n\n        return {\n            value: target,\n            errors: errors.length ? errors : null\n        };\n    };\n\n    if (typeof value === 'string' &&\n        options.convert) {\n\n        try {\n            value = JSON.parse(value);\n        }\n        catch (parseErr) { }\n    }\n\n    const type = this._flags.func ? 'function' : 'object';\n    if (!value ||\n        typeof value !== type ||\n        Array.isArray(value)) {\n\n        errors.push(Errors.create(type + '.base', null, state, options));\n        return finish();\n    }\n\n    // Skip if there are no other rules to test\n\n    if (!this._inner.renames.length &&\n        !this._inner.dependencies.length &&\n        !this._inner.children &&                    // null allows any keys\n        !this._inner.patterns.length) {\n\n        target = value;\n        return finish();\n    }\n\n    // Ensure target is a local copy (parsed) or shallow copy\n\n    if (target === value) {\n        if (type === 'object') {\n            target = Object.create(Object.getPrototypeOf(value));\n        }\n        else {\n            target = function () {\n\n                return value.apply(this, arguments);\n            };\n\n            target.prototype = Hoek.clone(value.prototype);\n        }\n\n        const valueKeys = Object.keys(value);\n        for (let i = 0; i < valueKeys.length; ++i) {\n            target[valueKeys[i]] = value[valueKeys[i]];\n        }\n    }\n    else {\n        target = value;\n    }\n\n    // Rename keys\n\n    const renamed = {};\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n        const item = this._inner.renames[i];\n\n        if (item.options.ignoreUndefined && target[item.from] === undefined) {\n            continue;\n        }\n\n        if (!item.options.multiple &&\n            renamed[item.to]) {\n\n            errors.push(Errors.create('object.rename.multiple', { from: item.from, to: item.to }, state, options));\n            if (options.abortEarly) {\n                return finish();\n            }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(target, item.to) &&\n            !item.options.override &&\n            !renamed[item.to]) {\n\n            errors.push(Errors.create('object.rename.override', { from: item.from, to: item.to }, state, options));\n            if (options.abortEarly) {\n                return finish();\n            }\n        }\n\n        if (target[item.from] === undefined) {\n            delete target[item.to];\n        }\n        else {\n            target[item.to] = target[item.from];\n        }\n\n        renamed[item.to] = true;\n\n        if (!item.options.alias) {\n            delete target[item.from];\n        }\n    }\n\n    // Validate schema\n\n    if (!this._inner.children &&            // null allows any keys\n        !this._inner.patterns.length &&\n        !this._inner.dependencies.length) {\n\n        return finish();\n    }\n\n    const unprocessed = Hoek.mapToObject(Object.keys(target));\n\n    if (this._inner.children) {\n        for (let i = 0; i < this._inner.children.length; ++i) {\n            const child = this._inner.children[i];\n            const key = child.key;\n            const item = target[key];\n\n            delete unprocessed[key];\n\n            const localState = { key: key, path: (state.path || '') + (state.path && key ? '.' : '') + key, parent: target, reference: state.reference };\n            const result = child.schema._validate(item, localState, options);\n            if (result.errors) {\n                errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));\n\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n\n            if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                delete target[key];\n            }\n            else if (result.value !== undefined) {\n                target[key] = result.value;\n            }\n        }\n    }\n\n    // Unknown keys\n\n    let unprocessedKeys = Object.keys(unprocessed);\n    if (unprocessedKeys.length &&\n        this._inner.patterns.length) {\n\n        for (let i = 0; i < unprocessedKeys.length; ++i) {\n            const key = unprocessedKeys[i];\n\n            for (let j = 0; j < this._inner.patterns.length; ++j) {\n                const pattern = this._inner.patterns[j];\n\n                if (pattern.regex.test(key)) {\n                    delete unprocessed[key];\n\n                    const item = target[key];\n                    const localState = { key: key, path: (state.path ? state.path + '.' : '') + key, parent: target, reference: state.reference };\n                    const result = pattern.rule._validate(item, localState, options);\n                    if (result.errors) {\n                        errors.push(Errors.create('object.child', { key: key, reason: result.errors }, localState, options));\n\n                        if (options.abortEarly) {\n                            return finish();\n                        }\n                    }\n\n                    if (result.value !== undefined) {\n                        target[key] = result.value;\n                    }\n                }\n            }\n        }\n\n        unprocessedKeys = Object.keys(unprocessed);\n    }\n\n    if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {\n        if (options.stripUnknown ||\n            options.skipFunctions) {\n\n            for (let i = 0; i < unprocessedKeys.length; ++i) {\n                const key = unprocessedKeys[i];\n\n                if (options.stripUnknown) {\n                    delete target[key];\n                    delete unprocessed[key];\n                }\n                else if (typeof target[key] === 'function') {\n                    delete unprocessed[key];\n                }\n            }\n\n            unprocessedKeys = Object.keys(unprocessed);\n        }\n\n        if (unprocessedKeys.length &&\n            (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n            for (let i = 0; i < unprocessedKeys.length; ++i) {\n                errors.push(Errors.create('object.allowUnknown', null, { key: unprocessedKeys[i], path: state.path + (state.path ? '.' : '') + unprocessedKeys[i] }, options));\n            }\n        }\n    }\n\n    // Validate dependencies\n\n    for (let i = 0; i < this._inner.dependencies.length; ++i) {\n        const dep = this._inner.dependencies[i];\n        const err = internals[dep.type](dep.key !== null && value[dep.key], dep.peers, target, { key: dep.key, path: (state.path || '') + (dep.key ? '.' + dep.key : '') }, options);\n        if (err) {\n            errors.push(err);\n            if (options.abortEarly) {\n                return finish();\n            }\n        }\n    }\n\n    return finish();\n};\n\n\ninternals.Object.prototype._func = function () {\n\n    const obj = this.clone();\n    obj._flags.func = true;\n    return obj;\n};\n\n\ninternals.Object.prototype.keys = function (schema) {\n\n    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n    Hoek.assert(!schema || !schema.isJoi, 'Object schema cannot be a joi schema');\n\n    const obj = this.clone();\n\n    if (!schema) {\n        obj._inner.children = null;\n        return obj;\n    }\n\n    const children = Object.keys(schema);\n\n    if (!children.length) {\n        obj._inner.children = [];\n        return obj;\n    }\n\n    const topo = new Topo();\n    if (obj._inner.children) {\n        for (let i = 0; i < obj._inner.children.length; ++i) {\n            const child = obj._inner.children[i];\n\n            // Only add the key if we are not going to replace it later\n            if (children.indexOf(child.key) === -1) {\n                topo.add(child, { after: child._refs, group: child.key });\n            }\n        }\n    }\n\n    for (let i = 0; i < children.length; ++i) {\n        const key = children[i];\n        const child = schema[key];\n        try {\n            const cast = Cast.schema(child);\n            topo.add({ key: key, schema: cast }, { after: cast._refs, group: key });\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.path = key + '.' + castErr.path;\n            }\n            else {\n                castErr.path = key;\n            }\n            throw castErr;\n        }\n    }\n\n    obj._inner.children = topo.nodes;\n\n    return obj;\n};\n\n\ninternals.Object.prototype.unknown = function (allow) {\n\n    const obj = this.clone();\n    obj._flags.allowUnknown = (allow !== false);\n    return obj;\n};\n\n\ninternals.Object.prototype.length = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('length', limit, (value, state, options) => {\n\n        if (Object.keys(value).length === limit) {\n            return null;\n        }\n\n        return Errors.create('object.length', { limit: limit }, state, options);\n    });\n};\n\n\ninternals.Object.prototype.min = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('min', limit, (value, state, options) => {\n\n        if (Object.keys(value).length >= limit) {\n            return null;\n        }\n\n        return Errors.create('object.min', { limit: limit }, state, options);\n    });\n};\n\n\ninternals.Object.prototype.max = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('max', limit, (value, state, options) => {\n\n        if (Object.keys(value).length <= limit) {\n            return null;\n        }\n\n        return Errors.create('object.max', { limit: limit }, state, options);\n    });\n};\n\n\ninternals.Object.prototype.pattern = function (pattern, schema) {\n\n    Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');\n    Hoek.assert(schema !== undefined, 'Invalid rule');\n\n    pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\n\n    try {\n        schema = Cast.schema(schema);\n    }\n    catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n            castErr.message = castErr.message + '(' + castErr.path + ')';\n        }\n\n        throw castErr;\n    }\n\n\n    const obj = this.clone();\n    obj._inner.patterns.push({ regex: pattern, rule: schema });\n    return obj;\n};\n\n\ninternals.Object.prototype.with = function (key, peers) {\n\n    return this._dependency('with', key, peers);\n};\n\n\ninternals.Object.prototype.without = function (key, peers) {\n\n    return this._dependency('without', key, peers);\n};\n\n\ninternals.Object.prototype.xor = function () {\n\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('xor', null, peers);\n};\n\n\ninternals.Object.prototype.or = function () {\n\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('or', null, peers);\n};\n\n\ninternals.Object.prototype.and = function () {\n\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('and', null, peers);\n};\n\n\ninternals.Object.prototype.nand = function () {\n\n    const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this._dependency('nand', null, peers);\n};\n\n\ninternals.Object.prototype.requiredKeys = function (children) {\n\n    children = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this.applyFunctionToChildren(children, 'required');\n};\n\n\ninternals.Object.prototype.optionalKeys = function (children) {\n\n    children = Hoek.flatten(Array.prototype.slice.call(arguments));\n    return this.applyFunctionToChildren(children, 'optional');\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.Object.prototype.rename = function (from, to, options) {\n\n    Hoek.assert(typeof from === 'string', 'Rename missing the from argument');\n    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n        Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.renames.push({\n        from: from,\n        to: to,\n        options: Hoek.applyToDefaults(internals.renameDefaults, options || {})\n    });\n\n    return obj;\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) {\n\n    children = [].concat(children);\n    Hoek.assert(children.length > 0, 'expected at least one children');\n\n    const groupedChildren = internals.groupChildren(children);\n    let obj;\n\n    if ('' in groupedChildren) {\n        obj = this[fn].apply(this, args);\n        delete groupedChildren[''];\n    }\n    else {\n        obj = this.clone();\n    }\n\n    if (obj._inner.children) {\n        root = root ? (root + '.') : '';\n\n        for (let i = 0; i < obj._inner.children.length; ++i) {\n            const child = obj._inner.children[i];\n            const group = groupedChildren[child.key];\n\n            if (group) {\n                obj._inner.children[i] = {\n                    key: child.key,\n                    _refs: child._refs,\n                    schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                };\n\n                delete groupedChildren[child.key];\n            }\n        }\n    }\n\n    const remaining = Object.keys(groupedChildren);\n    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n    return obj;\n};\n\n\ninternals.Object.prototype._dependency = function (type, key, peers) {\n\n    peers = [].concat(peers);\n    for (let i = 0; i < peers.length; ++i) {\n        Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n    }\n\n    const obj = this.clone();\n    obj._inner.dependencies.push({ type: type, key: key, peers: peers });\n    return obj;\n};\n\n\ninternals.with = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return null;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            return Errors.create('object.with', { peer: peer }, state, options);\n        }\n    }\n\n    return null;\n};\n\n\ninternals.without = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return null;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            return Errors.create('object.without', { peer: peer }, state, options);\n        }\n    }\n\n    return null;\n};\n\n\ninternals.xor = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return null;\n    }\n\n    if (present.length === 0) {\n        return Errors.create('object.missing', { peers: peers }, state, options);\n    }\n\n    return Errors.create('object.xor', { peers: peers }, state, options);\n};\n\n\ninternals.or = function (value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n            return null;\n        }\n    }\n\n    return Errors.create('object.missing', { peers: peers }, state, options);\n};\n\n\ninternals.and = function (value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n    return !aon ? Errors.create('object.and', { present: present, missing: missing }, state, options) : null;\n};\n\n\ninternals.nand = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const values = Hoek.clone(peers);\n    const main = values.splice(0, 1)[0];\n    const allPresent = (present.length === peers.length);\n    return allPresent ? Errors.create('object.nand', { main: main, peers: values }, state, options) : null;\n};\n\n\ninternals.Object.prototype.describe = function (shallow) {\n\n    const description = Any.prototype.describe.call(this);\n\n    if (this._inner.children &&\n        !shallow) {\n\n        description.children = {};\n        for (let i = 0; i < this._inner.children.length; ++i) {\n            const child = this._inner.children[i];\n            description.children[child.key] = child.schema.describe();\n        }\n    }\n\n    if (this._inner.dependencies.length) {\n        description.dependencies = Hoek.clone(this._inner.dependencies);\n    }\n\n    if (this._inner.patterns.length) {\n        description.patterns = [];\n\n        for (let i = 0; i < this._inner.patterns.length; ++i) {\n            const pattern = this._inner.patterns[i];\n            description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n        }\n    }\n\n    return description;\n};\n\n\ninternals.Object.prototype.assert = function (ref, schema, message) {\n\n    ref = Cast.ref(ref);\n    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n    message = message || 'pass the assertion test';\n\n    let cast;\n    try {\n        cast = Cast.schema(schema);\n    }\n    catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n            castErr.message = castErr.message + '(' + castErr.path + ')';\n        }\n\n        throw castErr;\n    }\n\n    const key = ref.path[ref.path.length - 1];\n    const path = ref.path.join('.');\n\n    return this._test('assert', { cast: cast, ref: ref }, (value, state, options) => {\n\n        const result = cast._validate(ref(value), null, options, value);\n        if (!result.errors) {\n            return null;\n        }\n\n        const localState = Hoek.merge({}, state);\n        localState.key = key;\n        localState.path = path;\n        return Errors.create('object.assert', { ref: localState.path, message: message }, localState, options);\n    });\n};\n\n\ninternals.Object.prototype.type = function (constructor, name) {\n\n    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n    name = name || constructor.name;\n\n    return this._test('type', name, (value, state, options) => {\n\n        if (value instanceof constructor) {\n            return null;\n        }\n\n        return Errors.create('object.type', { type: name }, state, options);\n    });\n};\n\n\nmodule.exports = new internals.Object();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/object.js\n **/","'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Topo = function () {\n\n    this._items = [];\n    this.nodes = [];\n};\n\n\ninternals.Topo.prototype.add = function (nodes, options) {\n\n    options = options || {};\n\n    // Validate rules\n\n    const before = [].concat(options.before || []);\n    const after = [].concat(options.after || []);\n    const group = options.group || '?';\n    const sort = options.sort || 0;                   // Used for merging only\n\n    Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);\n    Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');\n    Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);\n    Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');\n\n    ([].concat(nodes)).forEach((node, i) => {\n\n        const item = {\n            seq: this._items.length,\n            sort: sort,\n            before: before,\n            after: after,\n            group: group,\n            node: node\n        };\n\n        this._items.push(item);\n    });\n\n    // Insert event\n\n    const error = this._sort();\n    Hoek.assert(!error, 'item', (group !== '?' ? 'added into group ' + group : ''), 'created a dependencies error');\n\n    return this.nodes;\n};\n\n\ninternals.Topo.prototype.merge = function (others) {\n\n    others = [].concat(others);\n    for (let i = 0; i < others.length; ++i) {\n        const other = others[i];\n        if (other) {\n            for (let j = 0; j < other._items.length; ++j) {\n                const item = Hoek.shallow(other._items[j]);\n                this._items.push(item);\n            }\n        }\n    }\n\n    // Sort items\n\n    this._items.sort(internals.mergeSort);\n    for (let i = 0; i < this._items.length; ++i) {\n        this._items[i].seq = i;\n    }\n\n    const error = this._sort();\n    Hoek.assert(!error, 'merge created a dependencies error');\n\n    return this.nodes;\n};\n\n\ninternals.mergeSort = function (a, b) {\n\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\n};\n\n\ninternals.Topo.prototype._sort = function () {\n\n    // Construct graph\n\n    const groups = {};\n    const graph = {};\n    const graphAfters = {};\n\n    for (let i = 0; i < this._items.length; ++i) {\n        const item = this._items[i];\n        const seq = item.seq;                         // Unique across all items\n        const group = item.group;\n\n        // Determine Groups\n\n        groups[group] = groups[group] || [];\n        groups[group].push(seq);\n\n        // Build intermediary graph using 'before'\n\n        graph[seq] = item.before;\n\n        // Build second intermediary graph with 'after'\n\n        const after = item.after;\n        for (let j = 0; j < after.length; ++j) {\n            graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n        }\n    }\n\n    // Expand intermediary graph\n\n    let graphNodes = Object.keys(graph);\n    for (let i = 0; i < graphNodes.length; ++i) {\n        const node = graphNodes[i];\n        const expandedGroups = [];\n\n        const graphNodeItems = Object.keys(graph[node]);\n        for (let j = 0; j < graphNodeItems.length; ++j) {\n            const group = graph[node][graphNodeItems[j]];\n            groups[group] = groups[group] || [];\n\n            for (let k = 0; k < groups[group].length; ++k) {\n\n                expandedGroups.push(groups[group][k]);\n            }\n        }\n        graph[node] = expandedGroups;\n    }\n\n    // Merge intermediary graph using graphAfters into final graph\n\n    const afterNodes = Object.keys(graphAfters);\n    for (let i = 0; i < afterNodes.length; ++i) {\n        const group = afterNodes[i];\n\n        if (groups[group]) {\n            for (let j = 0; j < groups[group].length; ++j) {\n                const node = groups[group][j];\n                graph[node] = graph[node].concat(graphAfters[group]);\n            }\n        }\n    }\n\n    // Compile ancestors\n\n    let children;\n    const ancestors = {};\n    graphNodes = Object.keys(graph);\n    for (let i = 0; i < graphNodes.length; ++i) {\n        const node = graphNodes[i];\n        children = graph[node];\n\n        for (let j = 0; j < children.length; ++j) {\n            ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n        }\n    }\n\n    // Topo sort\n\n    const visited = {};\n    const sorted = [];\n\n    for (let i = 0; i < this._items.length; ++i) {\n        let next = i;\n\n        if (ancestors[i]) {\n            next = null;\n            for (let j = 0; j < this._items.length; ++j) {\n                if (visited[j] === true) {\n                    continue;\n                }\n\n                if (!ancestors[j]) {\n                    ancestors[j] = [];\n                }\n\n                const shouldSeeCount = ancestors[j].length;\n                let seenCount = 0;\n                for (let k = 0; k < shouldSeeCount; ++k) {\n                    if (sorted.indexOf(ancestors[j][k]) >= 0) {\n                        ++seenCount;\n                    }\n                }\n\n                if (seenCount === shouldSeeCount) {\n                    next = j;\n                    break;\n                }\n            }\n        }\n\n        if (next !== null) {\n            next = next.toString();         // Normalize to string TODO: replace with seq\n            visited[next] = true;\n            sorted.push(next);\n        }\n    }\n\n    if (sorted.length !== this._items.length) {\n        return new Error('Invalid dependencies');\n    }\n\n    const seqIndex = {};\n    for (let i = 0; i < this._items.length; ++i) {\n        const item = this._items[i];\n        seqIndex[item.seq] = item;\n    }\n\n    const sortedNodes = [];\n    this._items = sorted.map((value) => {\n\n        const sortedItem = seqIndex[value];\n        sortedNodes.push(sortedItem.node);\n        return sortedItem;\n    });\n\n    this.nodes = sortedNodes;\n};\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/~/topo/lib/index.js\n **/","'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Cast = require('./cast');\nconst Errors = require('./errors');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.Array = function () {\n\n    Any.call(this);\n    this._type = 'array';\n    this._inner.items = [];\n    this._inner.ordereds = [];\n    this._inner.inclusions = [];\n    this._inner.exclusions = [];\n    this._inner.requireds = [];\n    this._flags.sparse = false;\n};\n\nHoek.inherits(internals.Array, Any);\n\n\ninternals.Array.prototype._base = function (value, state, options) {\n\n    const result = {\n        value: value\n    };\n\n    if (typeof value === 'string' &&\n        options.convert) {\n\n        try {\n            const converted = JSON.parse(value);\n            if (Array.isArray(converted)) {\n                result.value = converted;\n            }\n        }\n        catch (e) { }\n    }\n\n    let isArray = Array.isArray(result.value);\n    const wasArray = isArray;\n    if (options.convert && this._flags.single && !isArray) {\n        result.value = [result.value];\n        isArray = true;\n    }\n\n    if (!isArray) {\n        result.errors = Errors.create('array.base', null, state, options);\n        return result;\n    }\n\n    if (this._inner.inclusions.length ||\n        this._inner.exclusions.length ||\n        !this._flags.sparse) {\n\n        // Clone the array so that we don't modify the original\n        if (wasArray) {\n            result.value = result.value.slice(0);\n        }\n\n        result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);\n\n        if (result.errors && wasArray && options.convert && this._flags.single) {\n\n            // Attempt a 2nd pass by putting the array inside one.\n            const previousErrors = result.errors;\n\n            result.value = [result.value];\n            result.errors = internals.checkItems.call(this, result.value, wasArray, state, options);\n\n            if (result.errors) {\n\n                // Restore previous errors and value since this didn't validate either.\n                result.errors = previousErrors;\n                result.value = result.value[0];\n            }\n        }\n    }\n\n    return result;\n};\n\n\ninternals.checkItems = function (items, wasArray, state, options) {\n\n    const errors = [];\n    let errored;\n\n    const requireds = this._inner.requireds.slice();\n    const ordereds = this._inner.ordereds.slice();\n    const inclusions = this._inner.inclusions.concat(requireds);\n\n    let il = items.length;\n    for (let i = 0; i < il; ++i) {\n        errored = false;\n        const item = items[i];\n        let isValid = false;\n        const localState = { key: i, path: (state.path ? state.path + '.' : '') + i, parent: items, reference: state.reference };\n        let res;\n\n        // Sparse\n\n        if (!this._flags.sparse && item === undefined) {\n            errors.push(Errors.create('array.sparse', null, { key: state.key, path: localState.path }, options));\n\n            if (options.abortEarly) {\n                return errors;\n            }\n\n            continue;\n        }\n\n        // Exclusions\n\n        for (let j = 0; j < this._inner.exclusions.length; ++j) {\n            res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults\n\n            if (!res.errors) {\n                errors.push(Errors.create(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n                errored = true;\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n\n                break;\n            }\n        }\n\n        if (errored) {\n            continue;\n        }\n\n        // Ordered\n        if (this._inner.ordereds.length) {\n            if (ordereds.length > 0) {\n                const ordered = ordereds.shift();\n                res = ordered._validate(item, localState, options);\n                if (!res.errors) {\n                    if (ordered._flags.strip) {\n                        internals.fastSplice(items, i);\n                        --i;\n                        --il;\n                    }\n                    else {\n                        items[i] = res.value;\n                    }\n                }\n                else {\n                    errors.push(Errors.create('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n                }\n                continue;\n            }\n            else if (!this._inner.items.length) {\n                errors.push(Errors.create('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));\n                if (options.abortEarly) {\n                    return errors;\n                }\n                continue;\n            }\n        }\n\n        // Requireds\n\n        const requiredChecks = [];\n        let jl = requireds.length;\n        for (let j = 0; j < jl; ++j) {\n            res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n            if (!res.errors) {\n                items[i] = res.value;\n                isValid = true;\n                internals.fastSplice(requireds, j);\n                --j;\n                --jl;\n                break;\n            }\n        }\n\n        if (isValid) {\n            continue;\n        }\n\n        // Inclusions\n\n        jl = inclusions.length;\n        for (let j = 0; j < jl; ++j) {\n            const inclusion = inclusions[j];\n\n            // Avoid re-running requireds that already didn't match in the previous loop\n            const previousCheck = requireds.indexOf(inclusion);\n            if (previousCheck !== -1) {\n                res = requiredChecks[previousCheck];\n            }\n            else {\n                res = inclusion._validate(item, localState, options);\n\n                if (!res.errors) {\n                    if (inclusion._flags.strip) {\n                        internals.fastSplice(items, i);\n                        --i;\n                        --il;\n                    }\n                    else {\n                        items[i] = res.value;\n                    }\n                    isValid = true;\n                    break;\n                }\n            }\n\n            // Return the actual error if only one inclusion defined\n            if (jl === 1) {\n                if (options.stripUnknown) {\n                    internals.fastSplice(items, i);\n                    --i;\n                    --il;\n                    isValid = true;\n                    break;\n                }\n\n                errors.push(Errors.create(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                errored = true;\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n\n                break;\n            }\n        }\n\n        if (errored) {\n            continue;\n        }\n\n        if (this._inner.inclusions.length && !isValid) {\n            if (options.stripUnknown) {\n                internals.fastSplice(items, i);\n                --i;\n                --il;\n                continue;\n            }\n\n            errors.push(Errors.create(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\n            if (options.abortEarly) {\n                return errors;\n            }\n        }\n    }\n\n    if (requireds.length) {\n        internals.fillMissedErrors(errors, requireds, state, options);\n    }\n\n    if (ordereds.length) {\n        internals.fillOrderedErrors(errors, ordereds, state, options);\n    }\n\n    return errors.length ? errors : null;\n};\n\n\ninternals.fillMissedErrors = function (errors, requireds, state, options) {\n\n    const knownMisses = [];\n    let unknownMisses = 0;\n    for (let i = 0; i < requireds.length; ++i) {\n        const label = Hoek.reach(requireds[i], '_settings.language.label');\n        if (label) {\n            knownMisses.push(label);\n        }\n        else {\n            ++unknownMisses;\n        }\n    }\n\n    if (knownMisses.length) {\n        if (unknownMisses) {\n            errors.push(Errors.create('array.includesRequiredBoth', { knownMisses: knownMisses, unknownMisses: unknownMisses }, { key: state.key, path: state.patk }, options));\n        }\n        else {\n            errors.push(Errors.create('array.includesRequiredKnowns', { knownMisses: knownMisses }, { key: state.key, path: state.path }, options));\n        }\n    }\n    else {\n        errors.push(Errors.create('array.includesRequiredUnknowns', { unknownMisses: unknownMisses }, { key: state.key, path: state.path }, options));\n    }\n};\n\n\ninternals.fillOrderedErrors = function (errors, ordereds, state, options) {\n\n    const requiredOrdereds = [];\n\n    for (let i = 0; i < ordereds.length; ++i) {\n        const presence = Hoek.reach(ordereds[i], '_flags.presence');\n        if (presence === 'required') {\n            requiredOrdereds.push(ordereds[i]);\n        }\n    }\n\n    if (requiredOrdereds.length) {\n        internals.fillMissedErrors(errors, requiredOrdereds, state, options);\n    }\n};\n\ninternals.Array.prototype.describe = function () {\n\n    const description = Any.prototype.describe.call(this);\n\n    if (this._inner.ordereds.length) {\n        description.orderedItems = [];\n\n        for (let i = 0; i < this._inner.ordereds.length; ++i) {\n            description.orderedItems.push(this._inner.ordereds[i].describe());\n        }\n    }\n\n    if (this._inner.items.length) {\n        description.items = [];\n\n        for (let i = 0; i < this._inner.items.length; ++i) {\n            description.items.push(this._inner.items[i].describe());\n        }\n    }\n\n    return description;\n};\n\n\ninternals.Array.prototype.items = function () {\n\n    const obj = this.clone();\n\n    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((type, index) => {\n\n        try {\n            type = Cast.schema(type);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.path = index + '.' + castErr.path;\n            }\n            else {\n                castErr.path = index;\n            }\n            castErr.message = castErr.message + '(' + castErr.path + ')';\n            throw castErr;\n        }\n\n        obj._inner.items.push(type);\n\n        if (type._flags.presence === 'required') {\n            obj._inner.requireds.push(type);\n        }\n        else if (type._flags.presence === 'forbidden') {\n            obj._inner.exclusions.push(type.optional());\n        }\n        else {\n            obj._inner.inclusions.push(type);\n        }\n    });\n\n    return obj;\n};\n\n\ninternals.Array.prototype.ordered = function () {\n\n    const obj = this.clone();\n\n    Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((type, index) => {\n\n        try {\n            type = Cast.schema(type);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.path = index + '.' + castErr.path;\n            }\n            else {\n                castErr.path = index;\n            }\n            castErr.message = castErr.message + '(' + castErr.path + ')';\n            throw castErr;\n        }\n        obj._inner.ordereds.push(type);\n    });\n\n    return obj;\n};\n\n\ninternals.Array.prototype.min = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('min', limit, (value, state, options) => {\n\n        if (value.length >= limit) {\n            return null;\n        }\n\n        return Errors.create('array.min', { limit: limit, value: value }, state, options);\n    });\n};\n\n\ninternals.Array.prototype.max = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('max', limit, (value, state, options) => {\n\n        if (value.length <= limit) {\n            return null;\n        }\n\n        return Errors.create('array.max', { limit: limit, value: value }, state, options);\n    });\n};\n\n\ninternals.Array.prototype.length = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('length', limit, (value, state, options) => {\n\n        if (value.length === limit) {\n            return null;\n        }\n\n        return Errors.create('array.length', { limit: limit, value: value }, state, options);\n    });\n};\n\n\ninternals.Array.prototype.unique = function () {\n\n    return this._test('unique', undefined, (value, state, options) => {\n\n        const found = {\n            string: {},\n            number: {},\n            undefined: {},\n            boolean: {},\n            object: [],\n            function: []\n        };\n\n        for (let i = 0; i < value.length; ++i) {\n            const item = value[i];\n            const type = typeof item;\n            const records = found[type];\n\n            // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n            // I still want to keep the test for future js versions with new types (eg. Symbol).\n            if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {\n                if (Array.isArray(records)) {\n                    for (let j = 0; j < records.length; ++j) {\n                        if (Hoek.deepEqual(records[j], item)) {\n                            return Errors.create('array.unique', { pos: i, value: item }, state, options);\n                        }\n                    }\n\n                    records.push(item);\n                }\n                else {\n                    if (records[item]) {\n                        return Errors.create('array.unique', { pos: i, value: item }, state, options);\n                    }\n\n                    records[item] = true;\n                }\n            }\n        }\n    });\n};\n\n\ninternals.Array.prototype.sparse = function (enabled) {\n\n    const obj = this.clone();\n    obj._flags.sparse = enabled === undefined ? true : !!enabled;\n    return obj;\n};\n\n\ninternals.Array.prototype.single = function (enabled) {\n\n    const obj = this.clone();\n    obj._flags.single = enabled === undefined ? true : !!enabled;\n    return obj;\n};\n\n\nmodule.exports = new internals.Array();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/array.js\n **/","'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Errors = require('./errors');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Binary = function () {\n\n    Any.call(this);\n    this._type = 'binary';\n};\n\nHoek.inherits(internals.Binary, Any);\n\n\ninternals.Binary.prototype._base = function (value, state, options) {\n\n    const result = {\n        value: value\n    };\n\n    if (typeof value === 'string' &&\n        options.convert) {\n\n        try {\n            const converted = new Buffer(value, this._flags.encoding);\n            result.value = converted;\n        }\n        catch (e) { }\n    }\n\n    result.errors = Buffer.isBuffer(result.value) ? null : Errors.create('binary.base', null, state, options);\n    return result;\n};\n\n\ninternals.Binary.prototype.encoding = function (encoding) {\n\n    Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n    const obj = this.clone();\n    obj._flags.encoding = encoding;\n    return obj;\n};\n\n\ninternals.Binary.prototype.min = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('min', limit, (value, state, options) => {\n\n        if (value.length >= limit) {\n            return null;\n        }\n\n        return Errors.create('binary.min', { limit: limit, value: value }, state, options);\n    });\n};\n\n\ninternals.Binary.prototype.max = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('max', limit, (value, state, options) => {\n\n        if (value.length <= limit) {\n            return null;\n        }\n\n        return Errors.create('binary.max', { limit: limit, value: value }, state, options);\n    });\n};\n\n\ninternals.Binary.prototype.length = function (limit) {\n\n    Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n    return this._test('length', limit, (value, state, options) => {\n\n        if (value.length === limit) {\n            return null;\n        }\n\n        return Errors.create('binary.length', { limit: limit, value: value }, state, options);\n    });\n};\n\n\nmodule.exports = new internals.Binary();\n\n\n\n/** WEBPACK FOOTER **\n ** D:/Web/home/bisubus/joi-browser/lib/binary.js\n **/"],"sourceRoot":""}